* Customizing Emacs

When Emacs starts, it reads and executes the contents of the .emacs file in your home directory.

** Lisp :lisp:

the language of the .emacs file.

It is traditionally associated with artificial intelligence applications, for which Lisp is well-suited because it permits symbolic computation, =can treat code as data=, and simplifies building very complicated data structures.

The word expression usually means any piece of Lisp code or any Lisp data structure. All Lisp expressions, whether code or data, can be evaluated by the Lisp interpreter built into Emacs to make them yield some computational result.


Among the features that distinguish Lisp from other programming languages are:

*** Fully-parenthesized prefix notation

All expressions and function calls in Lisp are surrounded by parentheses,* and the function
name always precedes the arguments to the function.

#+begin_src emacs-lisp
  ;;(Comments in Lisp are introduced with a semicolon and continue to the end of the line.)
  ;;to apply the + function to the arguments x and y, in Lisp you write
  (+ x y )
#+end_src



#+begin_src emacs-lisp

    ;;1.Though unfamiliar, prefix notation has some benefits over infix notation. In infix languages, ;;to write the sum of five variables you need four plus signs:
    ;;a+b+c+d+e
    ;;Lisp is more concise:
    (+ a b c d e)

    ;;2.Also, questions of operator precedence do not arise.
    ;;For example, is the value of 3 + 4 * 5 35 or 23? It depends on whether * has higher precedence than +.
    ;;But in Lisp, the confusion vanishes:
    (+ 3 (* 4 5)) ;result is 23
    (* (+ 3 4) 5) ;result is 35

    ;;3.Finally, while infix languages need commas to separate the arguments to a function:
    ;;foo(3 + 4, 5 + 6)~
    ;;Lisp doesn't need that extra bit of syntax:
    (foo (+ 3 4) (+ 5 6))
#+end_src

*** List data type

Lisp has a built-in data type called a list.

A list is a Lisp object containing zero or more other Lisp objects, surrounded by parentheses.

#+begin_src emacs-lisp
  (hello there) ;; list containing two "symbols"

  (1 2 "xyz") ;; two numbers and a string

  (a (b c)) ;; a symbol and a sublist (containing two symbols)

  () ;; the empty list
#+end_src

Lists can be assigned to variables, passed as arguments to functions and returned from
them, constructed with such functions as =cons= and =append=, and taken apart with such
functions as =car= and =cdr=.

*** Garbage collection

Lisp is a garbage-collected language, which means that Lisp itself automatically reclaims the memory used by your program's data structures.

** Keys and Strings

Backspace and Delete

To Emacs, what matters isn't the label but the numeric character code that the key generates when pressed.

Regardless of the label on the key, the "move left and erase the previous character" key may generate an ASCII "backspace" code (decimal 8, usually denoted BS) or an ASCII "delete" code (decimal 127, usually denoted DEL).

In its default configuration, Emacs believes only DEL is the code meaning "move left and erase the previous character."

The first thing we'll look at is adding some code to .emacs to make BS and DEL both do "back up and erase a character," moving the Help command to some other key.

The goal of this chapter is to make any BS-generating key work the same as any DEL-generating key.

*** Binding Keystrokes to Commands

In Emacs, every keystroke invokes a command or is part of a multiple-key sequence that invokes a command.

Commands are special kinds of Lisp functions, as we will see.

One Lisp function for doing this is ~global-set-key~.

#+begin_src emacs-lisp

  ;;Remember that a function call in Lisp is simply a parenthesized list.
  ;;The first element of the list is the name of the function, and any remaining elements are the arguments.
  (global-set-key keysequence command)

#+end_src

**** Denoting Keys in Strings

| "xyz" ; three-character string                                   |
| "I said, \"Look out!\""                                          |

An ordinary key is denoted by writing the character in a string. 

| the keystroke q is denoted in Lisp by the string "q"                                         |
| The keystroke \ would be written as "\\".                                                    |
| META-question-mark are denoted in strings using a special syntax: "\M-?".                    |
| M- x is shorthand for META- x, and "\M-x" is the string version                              |
| CONTROL-x is abbreviated C- x in Emacs documentation, and in strings is written as: "\C-x ". |
| CONTROL- x is also sometimes abbreviated ^x in documentation, string syntax: "\^x".          |
| CONTROL META-x is denoted C-M- x and is written as ''\C-\M- x " in strings                   |

One other way to write the keysequence "\M-?" is "\e?".

The string "\e" denotes the escape character, and M- x is the same as ESC x.

In Lisp, functions are named with symbols.

Symbols are like function names or variable names in other languages, although Lisp allows a wider variety of characters in symbols than most languages allow in their variable names.

For instance, legal Lisp symbols include =let*= and =up&down-p=.

** Check keystroke bound command

=C-h b=, which invokes another command called describe-bindings

** The right way to bind keystroke to command :lisp:

Our Lisp example is almost complete, but we can't just write

#+begin_src emacs-lisp

  (global-set-key "\M-?" help-command) ; almost right!
  
#+end_src


=This is wrong because of the way symbols are interpreted when they appear in Lisp
expressions.=

    - =If a symbol appears in the first position of a list, it's the name of a function to
    execute.!!!=
    - =If it appears elsewhere, it's a variable whose value needs to be retrieved.!!!=

But when we run global-set-key as shown, we don't want the value contained in help-command, whatever that may be. The value we want is the symbol help-command itself.

In short, we wish to prevent the symbol from being evaluated before it's passed to global-set-key.

After all, as far as we know, help-command doesn't have a value as a variable.

=The way to prevent a symbol (or any Lisp expression) from being evaluated is to quote it by
preceding it with a single quote (').=

#+begin_src emacs-lisp

  (global-set-key "\M-?" 'help-command)
  
#+end_src

Incidentally, to illustrate the difference between quoting and not quoting, the same effect could be achieved with

#+begin_src emacs-lisp

  (setq x 'help-command) ; setq assigns a variable
  (global-set-key "\M-?" x) ; usex's value

#+end_src

=Symbols aren't the only things that may follow a ' character; any Lisp expression can be quoted, including lists, numbers, strings, and other kinds of expressions we'll learn about later. Writing 'expr is shorthand for=

#+begin_src emacs-lisp

  (quote expr)

#+end_src

=which, when evaluated, yields expr.=

You might have noticed that a quote is required before the symbol help-command but not before the string argument, "\M-?". =This is because in Lisp, strings are self-evaluating, which means that when the string is evaluated, the result is the string itself.= So quoting it, while harmless, is redundant. =Numbers, characters, and vectors are other types of self-evaluating Lisp expressions.=

#+begin_src emacs-lisp

  ;;finally
  (global-set-key "\M-?" 'help-command)
  (global-set-key "\C-h" delete-backward-char)

#+end_src

** Evaluating Lisp Expressions

There are several ways to explicitly evaluate Lisp expressions.

- You can put the Lisp expressions in a file, then load the file.
  ~M-x load-file RET xxx.el RET~
- use the command ~eval-last-sexp~

  Sexp is an abbreviation for S-expression, which in turn is short for symbolic expression, which is another name for "Lisp expression."

  bound to =C-x C-e=

  This command evaluates the Lisp expression to the left of the cursor.

- use the command ~eval-expression~

  bound to =M-:=

  #+begin_src emacs-lisp

    (put 'eval-expression 'disabled nil)

  #+end_src

 (The =put= function relates to property lists, which we'll see in the section on "Symbol Properties" in Chapter 3.)

- use the *scratch* buffer

The buffer is in =Lisp Interaction mode=

In this mode, pressing =C-j= invokes ~eval-print-last-sexp~, which is like ~eval-lastsexp~ except that the result of the evaluation is inserted into the buffer at the location of the cursor

Another feature of Lisp Interaction mode is =its ability to complete a partially typed Lisp symbol= when you press =M-TAB= (which invokes ~lisp-complete-symbol~).

** Apropos

Allows you to search all known variables and functions for a pattern you specify.

~M-x apropos RET pattern RET~

For historical reasons, the way to write the DEL character is CONTROL-question-mark

You may invoke apropos with a prefix argument.

In Emacs, pressing C-u before executing a command is a way to pass extra information to the command. Frequently, C-u is followed by a number;

for instance, C-u 5 C-b means "move the cursor left 5 characters." Sometimes the extra information is just the fact that you pressed C-u.

When apropos is invoked with a prefix argument, it not only reports Emacs functions and
variables that match the search pattern, it also reports any existing keybindings for each
command in the list.

~C-u M-x apropos RET pattern RET~

we can further limit the scope of the search by using ~command-apropos~ (C-h a) instead of ~apropos~.

The difference between a command and other Lisp functions is that commands have been written specially to be invoked interactively, i.e., from a keybinding or with M-x. Functions that aren't commands can only be invoked as function calls from other Lisp code or by such commands as ~eval-expression~ and ~eval-last-sexp~.

* Simple New Commands

In this chapter we'll develop several very small Lisp functions and commands, introducing a wealth of concepts.

** define a lisp function :lisp:

check =The right way to bind keystroke to command=

#+begin_src emacs-lisp
  (defun function_name (function's parameter list)

    ;;(defun function_name (&optional function's parameter list)
    ;;The keyword &optional appearing in a parameter list means that all subsequent parameters are optional.
    ;; The function may be called with or without a value for an optional parameter.
    ;;If no value is given, the optional parameter gets the special value nil.

    ;;Emacs displays the docstring when showing online help about the function, as with the commands describe-function (C-h f) or apropos.
    "function's documentation string or docstring"

    (interactive);;It's optional, It distinguishes this function as an interactive command
    ;;A command, in Emacs, is a Lisp function that can be invoked interactively, which means it can be invoked from a keybinding or by typing M-x command-name.
    ;;Not all Lisp functions are commands, but all commands are Lisp functions.
    ;;Any Lisp function, including interactive commands, can be invoked from within other Lisp code using the (function arg . . . ) syntax.
    ;;Check [[** The right way to bind keystroke to command]]
    ;;A function is turned into an interactive command by using the special (interactive) expression at the beginning of the function definition (after the optional docstring).

    ;;An interactive command is, as we have observed, a kind of Lisp function.
    ;;That means that the command may take arguments.
    ;;Passing arguments to a function from Lisp is easy; they simply get written down in the function call, as in (other-window -1).

    ;;But what if the function is invoked as an interactive command? Where do the arguments come from then? Answering this question is the purpose of the interactive declaration.
    ;;The argument to interactive describes how to obtain arguments for the command that contains it.
    ;; - When the command takes no arguments, then i interactive has no arguments, as in our first draft of other-window-backward.
    ;; - When the command does take arguments, then interactive takes one argument: a string of code letters, one code letter per argument being described.
    ;;   - The code letter p used in this example means, "if there is a prefix argument, interpret it as a number, and if there is no prefix argument, interpret that as the number 1."
    ;;     (interactive "p")


    ;;(function arg ...)
    (Lisp Expression))
#+end_src

** nil :lisp:
*** It designates falsehood

  In the Lisp structures that test a true\/false condition—if, cond, while, and, or, and not-a value of nil means "false" and any other value means "true."

  #+begin_src emacs-lisp

    ;;Lisp's version of an if-then-else statement
    (if n 
        (other-window (- n)) 
      (other-window -1))
    ;;first n is evaluated
    ;;   If the value of n is true (non-nil), then (other-window (- n)) is evaluated,
    ;;   otherwise (other-window -1) is evaluated

  #+end_src

There is another =symbol, t= , that designates truth

*** It is indistinguishable from the empty list

Inside the Lisp interpreter, the symbol nil and the empty list ( ) are the same object. 

If you call ~listp~, which tests whether its argument is a list, on the symbol nil, you'll get the result t, which means truth. listp == list predict

Likewise, if you call ~symbolp~ , which tests whether its argument is a symbol, on the empty list, you'll get t again.

*** It is its own value

  When you evaluate the symbol nil, the result is nil.

For this reason, unlike other symbols, nil doesn't need to be quoted when you want its name instead of its value, because its name is the same as its value.

#+begin_src emacs-lisp

  (setq x nil) ;;assign nil to variable x
  ;;instead of (setq x 'nil)

#+end_src

There is a symbol, t, for designating truth. =Like nil, t is its own value and doesn't need to be quoted.=

And also unlike nil, which is the only way to denote falsehood, all other Lisp values denote truth just like t does.
  
** Condensing the Code :lisp:

#+begin_src emacs-lisp

  (if n ;; if this. . . 
      (other-window (- n)) ;;. . . then this 
    (other-window -1)) ;;. . . else this

#+end_src

Lisp version of an if-then-else statement

The first argument to if is a test.

It is evaluated to see whether it yields truth (any expression except nil) or falsehood (nil).

     If it's truth, the second argument-the "then" clause-is evaluated.

     If it's falsehood, the third argument—the "else" clause (which is optional)—is evaluated.

=The result of if is always the result of the last thing it evaluates.!!! 可以看成一个有返回值的if函数 ()是一个有返回值的表达式=

Observe that other-window is called in both branches (the "then" and the "else" clauses) of the if.In this case, we can make the if expression more concise by factoring out the common subexpressions.

#+begin_src emacs-lisp

  ;;We can therefore rewrite this expression as:
  (other-window (if n (- n) -1))

#+end_src

We can factor out common subexpressions again by observing that in both branches of the if, we're looking for the negative of something—either the negative of n or the negative of 1.

#+begin_src emacs-lisp

  (if n (- n) -1)
  ;;can become
  (- (if n n 1))

#+end_src

#+begin_src emacs-lisp

  ;;In general,
  (if test 
    (a b) 
   (a c))

  ;;can be shortened to

  (a (if test b c))

#+end_src

** Logical Expressions :lisp:

An old Lisp programmers' trick can now be used to make this expression even more concise:

#+begin_src emacs-lisp

  (if n n 1)
  ;;equal
  (or n 1)

#+end_src

=The function or= works like the logical "or" in most languages:

if all of its arguments are false, it returns falsehood, otherwise it returns truth.

But Lisp's =or= has an extra bit of usefulness:

=it evaluates each of its arguments in order until it finds one that's non-nil, then it returns that value. If it doesn't find one, it returns nil.=

=!!! 可以看成一个有返回值的or函数 ()是一个有返回值的表达式=

So the return value from or isn't merely false or true, =it's false or the first true value in the list.=

#+begin_src emacs-lisp

  ;;This means that generally speaking,
  (if a a b)
  ;;can be replaced by
  (or a b)

#+end_src

In fact, it often should be written that way because if a is true, =then (if a a b) will evaluate it twice whereas (or a b) won't.= (On the other hand, if you specifically want a evaluated twice, then of course you should use if.) In fact,

#+begin_src emacs-lisp

  (if a a ;; if a is true, return a
      (if b b ;; else if b is true, return b
          ;;. . . 
              (if y y z))) ;; else if y is true, return y, else z

  ;;(which might look artificial here but is actually a pretty common pattern in actual programs) can be changed to the following form.

  (or a b ... y z)

#+end_src

Similarly

#+begin_src emacs-lisp

  (if a
      (if b
          ;;. . .
              (if y z)))

  ;;(note that none of the ifs in this example has an "else" clause)!!! can also be written as

  (and a b . . . y z)

#+end_src

because =and(function)= works by evaluating each of its arguments in order until it finds one that's nil.

=If it finds one, it returns nil, and if it doesn't find one, it returns the value of the last argument.=

#+begin_src emacs-lisp

  ;;One other shorthand to watch out for: some programmers like to turn
  (if (and a b . . . y) z)
  into
  (and a b . . . y z)
  ;;but not me because, while they're functionally identical, the former has shades of meaning—"do z if a through y are all true"—that the latter doesn't, which could make it easier for a human reader to understand.
#+end_src

** defalias :lisp:

use ~defalias~ to refer to any Lisp function by a different name

#+begin_src emacs-lisp
(defalias 'new_name 'old_name)
#+end_src

There. Now we'll never have to deal with those ambiguous names again (=although the original names remain in addition to the new aliases=)

** Hooks :lisp:

For Emacs to make the buffer read-only when I first visit the file, I have to somehow tell Emacs, "execute a certain piece of Lisp code whenever I visit a file." The action of visiting a file should trigger a function I write. This is where =hooks= come in.

=A hook is an ordinary Lisp variable whose value is a list of functions that get executed under specific conditions.=

For instance, the variable ~write-file-hooks~ is a list of functions that Emacs executes whenever a buffer is saved, and ~post-command-hook~ is a list of functions to run after every interactive command. The hook that interests us most for this example is ~find-file-hooks~, which Emacs runs every time a new file is visited. (There are many more hooks, some of which we'll be looking at later in the book. =To discover what hooks are available, try M-x apropos RET hook RET.=)

The function ~add-hook~ adds a function to a hook variable.

=Functions that appear in hook variables take no arguments.=

** Traversing Windows

 dissatisfied with the keybinding C-x o, other-window

 What I really wanted was one keybinding meaning ="next window"= and a different keybinding meaning ="previous window."=

chose =C-x C-n= for "next window" and =C-x C-p= for "previous window." 

1.used the Help subcommand describe-key to see whether C-x C-n and C-x C-p were already bound to other commands

Binding them to commands for "next window" and "previous window" would override their default bindings. But since those aren't commands I use very often, I didn't mind losing the keybindings for them. =I can always execute them using M-x. Emacs 所有命令都可以通过M-x执行=

#+begin_src emacs-lisp

  (global-set-key "\C-x\C-n" 'other-window)

  ;;Defining a command to bind to C-x C-p was trickier.
  ;;There was no existing Emacs command meaning "move the cursor to the previous window."
  ;;Time to define one!

  (defun other-window-backward ( ) 
    "Select the previous window." ;;docstring 
    (interactive) ;; turned into an interactive command
    (other-window -1) ;;invokes the function other-window with an argument of -1.
    )

  ;;It's now possible to call it in Lisp programs by writing (other-window-backward);
  ;;to invoke it by typing M-x other-window-backward RET;
  ;;even to get help on it by typing M-? f other-window-backward RET.
  ;;Now all that's needed is the keybinding:

  (global-set-key "\C-x\C-p" 'other-window-backward)
#+end_src

*** Parameterizing other-window-backward

improve on it a bit

When using C-x o (or, now, C-x C-n) to invoke other-window, you can specify a numeric prefix argument n to change its behavior.

If n is given, other-window skips forward that many windows.

For instance, C-u 2 C-x C-n means "move to the second window following this one."

=As we've seen, n may be negative to skip backward some number of windows.=

#+begin_src emacs-lisp

  ;;In order to change it, we must parameterize the function to take one argument: the number of windows to skip.
  (defun other-window-backward (n) 
    "Select Nth previous window." ;;docstring 

    ;;An interactive command is, as we have observed, a kind of Lisp function.
    ;;That means that the command may take arguments.
    ;;Passing arguments to a function from Lisp is easy; they simply get written down in the function call, as in (other-window -1).

    ;;But what if the function is invoked as an interactive command? Where do the arguments come from then? Answering this question is the purpose of the interactive declaration.
    ;;The argument to interactive describes how to obtain arguments for the command that contains it.
    ;; - When the command takes no arguments, then i interactive has no arguments, as in our first draft of other-window-backward.
    ;; - When the command does take arguments, then interactive takes one argument: a string of code letters, one code letter per argument being described.
    ;;   - The code letter p used in this example means, "if there is a prefix argument, interpret it as a number, and if there is no prefix argument, interpret that as the number 1."
    ;;     The parameter n receives the result of this interpretation when the command is invoked.

    (interactive "p") ;; turned into an interactive command

    ;;(- n). This computes the negative of n by passing it to the function -.
    (other-window (- n)) ;;invokes the function other-window with an argument of -1.
    )
#+end_src

It's important to understand the difference between the two expressions (- n) and -1. =The first is a function call.= There must be a space between the function name and the argument. The
second expression is an integer constant. There may not be a space between the minus sign and
the 1.It is certainly possible to write (- 1) (though there's no reason to incur the cost of a
function call when you can alternatively write -1). =It is not possible to write -n, because n is not a constant.=

*** Making the Argument Optional

improve on it a bit

make the argument n optional when invoked from Lisp code, just as giving a prefix argument is optional when invoking other-window-backward interactively

It should be possible to pass zero arguments (like this: (other-window-backward)) and get the default behavior (as if calling this: (other-window-backward 1) ).

#+begin_src emacs-lisp

  (defun other-window-backward (&optional n) 
      "Select Nth previous window." 
      (interactive "p") 
      (if n 
          (other-window (- n)) ;ifn s non-nil 
        (other-window -1))) ;ifn snil

#+end_src

=The keyword &optional appearing in a parameter list means that all subsequent parameters
are optional.=

=The function may be called with or without a value for an optional parameter. If
no value is given, the optional parameter gets the special value nil.=

*** The Best other-window-backward

check =The right way to bind keystroke to command=
check =define a lisp function=
check =nil=
check =Condensing the Code=
check =Logical Expression=
=!!! 可以看成一个有返回值的函数 ()是一个有返回值的表达式=

Using our factored-out version of the call to other-window, the function definition now looks like this:

#+begin_src emacs-lisp

  (defun other-window-backward (&optional n) 
      "Select Nth previous window." 
      (interactive "p") 
      (other-window (- (or n 1))))

#+end_src

But the best definition of all—the most Emacs-Lisp-like—turns out to be:

#+begin_src emacs-lisp

  (defun other-window-backward (&optional n) 
    "Select Nth previous window." 
    (interactive "P") 
    (other-window (- (prefix-numeric-value n))))

#+end_src

In this version, the code letter in the interactive declaration is no longer lowercase p, it's capital P;
    =The capital P means "when called interactively, leave the prefix argument in raw form and assign it to n."=
    =The raw form of a prefix argument is a data structure used internally by Emacs to record the prefix information the user gave before invoking a command.=

and the argument to other-window is (- (prefix-numeric-value n)) instead of (- (or n 1)).
    =!!! 可以看成一个有返回值的函数 ()是一个有返回值的表达式=
    =The function prefix-numeric-value can interpret that data structure as a number in exactly the way (interactive "p") did.=
    =What's more, if other-window-backward is called non-interactively (and n is therefore not a prefix argument in raw form), prefix-numeric-value does the right thing—namely, return n unchanged if it's a number, and return 1 if it's nil.=

this version is more "Emacs-Lisp-like" because it achieves better code reuse.

It uses the built-in function prefix-numeric-value rather than duplicating that function's behavior.
    
** Line-at-a-Time Scrolling

Emacs has two scrolling functions, scroll-up and scroll-down, which are bound to C-v and M-v

Each function takes an optional argument telling it how many lines to scroll.

By default, they each scroll the text one windowful at a time.

Though I could scroll up and down one line at a time with C-u 1 C-v and C-u 1 M-v, I wanted to be able to do it with a single keystroke.

First things first, though. I can never remember which function does what. Does ~scroll-up~ mean that the text moves up, revealing parts of the file that are farther down? Or does it mean that we reveal parts of the file that are farther up, moving the text down? I'd prefer that these functions had less confusing names, like ~scroll-ahead and scroll-behind~.

use ~defalias~ to refer to any Lisp function by a different name

#+begin_src emacs-lisp

  (defalias 'scroll-ahead 'scroll-up) 
  (defalias 'scroll-behind scroll-down)

#+end_src

There. Now we'll never have to deal with those ambiguous names again (=although the original names remain in addition to the new aliases=)

#+begin_src emacs-lisp

  ;;Now to define two new commands that call scroll-ahead and scroll-behind with the right arguments.
  (defun scroll-one-line-ahead () 
    "Scroll ahead one line." 
    (interactive) 
    (scroll-ahead 1))

  (defun scroll-one-line-behind () 
    "Scroll behind one line." 
    (interactive) 
    (scroll-behind 1))

  ;;As before, we can make the functions more general by giving them an optional argument:
  ;;check Traversing Window

  (defun scroll-n-lines-ahead (&optional n) 
     "Scroll ahead N lines (1 by default)." 
     (interactive "P") 
     (scroll-ahead (prefix-numeric-value n))) 

  (defun scroll-n-lines-behind (&optional n) 
      "Scroll behind N lines (1 by default)." 
      (interactive "P") 
      (scroll-behind (prefix-numeric-value n)))

  ;;Finally, we choose keys to bind to the new commands.
  ;;I like C-q for scroll-n-lines-behind and C-z for scroll-n-lines-ahead:

  (global-set-key "\C-q" 'scroll-n-lines-behind) 
  (global-set-key "\C-z" 'scroll-n-lines-ahead)

  ;;By default, C-q is bound to quoted-insert.
  ;;I move that infrequently used function to C-x C-q:
  ;;check The right way to bind keystroke to command
  ;;The default binding of C-x C-q is vc-toggle-read-only, which I don't mind losing.

  (global-set-key "\C-x\C-q" 'quoted-insert)

  ;;C-z has a default binding of iconify-or-deiconify-frame when running under X, and suspend-emacs when running in a character terminal.
  ;; In both cases, the function is also bound to C-x C-z, so there's no need to rebind them.

#+end_src

** Other Cursor and Text Motion Commands

#+begin_src emacs-lisp

     (defun point-to-top () 
         "Put point on top line of window." 
         (interactive) 
         (move-to-window-line O)) 

     (global-set-key "\M-," 'point-to-top)


     ;;The suggested keybinding replaces tags-loop-continue, which I like to put on C-x,:
     (global-set-key "\C-x," 'tags-loop-continue)

     ;;The next function makes the cursor jump to the bottom left of the window it's in.
     (defun point-to-bottom () 
       "Put point at beginning of last visible line."
       (interactive) 
       (move-to-window-line -1)) 

     (global-set-key "\M-." 'point-to-bottom)

     ;;The suggested keybinding in this case replaces find-tag.
     ;;I put that on C-x . which in turn replaces set-fill-prefix, which I don't mind losing.

     (defun line-to-top () 
       "Move current line to top of window." 
       (interactive) 
       (recenter O)) 

    (global-set-key "\M-!" 'line-to-top)
    ;;This command scrolls the window so that whichever line the cursor is on becomes the top line in the window.
    ;;The keybinding replaces shell-command.

#+end_src

** Clobbering Symbolic Links

In UNIX, a symbolic link, or =symlink=, is a file that refers to another file by name.

Suppose you visit a file in Emacs that is really a symlink to some other file. You make some
changes and press C-x C-s to save the buffer. What should Emacs do?

1. Replace the symbolic link with the edited version of the file, breaking the link but leaving the original link target alone.
2. Overwrite the file pointed to by the symbolic link.
3. Prompt you to choose one of the above actions.
4. Something else altogether.

I believe that the right answer changes depending on the situation, and that the user should be forced to think about what's right each time this comes up.

Here's what I do: when I visit a file that's really a symlink, I have Emacs automatically make the buffer read-only. This causes a ''Buffer is read-only" error as soon as I try to change anything in the buffer. The error acts as a reminder, alerting me to the possibility that I'm visiting a symlink. Then I choose how to proceed using one of two special commands I've designed.

*** Hooks                                                            :lisp:

For Emacs to make the buffer read-only when I first visit the file, I have to somehow tell Emacs, "execute a certain piece of Lisp code whenever I visit a file." The action of visiting a file should trigger a function I write. This is where =hooks= come in.

=A hook is an ordinary Lisp variable whose value is a list of functions that get executed under specific conditions.=

For instance, the variable ~write-file-hooks~ is a list of functions that Emacs executes whenever a buffer is saved, and ~post-command-hook~ is a list of functions to run after every interactive command. The hook that interests us most for this example is ~find-file-hooks~, which Emacs runs every time a new file is visited. (There are many more hooks, some of which we'll be looking at later in the book. =To discover what hooks are available, try M-x apropos RET hook RET.=)

The function ~add-hook~ adds a function to a hook variable.

=Functions that appear in hook variables take no arguments.=

*** create a function to add to find-file-hooks

#+begin_src emacs-lisp

  (defun read-only-if-symlink () ;;First, notice that the parameter list is empty. Functions that appear in hook variables take no arguments.
      (if (file-symlink-p buffer-file-name) 
          ;;The function file-symlink-p tests whether its argument, which is a string naming a file, refers to a symbolic link.
          ;; It's a Boolean predicate, meaning it returns true or false.
          ;;In Lisp, predicates traditionally have names ending in p or -p.
          ;;The argument to file-symlink-p is buffer-file-name.
          ;;This predefined variable has a different value in every buffer, and is therefore known as a buffer-local variable.
          ;;It always refers to the name of the file in the current buffer.
          ;;The "current buffer," when find-file-hooks gets executed, is the newly found file.
          (progn 
              ;;A progn expression evaluates each of its subexpressions in order and returns the value of the last one.
              (setq buffer-read-only t) 
              ;;The variable buffer-read-only is also buffer-local and controls whether the current buffer is read-only.
              (message "File is a symlink"))))


  ;;Now that we've defined read-only-if-symlink, we can call
  ;;to add it to the list of functions that are called whenever a new file is visited.
  (add-hook 'find-file-hooks 'read-only-if-symlink)

#+end_src

*** Anonymous Functions                                              :lisp:

When you use =defun= to define a function, you give it a name by which the function can be called from anywhere.

But what if the function won't ever be called from anywhere else? What if it needs to be available in only one place?

Arguably, read-only-if-symlink is needed only in the find-file-hooks list; =in fact, it might even be harmful for it to be called outside of find-file-hooks.=

It's possible to define a function without giving it a name. Such functions are appropriately known as =anonymous functions.= They're created with the =Lisp keyword lambda=, which works exactly like =defun= except that the name of the function is left out:

#+begin_src emacs-lisp

  (lambda () 
      (if (file-symlink-p buffer-file-name) 
          (progn 
            (setq buffer-read-only t) 
            (message "File is a symlink"))))

#+end_src

The empty parentheses after the =lambda= are where the anonymous function's parameters would be listed. This function has no parameters. =An anonymous function definition can be used wherever you might use the name of a function:=

#+begin_src emacs-lisp

  (add-hook 'find-file-hooks 
    '(lambda () 
        (if (file-symlink-p buffer-file-name) 
            (progn 
            (setq buffer-read-only t)
            (message "File is a symlink")))))

#+end_src

Now only find-file-hooks has access to the function; no other code is able to call it.

=There's one reason not to use anonymous functions in hooks. If you ever wish to remove a function from a hook, you need to refer to it by name in a call to ~remove-hook~, like so:=

#+begin_src emacs-lisp

  (remove-hook 'find-file-hooks 'read-only-if-symlink)

#+end_src

This is much harder if the function is anonymous.

*** Handling the Symlink

When Emacs alerts me that I'm editing a symlink,

- I may wish to replace the buffer with one visiting the target of the link instead;
- or I may wish to "clobber" the symlink (replacing the link itself with an actual copy of the real file) and visit that.

Here are two commands for these purposes:

#+begin_src emacs-lisp

  (defun visit-target-instead () 
    "Replace this buffer with a buffer visiting the link target." 
    (interactive) 
    (if buffer-file-name 
        (let ((target (file-symlink-p buffer-file-name))) 
            (if target 
                (find-alternate-file target) 
                (error "Not visiting a symlink"))) 
       (error "Not visiting a file"))) 

  (defun clobber-symlink () 
    "Replace symlink with a copy of the file." 
    (interactive) 
    (if buffer-file-name 
        (let ((target (file-symlink-p buffer-file-name))) 
            (if target 
                (if (yes-or-no-p (format "Replace %s with %s?" buffer-file-name target)) 
                (progn 
                    (delete-file buffer-file-name) 
                    (write-file buffer-file-name))) 
              (error "Not visiting a symlink"))) 
       (error "Not visiting a file")))

#+end_src

#+begin_src emacs-lisp
  (if buffer-file-name
     ;;. . .
     (error "Not visting a file"))
#+end_src

This test is necessary because =buffer-file-name may be nil (in the case that the current buffer isn't visiting any file---e.g., it might be the *scratch* buffer)=, and passing nil to file-symlink-p would generate the error, "Wrong type argument: stringp, nil".

=The error message means that some function was called expecting a string—an object satisfying the predicate stringp—but got nil instead.=

=When error is called, the current command aborts and Emacs returns to its top-level to await the user's next action.=

=Why wasn't it necessary to test buffer-file-name in read-only-ifsymlink? Because that function only gets called from find-file-hooks, and find-file-hooks only gets executed when visiting a file.=

=Most languages have a way to create temporary variables (also called local variables) that exist only in a certain region of code, called the variable's scope.= In Lisp, temporary variables are created with let, whose syntax is

#+begin_src emacs-lisp
  (let ((var1 value1)
        (var2 value2)
        . . .
        (varn valuen))
    body1 body2 ... bodyn)
#+end_src

=This gives var1 the value value1 , var2 the value value2 , and so on; and var1 and var2 can be used only within the body1 expressions.=

using temporary variables helps to avoid conflicts between regions of code that happen to use identical variable names.

#+begin_src emacs-lisp

    ;;So the expression
    (let ((target (file-symlink-p buffer-file-name))) . . . )
    ;;creates a temporary variable named target whose value is the result of calling
    ;;function with p or -p
    ;;As mentioned earlier, file-symlink-p is a predicate, which means it returns truth or falsehood.
    ;;But because "truth" in Lisp can be represented by any expression except nil, file-symlink-p isn't constrained to returning t if its argument really is a symlink.
    ;; In fact, it returns the name of the file to which the symlink refers.
    ;;So if buffer-file-name is the name of a symlink, target will be the name of the symlink's target.
    (file-symlink-p buffer-file-name) 

#+end_src

After executing the body of the let, the variable target no longer exists.

Within the let, if target is nil (because file-symlink-p returned nil, because buffer-file-name must not be the name of a symlink), then in the "else" clause we issue an informative error message, "Not visiting a symlink." Otherwise we do something else that depends on which function we're talking about.

At this point, visit-target-instead does

~(find-alternate-file target)~

which replaces the current buffer with one visiting ~target~, prompting the user first in case
there are unsaved changes in the original buffer. It even reruns the ~find-file-hooks~ when
the new file is visited, which is good because it, too, may be a symlink!

At the point where visit-target-instead calls find-alternate-file,
clobber-symlink does this instead:

~(if (yes-or-no-p . . . ) . . . )~

The function ~yes-or-no-p~ asks the user a yes or no question and returns true if the answer
was "yes," false otherwise.

The question, in this case, is:

~(format "Replace %s with %s? buffer-file-name target)~

This constructs a string in a fashion similar to C's =printf=.

The first argument is a pattern.

Each %s gets replaced with the string representation of a subsequent argument.

The first %s gets replaced with the value of buffer-file-name and the second gets replaced with the value of target. So if buffer-file-name is the string "foo" and target is "bar", the prompt will read, "Replace foo with bar?"

(The format function understands other ~%-sequences in the pattern string~. For instance, =%c prints a single character= if the corresponding argument is an ASCII value. See the online help for format—by typing ~M-? f format RET~ —for a complete list.)

After testing the return value of yes-or-no-p to make sure the user answered "yes," clobber-symlink does this:

#+begin_src emacs-lisp

  (progn 
      (delete-file buffer-file-name) 
      (write-file buffer-file-name))

#+end_src

=As we've seen, the progn is for grouping two or more Lisp expressions where only one is expected.= The call to delete-file deletes the file (which is really just a symlink), and the
call to write-file saves the contents of the current buffer right back to the same filename,
but this time as a plain file.

I like to put these functions on =C-x t= for visit-target-instead (unused by default) and
=C-x 1= for clobber-symlink (by default bound to count-linespage).

** Advised Buffer Switching

It frequently happens that I'm editing many similarly named files at the same time;

When I want to switch from one buffer to the other, I use =C-x b=, switch-to-buffer, which prompts me for a buffer name.

Since I like to keep my keystrokes to a minimum, I depend on =TAB= completion of the buffer name.

Other times, such as in this example, pressing fo TAB will only expand as far as "foobar.'', requiring me to disambiguate between "foobar.c" and "foobar.h". Out of habit, though, I often press RET and accept the buffer name "foobar.".At this point, Emacs creates a brand-new empty buffer named foobar., which of course isn't what I wanted at all. Now I've got to kill the brand-new buffer (with =C-x k, kill-buffer=) and start all over again.

What I'd like is for Emacs to catch my error before letting me commit it, by only accepting the names of existing buffers when it prompts me for one.

=A piece of advice attached to a Lisp function is code that gets executed before or after the function each time the function is invoked.Before advice can affect the arguments before they're passed to the advised function. After advice can affect the return value that comes out of the advised function.=

=Advice is a little bit like hook variables, but whereas Emacs defines only a few dozen hook variables for very particular circumstances, you get to choose which functions get "advised."=

#+begin_src emacs-lisp

  (defadvice switch-to-buffer (before existing-buffer activate compile) 
      "When interactive, switch to existing buffers only." 
      (interactive "b"))

#+end_src

The function defadvice creates a new piece of advice.

Its first argument is the =(unquoted)= name of the existing function being advised in this case, ~switch-to-buffer~.

=check The right way to bind keystroke to command=

Next comes a specially formatted list.

- =before—tells whether this is "before" or "after" advice. (Another type of advice, called
"around," lets you embed a call to the advised function inside the advice code.)=

- =Next comes the name of this piece of advice;= I named it existing-buffer. =The name can be used later if you want to remove or modify the advice.=
- Next come some =keywords=: =activate means that this advice should be active as soon as it's defined (it's possible to define advice but leave it inactive); and compile means that the advice code should be "byte-compiled" for speed (see Chapter 5, Lisp Files)= 

After the specially formatted list, a piece of advice has an =optional docstring.=

The only thing in the body of this advice is its own interactive declaration, =which replaces the interactive declaration of switch-to-buffer.= Whereas switch-to-buffer accepts any string as the buffer-name argument, =the code letter b in an interactive declaration means "accept only names of existing buffers."=

=By using the interactive declaration to make this change, we've managed to not affect any Lisp code that wants to call switch-to-buffer noninteractively.=

Unfortunately, that's too restrictive. =It should still be possible to switch to nonexistent buffers, but only when some special indication is given that the restriction should be lifted—say, when a prefix argument is given. Thus, C-x b should refuse to switch to nonexistent buffers, but C-u
C-x b should permit it.=

#+begin_src emacs-lisp

      (defadvice switch-to-buffer (before existing-buffer activate compile) 

        "When interactive, switch to existing buffers only, unless given a prefix argument." 
        (interactive 
         (list (read-buffer "Switch to buffer:"
                            (other-buffer)
                            (null current-prefix-arg)))))

#+end_src

Once again, we're overriding the interactive declaration of switch-to-buffer using "before" advice.

But this time, we're using interactive in a way we haven't seen before: =we're passing a list as its argument, rather than a string of code letters. When the argument to interactive is some expression other than a string, that expression is evaluated to get a list of arguments that should be passed to the function. So in this case we call list, which constructs a list out of its arguments,=  with the result of

#+begin_src emacs-lisp

  (read-buffer "Switch to buffer:" 
    (other-buffer)
     (null current-prefix-arg))

#+end_src

=The function read-buffer is the low-level Lisp function that prompts the user for a buffer name.=

=It's "low-level" in the sense that all other functions that prompt for buffer names ultimately call read-buffer.=

It's called with a prompt string and =two optional arguments:=
- =a default buffer to switch to, and=
- =a Boolean stating whether input should be restricted to existing buffers only.=

#+begin_src emacs-lisp

  ;;This tests whether current-prefix-arg is nil. If it is, the result will be t; if it's not, the result will be nil.
  (null current-prefix-arg)

#+end_src

=The result of read-buffer is then passed to list=, and the resulting list (containing one element, the buffer name) is used as the argument list for switch-to-buffer. 

With switch-to-buffer thus advised, Emacs won't let me respond to the prompt with a nonexistent buffer name unless I asked for that ability by pressing C-u first.

For completeness, you should similarly advise the functions ~switch-to-buffer-other-window~ and ~switch-to-buffer-other-frame~.

** Addendum: Raw Prefix Argument :lisp:

The variable =current-prefix-arg= always contains the latest ="raw"= prefix argument, which is the same thing you get from

#+begin_src emacs-lisp
(interactive "P")
#+end_src

The function =prefix-numeric-value= can be applied to a ="raw"= prefix argument to get =its numeric value=, which is the same thing you get from

#+begin_src emacs-lisp
(interactive "p")
#+end_src

| If the User Types                            | Raw Value                        | Numeric Value     |
|----------------------------------------------+----------------------------------+-------------------|
| C-u followed by a (possibly negative) number | The number itself                | The number itself |
| C-u - (with no following number)             | The symbol -                     | -1                |
| C-u n times in a row                         | A list containing the number 4^n | 4^n itself        |
| No prefix argument                           | nil                              | 1                 |

* Cooperating Commands

This chapter shows how to get different commands to work together by saving information in one command and retrieving it in another.

The simplest way to share information is to create a variable and store a value in it.

We'll combine these techniques with information about buffers and windows to write a set of functions that allow you to "undo" scrolling

we could write another function, ~unscroll~, which undoes the effects of the latest scroll.
Getting lost should therefore cause no more disruption to your mental context than it takes to remember the keybinding for ~unscroll~.

Actually, that's not quite good enough. If you press several C-vs in a row, =one call to unscroll should undo them all, not only the last one. This means that only the first C-v in a sequence should memorize the starting location.= How can we arrange for this to happen? 

=Emacs maintains a variable for this purpose called last-command. This variable is the first mechanism we'll use to communicate information from one command to a later one.=

how can we attach this extra code to the scroll-up command? =The advice facility is ideal for this purpose. Recall that a piece of advice can run before or after the advised function.=
=check defadvice=

In this case, we'll need before advice, because it's only before scroll-up runs that we know the starting location.

*** Declaring Variables :lisp:

 ~defvar~ to declare the global variable.

 #+begin_src emacs-lisp
   ;;setting up a global variable, unscroll-to
   ;;which will hold the "undo" information, which is simply the position in the buffer to which unscroll should move the cursor.
    (defvar unscroll-to nil 
        "Text position for next call to 'unscroll'.")
 #+end_src

=Global variables don't need to be declared. But there are some advantages to declaring variables with defvar:=

- =Using defvar allows a docstring to be associated with the variable, in the same way that defun allows a docstring to be associated with a function.=

- =A default value for the variable can be given. In this case, the default value for
unscroll-to is nil.=

Instead of unconditionally assigning the value to the variable like =setq= does, =defvar= assigns the value only if the variable does not yet have any value.

- A variable declaration using =defvar can be found by the various tag-related commands.= Tags are a way to quickly find variable and function definitions in a programming project.

Emacs's tag facilities, such as the =find-tag= command, can find anything created with the
def. . . functions (=defun, defalias, defmacro, defvar, defsubst, defconst, defadvice=).

- When you byte-compile the code (see Chapter 5, Lisp Files), the byte-compiler emits a warning for each variable it encounters that hasn't been declared with defvar.
*** Saving and Restoring Point

Let's define the value of =unscroll-to= to be the position in the text where the cursor was before the latest sequence of =scroll-ups=.

The position of the cursor in the text is the number of characters from the beginning of the buffer (counting from 1) and is called point or the point.

The value of point at any moment is given by the function ~point~.

#+begin_src emacs-lisp

  (defadvice scroll-up (before remember-for-unscroll activate compile) 
      "Remember where we started from, for 'unscroll'."
        ;; and the literal symbol scroll-up
        ;; check The right way to bind keystroke to command
        ;; The result of the call to eq is passed to not, which inverts the truth value of its argument.
        (if (not (eq last-command 'scroll-up)) 
            (setq unscroll-to (point))))

  (defun unscroll () 
    "Jump to location specified by 'unscroll-to'."*
    (interactive) 
    (goto-char unscroll-to))

#+end_src

*** Window Appearance

we'd really like to restore not only the location of the cursor, but also the appearance of the window with respect to which lines are visible where.

Emacs provides several functions describing what's visible in a window, such as ~window-edges, window-height, and current-window-configuration~.

~window-start~

for a given window, yields the buffer position that is the first visible character (i.e., the upper-left corner) in the window.

#+begin_src emacs-lisp
      (defvar unscroll-point nil 
      "Cursor position for next call to 'unscroll'.")

      (defvar unscroll-window-start nil 
     "Window start for next call to 'unscroll'.")

     (defadvice scroll-up (before remember-for-unscroll activate compile) 
       "Remember where we started from, for 'unscroll'." 
       (if (not (eq last-command 'scroll-up)) 
           (progn 
           (setq unscroll-point (point)) 
           (setq unscroll-window-start (window-start))))) 

    (defun unscroll () 
       "Revert to 'unscroll-point' and 'unscroll-window-start'." 
       (interactive) 
       (goto-char unscroll-point) 
       ;; The first argument is the window whose start position is being set. If nil is passed as the first argument (as in this example), set-window-start defaults to the currently selected window.
       ;;. (Window objects for passing to set-window-start can be obtained from such functions as get-buffer-window and previous-window.)
       (set-window-start nil unscroll-window-start))


    ;;There's one more piece of information we might like to save for unscrolling purposes, and that's the window's hscroll,  the number of columns by which the window is scrolled horizontally, normally zero.
    (defvar unscroll-hscroll nil 
   "Hscroll for next call to 'unscroll' .")

   (defadvice scroll-up (before remember-for-unscroll activate compile) 
     "Remember where we started from, for 'unscroll'.'"
     (if (not (eq last-command 'scroll-up)) 
         ;; a single setq call with multiple variable-value pairs. For conciseness, setq can set any number of variables.
         (setq unscroll-point (point) 
         unscroll-window-start (window-start) 
         unscroll-hscroll (window-hscroll)))) 

  (defun unscroll () 
     "Revert to 'unscroll-point' and 'unscroll-window-start'." 
     (interactive) 
     (goto-char unscroll-point) 
     (set-window-start nil unscroll-window-start) 
     (set-window-hscroll nil unscroll-hscroll))
#+end_src

*** Detecting Errors :lisp:

To keep the user from being baffled by this cryptic error message, it's a good idea to precede the call to goto-char with a simple check and a more informative error message:

#+begin_src emacs-lisp

  (if (not unscroll-point) ;i.e., ifunscroll-point is nil 
    (error "Cannot unscroll yet"))

#+end_src

When =error= is invoked, =execution of unscroll aborts= and the message "Cannot unscroll yet" is displayed.

*** Generalizing the Solution

It would be nice if we could generalize unscroll to undo scrolling in any direction.

The obvious way to generalize ~unscroll~ is to =advise= ~scroll-down~ in the same way that we advised scroll-up:

#+begin_src emacs-lisp

  (defadvice scroll-down (before remember-for-unscroll activate compile) 
   "Remember where we started from, for 'unscroll'." 
      (if (not (eq last-command 'scroll-down)) 
          (setq unscroll-point (point) 
          unscroll-window-start (window-start) 
          unscroll-hscroll (window-hscroll))))

#+end_src

=(Note that two functions, such as scroll-up and scroll-down, may have identically named pieces of advice, such as remember-for-unscroll, without conflict.)=

In other words, suppose you mistakenly press C-v C-v M-v. Should unscroll revert to the position before the M-v, or should it revert all the way back to the position before the first C-v?

I prefer the latter behavior. But this means that in the advice for scroll-up, where we now test whether the last command was scroll-up, we must now test whether it was either scroll-up or scroll-down, and do the same in scroll-down.

=check Logical Expression=

#+begin_src emacs-lisp
(defadvice scroll-up (before remember-for-unscroll activate compile) 
    "Remember where we started from, for 'unscroll'." 
    (if (not (or (eq last-command 'scroll-up) (eq last-command 'scroll-down))) 
            (setq unscroll-point (point) 
            unscroll-window-start (window-start) 
            unscroll-hscroll (window-hscroll)))) 
 
(defadvice scroll-down (before remember-for-unscroll activate compile) 
    "Remember where we started from, for 'unscroll'.'"
    (if (not (or (eq last-command 'scroll-up) (eq last-command 'scroll-down))) 
        (setq unscroll-point (point) 
        unscroll-window-start (window-start) 
        unscroll-hscroll (window-hscroll))))
#+end_src

Suppose somewhere down the line, you come up with more commands you'd like to advise this way; let's say =scroll-left= and =scroll-right=:

#+begin_src emacs-lisp
    (defadvice scroll-up (before remember-for-unscroll activate compile) 
     "Remember where we started from, for 'unscroll'." 
     (if (not (or (eq last-command 'scroll-up) 
                   (eq last-command 'scroll-down) 
                   (eq last-command 'scroll-left) ;new 
                   (eq last-command 'scroll-right))) ; new 
            (setq unscroll-point (point) 
                  unscroll-window-start (window-start) 
                  unscroll-hscroll (window-hscroll)))) 
 
     (defadvice scroll-down (before remember-for-unscroll activate compile) 
     "Remember where we started from, for 'unscroll'." 
     (if (not (or (eq last-command 'scroll-up) 
                  (eq last-command 'scroll-down) 
                  (eq last-command 'scroll-left) ;neu 
                  (eq last-command 'scroll-right))) ;neuw 
            (setq unscroll-point (point) 
                unscroll-window-start (window-start) 
                unscroll-hscroll (window-hscroll)))) 
 
     (defadvice scroll-left (before remember-for-unscroll activate compile) 
        "Remember where we started from, for 'unscroll'." 
        (if (not (or (eq last-command 'scroll-up)
                    (eq last-command 'scroll-down)
                    (eq last-command 'scroll-left) 
                    (eq last-command scroll-right))) 
            (setq unscroll-point (point) 
                unscroll-window-start (window-start) 
                unscroll-hscroll (window-hscroll)))) 
 
   (defadvice scroll-right (before remember-for-unscroll activate compile) 
        "Remember where we started from, for 'unscroll'." 
        (if (not (or (eq last-command 'scroll-up) 
                     (eq last-command scroll-down) 
                     (eq last-command scroll-left) 
                     (eq last-command 'scroll-right))) 
            (setq unscroll-point (point) 
                    unscroll-window-start (window-start) 
                    unscroll-hscroll (window-hscroll))))
#+end_src

Not only is this very repetitive and error-prone, but for each new command that we wish to make "unscrollable," =the advice for each existing unscrollable command must have its last-command test modified to include the new one.=

*** Using this-command

Two things can be done to improve this situation.
- First, since the advice is identical in each case, it can be factored out into a shared function:

#+begin_src emacs-lisp

(defun unscroll-maybe-remember () 
 (if (not (or (eq last-command 'scroll-up) 
                (eq last-command scroll-down) 
                (eq last-command scroll-left) 
                (eq last-command scroll-right))) 
        (setq unscroll-point (point) 
            unscroll-window-start (window-start) 
            unscroll-hscroll (window-hscroll)))) 
 
 (defadvice scroll-up (before remember-for-unscroll activate compile) 
    "Remember where we started from, for 'unscroll'." 
    (unscroll-maybe-remember)) 
 
 (defadvice scroll-down (before remember-for-unscroll activate compile) 
    "Remember where we started from, for 'unscroll'." 
    (unscroll-maybe-remember)) 
 
 (defadvice scroll-left (before remember-for-unscroll activate compile) 
    "Remember where we started from, for 'unscroll'." 
    (unscroll-maybe-remember)) 
 
 (defadvice scroll-right (before remember-for-unscroll activate compile) 
    "Remember where we started from, for 'unscroll'." 
    (unscroll-maybe-remember))

#+end_src

- Second, instead of having to test for n possible values of last-command, all meaning "the last command was unscrollable," it would be nice if there were a single such value, and if all the unscrollable commands could somehow set last-command to that value.

  =Enter this-command, the variable that contains the name of the current command invoked by the user. In fact, the way last-command gets set is this: while Emacs is executing a command, this-command contains the name of the command; then when it is finished, Emacs puts the value of this-command into last-command. While a command is executing, it can change the value of this-command. When the next command runs, the value will be available in last-command.=

  #+begin_src emacs-lisp
    (defun unscroll-maybe-remember () 
        ;;choose a symbol to represent all unscrollable commands: say, unscrollable.
        (setq this-command 'unscrollable) 
        (if (not (eq last-command 'unscrollable)) 
                (setq unscroll-point (point) 
                unscroll-window-start (window-start) 
                unscroll-hscroll (window-hscroll))))
  #+end_src
  
Any command that calls unscroll-maybe-remember now causes this command to contain unscrollable. And instead of checking last-command for four different values (more if we add new unscrollable commands), we only need to check for one value (even if we define new unscrollable commands).

*** Symbol Properties :lisp:

The first is to address this problem: the variables this-command and last-command aren't exclusively ours to do with as we please.For all we know, there exists an Emacs component that depends on the various scroll functions not overriding the settings of this-command and last-command.

Still, we would like a single, distinguished value in last-command to identify all unscrollable commands.

=Here's where symbol properties come in handy. In addition to having a variable value and/or a function definition, every Emacs Lisp symbol may also have associated with it a property list. A property list is a mapping from names to values. Each name is yet another Lisp symbol,
while each value may be any Lisp expression.=

=Properties are stored with the put function and retrieved with the get function.=

#+begin_src emacs-lisp

  ;;if we give the value 17 to the property named some-property belonging to the symbol a-symbol:
    (put 'a-symbol 'some-property 17)
  ;;then
    (get 'a-symbol 'some-property)
  ;;returns 17

#+end_src

If we try to get a property from a symbol that doesn't have that property, the result is nil.

Instead of using unscrollable as a value for ~this-command and last-command~, we can instead use an unscrollable ~property~. We'll set it up so that commands that are unscrollable have the unscrollable property of their names set to t, like so:

#+begin_src emacs-lisp

  (put 'scroll-up 'unscrollable t) 
  (put 'scroll-down 'unscrollable t) 
  (put 'scroll-left 'unscrollable t) 
  (put 'scroll-right 'unscrollable t)

  ;;Now (get x unscrollable) will be true only when x is one of the symbols scroll-up, scroll-down, scroll-left, and scroll-right.

  (defun unscroll-maybe-remember () 
    (if (not (get last-command 'unscrollable)) 
        (setq unscroll-point (point) 
            unscroll-window-start (window-start) 
            unscroll-hscroll (window-hscroll))))
#+end_src
  
*** Markers :lisp:

How can we make this code even better?

But before you do, you happen to see a bit of text you'd like to change, and you change it. Then you unscroll. The screen hasn't been correctly restored!

=The reason is that editing text earlier in the buffer changes all the subsequent buffer positions.An edit involving a net addition or removal of n characters adds or subtracts n to or from all subsequent positions.=

it would be a good idea to use markers

=A marker is a special object that specifies a buffer position just like an integer does. But if the buffer position moves because of insertions or deletions, the marker "moves" too so that it keeps pointing to the same
spot in the text.=

#+begin_src emacs-lisp
  ;;we no longer initialize them with nil.
  ;;We instead initialize them as new, empty marker objects using the function make-marker:
  (defvar unscroll-point (make-marker) "Cursor position for next call to 'unscroll'.") 
  (defvar unscroll-window-start (make-marker) "Window start for next call to 'unscroll'.")

  (defun unscroll-maybe-remember () 
    (if (not (get last-command 'unscrollable)) 
        (progn 
            (set-marker unscroll-point (point)) 
            (set-marker unscroll-window-start (window-start)) 
            ;;We don't use a marker for unscroll-hscroll because its value isn't a buffer position.
            (setq unscroll-hscroll (window-hscroll)))))

  (defun unscroll () 
        "Revert to 'unscroll-point' and 'unscroll-window-start'." 
        (interactive) 
        ;;goto-char and set-window-start can both handle arguments that are markers as well as arguments that are integers.
        (goto-char unscroll-point) 
        (set-window-start nil unscroll-window-start) 
        (set-window-hscroll nil unscroll-hscroll))
#+end_src

**** Addendum: Efficiency Consideration

Each marker that points into some buffer somewhere has to be updated every time text is inserted or deleted in that buffer.

A discarded marker object will eventually be reclaimed by the garbage collector, but until it is, it'll slow down editing in its buffer.

In general, when you intend to discard a marker object m (meaning that you no longer intend to refer to its value), =it's a good idea to first make it point "nowhere" by doing this:=

#+begin_src emacs-lisp
(set-marker m nil)
#+end_src

* Searching and Modifying Buffer

** Inserting the Current Time

placed a timestamp in the comment because it could be useful when editing that code in the future to look back and see when this change was made.

the function ~current-time-string~ yields today's date and time as a string

#+begin_src emacs-lisp
  (defun insert-current-time () 
      "Insert the current time" 
      (interactive "*") 
      (insert (current-time-string)))

  ;;Happily, we can get finer control if we're willing to do a little extra work. Emacs includes a few other time-related functions, notably current-time, which yields the current time in a raw form, and format-time-string, which can take such a time and format it in a wide variety of ways (in the style of C's strftime).

  ;;For a complete list of format codes, use describe-function on format-time-string.)
  (format-time-string "%1 %M %p" (current-time))
#+end_src

We can also easily permit the format used by each to be user-configurable, based on a configuration variable the user can set. Let's call the two functions ~insert-time and insert-date~. The corresponding configuration variables will be ~insert-time-format and insert-date-format.~

** User Options and Docstrings :lisp:

 define the variables

 #+begin_src emacs-lisp

   (defvar insert-time-format "%X" "*Format for \\[insert-time] (c.f. format-time-string').") 
   (defvar insert-date-format "%x" "*Format for \\[insert-date] (c.f. 'format-time-string').")

 #+end_src

=There are two new things to note about these docstrings.=

=First, each begins with an asterisk (*). A leading asterisk has special meaning in defvar docstrings. It means that the variable in question is a user option.=

user option

User options can be set interactively using =set-variable=, which prompts the user for a variable name (with completion of partially typed names) and a value.

=To set variables interactively when they aren't user options=, you must do something like

~M-: (setq variable value) RET~

User options, but not other variables, can be edited en masse using the ~option-editing mode~ available as ~M-x edit-options RET.~

=The second new thing about these docstrings is that each contains the special construct \[command]. (Yes, it's \[. . . ], but since it's written inside a Lisp string, the backslash has to be doubled: \\[. . . ].) This syntax is magic. When the docstring is displayed to the user-such as when the user uses apropos or describe-variable—\ [command] is replaced with a representation of a keybinding that invokes command.=

For example, if C-x t invokes insert-time, then the docstring

"*Format for \\[insert-time] (c.f. 'format-time-string')."

is displayed as

*Format for C-x t (c.f. 'format-time-string').

If there is no keybinding for insert-time, then M-x insert-time is used. If there are two or more keybindings for insert-time, Emacs chooses one.

Suppose you want the string \[insert-time] to appear literally in a docstring. How could you prevent its keybinding being substituted? For this purpose there is a special escape sequence: ~\=~. When ~\=~ precedes ~\[. . .~ , the magic replacement of \[. . . ] doesn't happen. Of course, Lisp string syntax dictates that this be written as "~. . . \\=\\[. . . . . .~".

\= is also useful for escaping the =asterisk at the beginning of a defvar docstring=, if you don't want the variable to be a user option but you absolutely must have a docstring that begins with an asterisk.

=All variables that are shared between two or more functions should be declared with defvar.=

=Which of those should be user options? A rule of thumb is that if the variable directly controls a user-visible feature that a user might want to change, and if setting that variable is straightforward (i.e., no complex data structures or specially coded values), then it should be a user option.=

** More Asterisk Magic :lisp:

#+begin_src emacs-lisp
(defun insert-time () 
    "Insert the current time according to insert-time-format." 
    (interactive "*") 
    (insert (format-time-string insert-time-format 
    (current-time)))) 
 
 (defun insert-date () 
    "Insert the current date according to insert-date-format."
    (interactive "*") 
    (insert (format-time-string insert-date-format 
    (current-time))))
#+end_src

=The insert function takes any number of arguments (which must all be strings or characters) and inserts them one after another in the current buffer at the present location of point, moving point forward.=

~(interactive)~
=By now you know that interactive turns a function into a command and specifies how to obtain the function's arguments when invoked interactively.=

But we haven't seen * in the argument of interactive before, and besides, these functions take no arguments, so why does interactive have one?

=The asterisk, when it is the first character in an interactive argument, means "abort this function if the current buffer is read-only."=

A more complicated function, though, might cause irreversible side effects (such as changing global variables), expecting to be able to finish, before discovering that it can't.

** Writestamps

Inserting the current date and time automatically and in such a configurable format is pretty neat
and probably beyond the ken of most text editors, but its usefulness is limited. Undoubtedly more useful would be the ability to store a writestamp in a file; that is, the date and/or time the file was last written to disk. A writestamp updates itself each time the file is saved anew

*** Updating Writestamps

The first thing we'll need is a way to run our writestamp-updating code each time the file is saved.

=As we discovered in the section "Hooks" in Chapter 2, the best way to associate some code with a common action (such as saving a file) is by adding a function to a hook variable, provided that a suitable hook variable exists.=

~M-x apropos RET hook RET~

=after-save-hook, local-write-file-hooks, write-contents-hooks, and write-file-hooks=

The most straightforward approach is to surround each writestamp with a distinguishing string of characters that we can search for.

Let's say that each writestamp is surrounded by the strings "WRITESTAMP((" on the left and "))" on the right, so that in a file it looks something like this:

WRITESTAMP((12:19pm 7 Jul 96))

Let's say that the stuff inside the WRITESTAMP ((. . . )) is put there by ~insert-date~ (which we defined earlier) and so its format can be controlled with ~insert-date-format~.

#+begin_src emacs-lisp
  (add-hook 'local-write-file-hooks 'update-writestamps) 

  (defun update-writestamps () 
     "Find writestamps and replace them with the current time." 
     ;;What save-excursion does is memorize the position of the cursor, execute the subexpressions it's given as arguments, then restore the cursor to its original position.
     ;;It's useful in this case because the body of the function is going to move the cursor all over the buffer, but by the time the function finishes we'd like the caller of this function to perceive no cursor motion.
     (save-excursion 
        ;; This is like save-excursion in that it memorizes some information, then executes its arguments, then restores the information.
        ;;The information in this case is the buffer's restriction, which is the result of narrowing.
        ;;Since update-writestamps is going to call widen, which undoes the effect of any narrowing, we need save-restriction in order to clean up after ourselves.
         (save-restriction 
             ;;like save-excursion and save-restriction, memorizes some information, executes its arguments, then restores the information.
             ;;This time the information in question is the result of the latest search.
             ;;Each time a search occurs, information about the result of the search is stored in some global variables (as we will see shortly).
             ;;Each search wipes out the result of the previous search.
             ;;Our function will perform a search, but for the sake of other functions that might be calling ours, we don't want to disrupt the global match data.
             (save-match-data 
                 ;;As previously mentioned, this undoes any narrowing in effect.
                 ;;It makes the entire buffer accessible, which is necessary if every writestamp is to be found and updated.
                 (widen) 
                 (goto-char (point-min)) 
                 ;;The nil means the search is not bounded except by the end of the buffer.
                 ;;The t means that if no match is found, search-forward should simply return nil.
                 ;;  Without the t, search-forward signals an error, aborting the current command, if no match is found.
                 (while (search-forward "WRITESTAMP((" nil t) 
                     (let ((start (point))) 
                     (search-forward "))") 
                     (delete-region start (- (point) 2))
                     (goto-char start) 
                     (insert-date)))))) 
        ;;This is the function's return value.
        ;;The final expression of update-writestamps, after the call to save-excursion, is nil
         nil)
#+end_src

=The return value of a Lisp function is simply the value of the last expression in the function's body.=

(All Lisp functions return a value, but so far every function we've written has done its job via "side effects" instead of by returning meaningful values.)

The reason is that functions in local-write-file-hooks are treated specially.

Normally, the return value of a function in a hook variable doesn't matter.

But for functions in =local-write-file-hooks= (also in write-file-hooks and write-contents-hooks), =a non-nil return value means, "This hook function has taken over the job of writing the buffer to a file." If the hook function returns a non-nil value, the remaining functions in the hook variables are not called, and Emacs does not write the buffer to a file itself after the hook functions run.= Since update-writestamps is not taking over the job of writing the buffer to a file, we want to be sure it returns nil.

** Generalizing Writestamps

This approach to implementing writestamps works, but there are a few problems.

=First, by hardwiring the strings "WRITESTAMP((" and "))" we've doomed the user to an unaesthetic and inflexible way to distinguish writestamps in text.=

=Second, the user's preference might not be to use insert-date for writestamps.=

* Lisp Files
- =Code in .emacs is always executed when Emacs starts up=, even if it is never needed in a given session. This makes startup time longer and consumes memory.

=By contrast, a separate file of Lisp code can be loaded only when and if needed.=

- =Code in .emacs typically isn't byte-compiled.=

=Bytecompiled Lisp files usually have names ending in .elc= ("Emacs Lisp, compiled"), while =their non-compiled counterparts usually have names ending in .el ("Emacs Lisp")=.

** Creating a Lisp File

touch xxx.el

Lisp files should be written such that they can be loaded at any time, even multiple times, without unwanted side-effects.

One such side-effect would be including (make-local-hook 'after-change-functions) in xxx.el, then loading xxx.el while the current buffer is not the one whose after-change-functions you want to make local.

** Loading the File

This is done by =loading= the file, which causes Emacs to read and execute its contents.

There are many ways to load Lisp files in Emacs: interactively, non-interactively, explicitly, implicitly, and with and without pathsearching.

*** Finding Lisp Files

Emacs can load files based on full path names such as /usr/local/share/emacs/ site-lisp/foo.el, but it is usually more convenient to use only a file's base name, bo.el, and let Emacs find it among the directories in the =loadpath=.

=The load path is simply a list of directories that Emacs searches for files to load, very much like the way the UNIX shell uses the environment variable PATH to find programs to execute. Emacs's load path is stored as a list of strings in the Lisp variable load-path.=

("/usr/local/share/emacs/19.34/site-lisp" 
 "/usr/local/share/emacs/site-lisp" 
 "/usr/local/share/emacs/19.34/lisp")

To add a directory to the beginning of load-path, use

#+begin_src emacs-lisp
(setq load-path 
 (cons "/your/directory/here" 
    load-path))
#+end_src

To add a directory to the end, use

#+begin_src emacs-lisp

  (setq load-path 
   (append load-path 
    ("/your/directory/here")))

#+end_src

If you ask Emacs to find a Lisp file in the load path and you omit the suffix of the file for which you're looking-e.g., you specify foo instead of foo.el-Emacs first looks for foo.elc, the byte-compiled form of foo.el. If that's not found in the load path, then foo.el is tried, followed by plain foo.

=It's usually best to omit the suffix when specifying a file to load.=

Not only does it get you that useful search behavior, but it helps ~eval-after-load~ to work properly (see the section about eval-after-load later in this chapter).

*** Interactive Loading

~load-file~

=When you type M-x load-file RET, Emacs prompts you for the full pathname of a Lisp file (e.g., /home/bobg/emacs/foo.el) and does not search load-path.=

~load-library~

=Emacs prompts you for just the base name of the library (e.g, foo) and attempts to find it in load-path.=

*** Programmatic Loading

When loading files from Lisp code, you may choose =explicit loading, conditional loading, or autoloading.=

**** Explicit loading

Files are loaded explicitly by calling ~load~ (which works like the interactive load-library) or ~load-file~.

#+begin_src emacs-lisp
  ;;searches load-path for lazy-lock.elc, lazy-lock.el, or lazy-lock
  (load "lazy-lock")

  ;;doesn't use load-path.
  (load-file "/home/bobg/emacs/lazy-lock.elc")
#+end_src

* Lisp

=!!! 可以看成一个有返回值的函数 ()是一个有返回值的表达式=
** Lisp :lisp:

the language of the .emacs file.

It is traditionally associated with artificial intelligence applications, for which Lisp is well-suited because it permits symbolic computation, =can treat code as data=, and simplifies building very complicated data structures.

The word expression usually means any piece of Lisp code or any Lisp data structure. All Lisp expressions, whether code or data, can be evaluated by the Lisp interpreter built into Emacs to make them yield some computational result.


Among the features that distinguish Lisp from other programming languages are:

*** Fully-parenthesized prefix notation

All expressions and function calls in Lisp are surrounded by parentheses,* and the function
name always precedes the arguments to the function.

#+begin_src emacs-lisp
  ;;(Comments in Lisp are introduced with a semicolon and continue to the end of the line.)
  ;;to apply the + function to the arguments x and y, in Lisp you write
  (+ x y )
#+end_src



#+begin_src emacs-lisp

    ;;1.Though unfamiliar, prefix notation has some benefits over infix notation. In infix languages, ;;to write the sum of five variables you need four plus signs:
    ;;a+b+c+d+e
    ;;Lisp is more concise:
    (+ a b c d e)

    ;;2.Also, questions of operator precedence do not arise.
    ;;For example, is the value of 3 + 4 * 5 35 or 23? It depends on whether * has higher precedence than +.
    ;;But in Lisp, the confusion vanishes:
    (+ 3 (* 4 5)) ;result is 23
    (* (+ 3 4) 5) ;result is 35

    ;;3.Finally, while infix languages need commas to separate the arguments to a function:
    ;;foo(3 + 4, 5 + 6)~
    ;;Lisp doesn't need that extra bit of syntax:
    (foo (+ 3 4) (+ 5 6))
#+end_src

*** List data type

Lisp has a built-in data type called a list.

A list is a Lisp object containing zero or more other Lisp objects, surrounded by parentheses.

#+begin_src emacs-lisp
  (hello there) ;; list containing two "symbols"

  (1 2 "xyz") ;; two numbers and a string

  (a (b c)) ;; a symbol and a sublist (containing two symbols)

  () ;; the empty list
#+end_src

Lists can be assigned to variables, passed as arguments to functions and returned from
them, constructed with such functions as =cons= and =append=, and taken apart with such
functions as =car= and =cdr=.

*** Garbage collection

Lisp is a garbage-collected language, which means that Lisp itself automatically reclaims the memory used by your program's data structures.

** The right way to bind keystroke to command :lisp:

Our Lisp example is almost complete, but we can't just write

#+begin_src emacs-lisp

  (global-set-key "\M-?" help-command) ; almost right!
  
#+end_src


=This is wrong because of the way symbols are interpreted when they appear in Lisp
expressions.=

    - =If a symbol appears in the first position of a list, it's the name of a function to
    execute.!!!=
    - =If it appears elsewhere, it's a variable whose value needs to be retrieved.!!!=

But when we run global-set-key as shown, we don't want the value contained in help-command, whatever that may be. The value we want is the symbol help-command itself.

In short, we wish to prevent the symbol from being evaluated before it's passed to global-set-key.

After all, as far as we know, help-command doesn't have a value as a variable.

=The way to prevent a symbol (or any Lisp expression) from being evaluated is to quote it by
preceding it with a single quote (').=

#+begin_src emacs-lisp

  (global-set-key "\M-?" 'help-command)
  
#+end_src

Incidentally, to illustrate the difference between quoting and not quoting, the same effect could be achieved with

#+begin_src emacs-lisp

  (setq x 'help-command) ; setq assigns a variable
  (global-set-key "\M-?" x) ; usex's value

#+end_src

=Symbols aren't the only things that may follow a ' character; any Lisp expression can be quoted, including lists, numbers, strings, and other kinds of expressions we'll learn about later. Writing 'expr is shorthand for=

#+begin_src emacs-lisp

  (quote expr)

#+end_src

=which, when evaluated, yields expr.=

You might have noticed that a quote is required before the symbol help-command but not before the string argument, "\M-?". =This is because in Lisp, strings are self-evaluating, which means that when the string is evaluated, the result is the string itself.= So quoting it, while harmless, is redundant. =Numbers, characters, and vectors are other types of self-evaluating Lisp expressions.=

#+begin_src emacs-lisp

  ;;finally
  (global-set-key "\M-?" 'help-command)
  (global-set-key "\C-h" delete-backward-char)

#+end_src

** Evaluating Lisp Expressions

There are several ways to explicitly evaluate Lisp expressions.

- You can put the Lisp expressions in a file, then load the file.
  ~M-x load-file RET xxx.el RET~
- use the command ~eval-last-sexp~

  Sexp is an abbreviation for S-expression, which in turn is short for symbolic expression, which is another name for "Lisp expression."

  bound to =C-x C-e=

  This command evaluates the Lisp expression to the left of the cursor.

- use the command ~eval-expression~

  bound to =M-:=

  #+begin_src emacs-lisp

    (put 'eval-expression 'disabled nil)

  #+end_src

 (The =put= function relates to property lists, which we'll see in the section on "Symbol Properties" in Chapter 3.)

- use the *scratch* buffer

The buffer is in =Lisp Interaction mode=

In this mode, pressing =C-j= invokes ~eval-print-last-sexp~, which is like ~eval-lastsexp~ except that the result of the evaluation is inserted into the buffer at the location of the cursor

Another feature of Lisp Interaction mode is =its ability to complete a partially typed Lisp symbol= when you press =M-TAB= (which invokes ~lisp-complete-symbol~).

** define a lisp function :lisp:

check =The right way to bind keystroke to command=

#+begin_src emacs-lisp
  (defun function_name (function's parameter list)

    ;;(defun function_name (&optional function's parameter list)
    ;;The keyword &optional appearing in a parameter list means that all subsequent parameters are optional.
    ;; The function may be called with or without a value for an optional parameter.
    ;;If no value is given, the optional parameter gets the special value nil.

    ;;Emacs displays the docstring when showing online help about the function, as with the commands describe-function (C-h f) or apropos.
    "function's documentation string or docstring"

    (interactive);;It's optional, It distinguishes this function as an interactive command
    ;;A command, in Emacs, is a Lisp function that can be invoked interactively, which means it can be invoked from a keybinding or by typing M-x command-name.
    ;;Not all Lisp functions are commands, but all commands are Lisp functions.
    ;;Any Lisp function, including interactive commands, can be invoked from within other Lisp code using the (function arg . . . ) syntax.
    ;;Check [[** The right way to bind keystroke to command]]
    ;;A function is turned into an interactive command by using the special (interactive) expression at the beginning of the function definition (after the optional docstring).

    ;;An interactive command is, as we have observed, a kind of Lisp function.
    ;;That means that the command may take arguments.
    ;;Passing arguments to a function from Lisp is easy; they simply get written down in the function call, as in (other-window -1).

    ;;But what if the function is invoked as an interactive command? Where do the arguments come from then? Answering this question is the purpose of the interactive declaration.
    ;;The argument to interactive describes how to obtain arguments for the command that contains it.
    ;; - When the command takes no arguments, then i interactive has no arguments, as in our first draft of other-window-backward.
    ;; - When the command does take arguments, then interactive takes one argument: a string of code letters, one code letter per argument being described.
    ;;   - The code letter p used in this example means, "if there is a prefix argument, interpret it as a number, and if there is no prefix argument, interpret that as the number 1."
    ;;     (interactive "p")


    ;;(function arg ...)
    (Lisp Expression))
#+end_src

*** function return value

#+begin_src emacs-lisp
  (add-hook 'local-write-file-hooks 'update-writestamps) 

  (defun update-writestamps () 
     (save-excursion 
         (save-restriction 
             (save-match-data 
                 (widen) 
                 (goto-char (point-min)) 
                 (while (search-forward "WRITESTAMP((" nil t) 
                     (let ((start (point))) 
                     (search-forward "))") 
                     (delete-region start (- (point) 2))
                     (goto-char start) 
                     (insert-date)))))) 
        ;;This is the function's return value.
        ;;The final expression of update-writestamps, after the call to save-excursion, is nil
         nil)
#+end_src

=The return value of a Lisp function is simply the value of the last expression in the function's body.=

(All Lisp functions return a value, but so far every function we've written has done its job via "side effects" instead of by returning meaningful values.)

The reason is that functions in local-write-file-hooks are treated specially.

Normally, the return value of a function in a hook variable doesn't matter.

But for functions in =local-write-file-hooks= (also in write-file-hooks and write-contents-hooks), =a non-nil return value means, "This hook function has taken over the job of writing the buffer to a file." If the hook function returns a non-nil value, the remaining functions in the hook variables are not called, and Emacs does not write the buffer to a file itself after the hook functions run.= Since update-writestamps is not taking over the job of writing the buffer to a file, we want to be sure it returns nil.

** nil :lisp:
*** It designates falsehood

  In the Lisp structures that test a true/false condition—if, cond, while, and, or, and not-a value of nil means "false" and any other value means "true."

  #+begin_src emacs-lisp

    ;;Lisp's version of an if-then-else statement
    (if n 
        (other-window (- n)) 
      (other-window -1))
    ;;first n is evaluated
    ;;   If the value of n is true (non-nil), then (other-window (- n)) is evaluated,
    ;;   otherwise (other-window -1) is evaluated

  #+end_src

There is another =symbol, t= , that designates truth

*** It is indistinguishable from the empty list

Inside the Lisp interpreter, the symbol nil and the empty list ( ) are the same object. 

If you call ~listp~, which tests whether its argument is a list, on the symbol nil, you'll get the result t, which means truth. listp == list predict

Likewise, if you call ~symbolp~ , which tests whether its argument is a symbol, on the empty list, you'll get t again.

*** It is its own value

  When you evaluate the symbol nil, the result is nil.

For this reason, unlike other symbols, nil doesn't need to be quoted when you want its name instead of its value, because its name is the same as its value.

#+begin_src emacs-lisp

  (setq x nil) ;;assign nil to variable x
  ;;instead of (setq x 'nil)

#+end_src

There is a symbol, t, for designating truth. =Like nil, t is its own value and doesn't need to be quoted.=

And also unlike nil, which is the only way to denote falsehood, all other Lisp values denote truth just like t does.
  
** Condensing the Code :lisp:

#+begin_src emacs-lisp

  (if n ;; if this. . . 
      (other-window (- n)) ;;. . . then this 
    (other-window -1)) ;;. . . else this

#+end_src

Lisp version of an if-then-else statement

The first argument to if is a test.

It is evaluated to see whether it yields truth (any expression except nil) or falsehood (nil).

     If it's truth, the second argument-the "then" clause-is evaluated.

     If it's falsehood, the third argument—the "else" clause (which is optional)—is evaluated.

=The result of if is always the result of the last thing it evaluates.!!! 可以看成一个有返回值的if函数 ()是一个有返回值的表达式=

Observe that other-window is called in both branches (the "then" and the "else" clauses) of the if.In this case, we can make the if expression more concise by factoring out the common subexpressions.

#+begin_src emacs-lisp

  ;;We can therefore rewrite this expression as:
  (other-window (if n (- n) -1))

#+end_src

We can factor out common subexpressions again by observing that in both branches of the if, we're looking for the negative of something—either the negative of n or the negative of 1.

#+begin_src emacs-lisp

  (if n (- n) -1)
  ;;can become
  (- (if n n 1))

#+end_src

#+begin_src emacs-lisp

  ;;In general,
  (if test 
    (a b) 
   (a c))

  ;;can be shortened to

  (a (if test b c))

#+end_src

** Logical Expressions :lisp:

An old Lisp programmers' trick can now be used to make this expression even more concise:

#+begin_src emacs-lisp

  (if n n 1)
  ;;equal
  (or n 1)

#+end_src

=The function or= works like the logical "or" in most languages:

if all of its arguments are false, it returns falsehood, otherwise it returns truth.

But Lisp's =or= has an extra bit of usefulness:

=it evaluates each of its arguments in order until it finds one that's non-nil, then it returns that value. If it doesn't find one, it returns nil.=

=!!! 可以看成一个有返回值的or函数 ()是一个有返回值的表达式=

So the return value from or isn't merely false or true, =it's false or the first true value in the list.=

#+begin_src emacs-lisp

  ;;This means that generally speaking,
  (if a a b)
  ;;can be replaced by
  (or a b)

#+end_src

In fact, it often should be written that way because if a is true, =then (if a a b) will evaluate it twice whereas (or a b) won't.= (On the other hand, if you specifically want a evaluated twice, then of course you should use if.) In fact,

#+begin_src emacs-lisp

  (if a a ;; if a is true, return a
      (if b b ;; else if b is true, return b
          ;;. . . 
              (if y y z))) ;; else if y is true, return y, else z

  ;;(which might look artificial here but is actually a pretty common pattern in actual programs) can be changed to the following form.

  (or a b ... y z)

#+end_src

Similarly

#+begin_src emacs-lisp

  (if a
      (if b
          ;;. . .
              (if y z)))

  ;;(note that none of the ifs in this example has an "else" clause)!!! can also be written as

  (and a b . . . y z)

#+end_src

because =and(function)= works by evaluating each of its arguments in order until it finds one that's nil.

=If it finds one, it returns nil, and if it doesn't find one, it returns the value of the last argument.=

#+begin_src emacs-lisp

  ;;One other shorthand to watch out for: some programmers like to turn
  (if (and a b . . . y) z)
  into
  (and a b . . . y z)
  ;;but not me because, while they're functionally identical, the former has shades of meaning—"do z if a through y are all true"—that the latter doesn't, which could make it easier for a human reader to understand.
#+end_src

** defalias :lisp:

use ~defalias~ to refer to any Lisp function by a different name

#+begin_src emacs-lisp
(defalias 'new_name 'old_name)
#+end_src

There. Now we'll never have to deal with those ambiguous names again (=although the original names remain in addition to the new aliases=)

** Hooks :lisp:

For Emacs to make the buffer read-only when I first visit the file, I have to somehow tell Emacs, "execute a certain piece of Lisp code whenever I visit a file." The action of visiting a file should trigger a function I write. This is where =hooks= come in.

=A hook is an ordinary Lisp variable whose value is a list of functions that get executed under specific conditions.=

For instance, the variable ~write-file-hooks~ is a list of functions that Emacs executes whenever a buffer is saved, and ~post-command-hook~ is a list of functions to run after every interactive command. The hook that interests us most for this example is ~find-file-hooks~, which Emacs runs every time a new file is visited. (There are many more hooks, some of which we'll be looking at later in the book. =To discover what hooks are available, try M-x apropos RET hook RET.=)

The function ~add-hook~ adds a function to a hook variable.

=Functions that appear in hook variables take no arguments.=

** function with p or -p :lisp:

It's a Boolean predicate, meaning it returns true or false.
In Lisp, predicates traditionally have names ending in p or -p.
** progn :lisp:

A progn expression evaluates each of its subexpressions in order and returns the value of the last one.

** Anonymous Functions                                              :lisp:

When you use =defun= to define a function, you give it a name by which the function can be called from anywhere.

But what if the function won't ever be called from anywhere else? What if it needs to be available in only one place?

Arguably, read-only-if-symlink is needed only in the find-file-hooks list; =in fact, it might even be harmful for it to be called outside of find-file-hooks.=

It's possible to define a function without giving it a name. Such functions are appropriately known as =anonymous functions.= They're created with the =Lisp keyword lambda=, which works exactly like =defun= except that the name of the function is left out:

#+begin_src emacs-lisp

  (lambda () 
      (if (file-symlink-p buffer-file-name) 
          (progn 
            (setq buffer-read-only t) 
            (message "File is a symlink"))))

#+end_src

The empty parentheses after the =lambda= are where the anonymous function's parameters would be listed. This function has no parameters. =An anonymous function definition can be used wherever you might use the name of a function:=

#+begin_src emacs-lisp

  (add-hook 'find-file-hooks 
    '(lambda () 
        (if (file-symlink-p buffer-file-name) 
            (progn 
            (setq buffer-read-only t)
            (message "File is a symlink")))))

#+end_src

Now only find-file-hooks has access to the function; no other code is able to call it.

=There's one reason not to use anonymous functions in hooks. If you ever wish to remove a function from a hook, you need to refer to it by name in a call to ~remove-hook~, like so:=

#+begin_src emacs-lisp

  (remove-hook 'find-file-hooks 'read-only-if-symlink)

#+end_src

This is much harder if the function is anonymous.

** let :lisp:

=Most languages have a way to create temporary variables (also called local variables) that exist only in a certain region of code, called the variable's scope.= In Lisp, temporary variables are created with let, whose syntax is

#+begin_src emacs-lisp
  (let ((var1 value1)
        (var2 value2)
        . . .
        (varn valuen))
    body1 body2 ... bodyn)
#+end_src

=This gives var1 the value value1 , var2 the value value2 , and so on; and var1 and var2 can be used only within the body1 expressions.=

using temporary variables helps to avoid conflicts between regions of code that happen to use identical variable names.

#+begin_src emacs-lisp

  ;;So the expression
  (let ((target (file-symlink-p buffer-file-name))) . . . )
  ;;creates a temporary variable named target whose value is the result of calling
  ;;function with p or -p
  (file-symlink-p buffer-file-name) 

#+end_src

** yes-or-no-p :lisp:

The function ~yes-or-no-p~ asks the user a yes or no question and returns true if the answer
was "yes," false otherwise.

** format :lisp:

#+begin_src emacs-lisp
(format "%s" buffer-file-name)
#+end_src

This constructs a string in a fashion similar to C's =printf=.

The first argument is a pattern.

Each %s gets replaced with the string representation of a subsequent argument.

(The format function understands other ~%-sequences in the pattern string~. For instance, =%c prints a single character= if the corresponding argument is an ASCII value. See the online help for format—by typing ~M-? f format RET~ —for a complete list.)

** defadvice :lisp:

=A piece of advice attached to a Lisp function is code that gets executed before or after the function each time the function is invoked.Before advice can affect the arguments before they're passed to the advised function. After advice can affect the return value that comes out of the advised function.=

=Advice is a little bit like hook variables, but whereas Emacs defines only a few dozen hook variables for very particular circumstances, you get to choose which functions get "advised."=

#+begin_src emacs-lisp

  (defadvice switch-to-buffer (before existing-buffer activate compile) 
      "When interactive, switch to existing buffers only." 
      (interactive "b"))

#+end_src

The function defadvice creates a new piece of advice.

Its first argument is the =(unquoted)= name of the existing function being advised in this case, ~switch-to-buffer~.

=check The right way to bind keystroke to command=

Next comes a specially formatted list.

- =before—tells whether this is "before" or "after" advice. (Another type of advice, called
"around," lets you embed a call to the advised function inside the advice code.)=

- =Next comes the name of this piece of advice;= I named it existing-buffer. =The name can be used later if you want to remove or modify the advice.=
- Next come some =keywords=: =activate means that this advice should be active as soon as it's defined (it's possible to define advice but leave it inactive); and compile means that the advice code should be "byte-compiled" for speed (see Chapter 5, Lisp Files)= 

After the specially formatted list, a piece of advice has an =optional docstring.=

The only thing in the body of this advice is its own interactive declaration, =which replaces the interactive declaration of switch-to-buffer.= Whereas switch-to-buffer accepts any string as the buffer-name argument, =the code letter b in an interactive declaration means "accept only names of existing buffers."=

=By using the interactive declaration to make this change, we've managed to not affect any Lisp code that wants to call switch-to-buffer noninteractively.=

It would be nice if we could generalize unscroll to undo scrolling in any direction.

The obvious way to generalize ~unscroll~ is to =advise= ~scroll-down~ in the same way that we advised scroll-up:

#+begin_src emacs-lisp

  (defadvice scroll-down (before remember-for-unscroll activate compile) 
   "Remember where we started from, for 'unscroll'." 
      (if (not (eq last-command 'scroll-down)) 
          (setq unscroll-point (point) 
          unscroll-window-start (window-start) 
          unscroll-hscroll (window-hscroll))))

#+end_src

=(Note that two functions, such as scroll-up and scroll-down, may have identically named pieces of advice, such as remember-for-unscroll, without conflict.)=

** Addendum: Raw Prefix Argument :lisp:

The variable =current-prefix-arg= always contains the latest ="raw"= prefix argument, which is the same thing you get from

#+begin_src emacs-lisp
(interactive "P")
#+end_src

The function =prefix-numeric-value= can be applied to a ="raw"= prefix argument to get =its numeric value=, which is the same thing you get from

#+begin_src emacs-lisp
(interactive "p")
#+end_src

| If the User Types                            | Raw Value                        | Numeric Value     |
|----------------------------------------------+----------------------------------+-------------------|
| C-u followed by a (possibly negative) number | The number itself                | The number itself |
| C-u - (with no following number)             | The symbol -                     | -1                |
| C-u n times in a row                         | A list containing the number 4^n | 4^n itself        |
| No prefix argument                           | nil                              | 1                 |

** functions
 | null |

#+begin_src emacs-lisp

  ;;This tests whether current-prefix-arg is nil. If it is, the result will be t; if it's not, the result will be nil.
  (null current-prefix-arg)

#+end_src

| switch-to-buffer |
| read-buffer      |
| not              |
| point            |

** Declaring Variables :lisp:

 ~defvar~ to declare the global variable.

 #+begin_src emacs-lisp
   ;;setting up a global variable, unscroll-to
   ;;which will hold the "undo" information, which is simply the position in the buffer to which unscroll should move the cursor.
    (defvar unscroll-to nil 
        "Text position for next call to 'unscroll'.")
 #+end_src

=Global variables don't need to be declared. But there are some advantages to declaring variables with defvar:=

- =Using defvar allows a docstring to be associated with the variable, in the same way that defun allows a docstring to be associated with a function.=

- =A default value for the variable can be given. In this case, the default value for
unscroll-to is nil.=

Instead of unconditionally assigning the value to the variable like =setq= does, =defvar= assigns the value only if the variable does not yet have any value.

- A variable declaration using =defvar can be found by the various tag-related commands.= Tags are a way to quickly find variable and function definitions in a programming project.

Emacs's tag facilities, such as the =find-tag= command, can find anything created with the
def. . . functions (=defun, defalias, defmacro, defvar, defsubst, defconst, defadvice=).

- When you byte-compile the code (see Chapter 5, Lisp Files), the byte-compiler emits a warning for each variable it encounters that hasn't been declared with defvar.
  
** Detecting Errors :lisp:

To keep the user from being baffled by this cryptic error message, it's a good idea to precede the call to goto-char with a simple check and a more informative error message:

#+begin_src emacs-lisp

  (if (not unscroll-point) ;i.e., ifunscroll-point is nil 
    (error "Cannot unscroll yet"))

#+end_src

When =error= is invoked, =execution of unscroll aborts= and the message "Cannot unscroll yet" is displayed.

** Symbol Properties :lisp:

The first is to address this problem: the variables this-command and last-command aren't exclusively ours to do with as we please.For all we know, there exists an Emacs component that depends on the various scroll functions not overriding the settings of this-command and last-command.

Still, we would like a single, distinguished value in last-command to identify all unscrollable commands.

=Here's where symbol properties come in handy. In addition to having a variable value and/or a function definition, every Emacs Lisp symbol may also have associated with it a property list. A property list is a mapping from names to values. Each name is yet another Lisp symbol,
while each value may be any Lisp expression.=

=Properties are stored with the put function and retrieved with the get function.=

#+begin_src emacs-lisp

  ;;if we give the value 17 to the property named some-property belonging to the symbol a-symbol:
    (put 'a-symbol 'some-property 17)
  ;;then
    (get 'a-symbol 'some-property)
  ;;returns 17

#+end_src

If we try to get a property from a symbol that doesn't have that property, the result is nil.

Instead of using unscrollable as a value for ~this-command and last-command~, we can instead use an unscrollable ~property~. We'll set it up so that commands that are unscrollable have the unscrollable property of their names set to t, like so:

#+begin_src emacs-lisp

  (put 'scroll-up 'unscrollable t) 
  (put 'scroll-down 'unscrollable t) 
  (put 'scroll-left 'unscrollable t) 
  (put 'scroll-right 'unscrollable t)

  ;;Now (get x unscrollable) will be true only when x is one of the symbols scroll-up, scroll-down, scroll-left, and scroll-right.

  (defun unscroll-maybe-remember () 
    (if (not (get last-command 'unscrollable)) 
        (setq unscroll-point (point) 
            unscroll-window-start (window-start) 
            unscroll-hscroll (window-hscroll))))
#+end_src
  
** Markers :lisp:

How can we make this code even better?

But before you do, you happen to see a bit of text you'd like to change, and you change it. Then you unscroll. The screen hasn't been correctly restored!

=The reason is that editing text earlier in the buffer changes all the subsequent buffer positions.An edit involving a net addition or removal of n characters adds or subtracts n to or from all subsequent positions.=

it would be a good idea to use markers

=A marker is a special object that specifies a buffer position just like an integer does. But if the buffer position moves because of insertions or deletions, the marker "moves" too so that it keeps pointing to the same
spot in the text.=

#+begin_src emacs-lisp
  ;;we no longer initialize them with nil.
  ;;We instead initialize them as new, empty marker objects using the function make-marker:
  (defvar unscroll-point (make-marker) "Cursor position for next call to 'unscroll'.") 
  (defvar unscroll-window-start (make-marker) "Window start for next call to 'unscroll'.")

  (defun unscroll-maybe-remember () 
    (if (not (get last-command 'unscrollable)) 
        (progn 
            (set-marker unscroll-point (point)) 
            (set-marker unscroll-window-start (window-start)) 
            ;;We don't use a marker for unscroll-hscroll because its value isn't a buffer position.
            (setq unscroll-hscroll (window-hscroll)))))

  (defun unscroll () 
        "Revert to 'unscroll-point' and 'unscroll-window-start'." 
        (interactive) 
        ;;goto-char and set-window-start can both handle arguments that are markers as well as arguments that are integers.
        (goto-char unscroll-point) 
        (set-window-start nil unscroll-window-start) 
        (set-window-hscroll nil unscroll-hscroll))
#+end_src

**** Addendum: Efficiency Consideration

Each marker that points into some buffer somewhere has to be updated every time text is inserted or deleted in that buffer.

A discarded marker object will eventually be reclaimed by the garbage collector, but until it is, it'll slow down editing in its buffer.

In general, when you intend to discard a marker object m (meaning that you no longer intend to refer to its value), =it's a good idea to first make it point "nowhere" by doing this:=

#+begin_src emacs-lisp
(set-marker m nil)
#+end_src

** User Options and Docstrings :lisp:

 define the variables

 #+begin_src emacs-lisp

   (defvar insert-time-format "%X" "*Format for \\[insert-time] (c.f. format-time-string').") 
   (defvar insert-date-format "%x" "*Format for \\[insert-date] (c.f. 'format-time-string').")

 #+end_src

=There are two new things to note about these docstrings.=

=First, each begins with an asterisk (*). A leading asterisk has special meaning in defvar docstrings. It means that the variable in question is a user option.=

user option

User options can be set interactively using =set-variable=, which prompts the user for a variable name (with completion of partially typed names) and a value.

=To set variables interactively when they aren't user options=, you must do something like

~M-: (setq variable value) RET~

User options, but not other variables, can be edited en masse using the ~option-editing mode~ available as ~M-x edit-options RET.~

=The second new thing about these docstrings is that each contains the special construct \[command]. (Yes, it's \[. . . ], but since it's written inside a Lisp string, the backslash has to be doubled: \\[. . . ].) This syntax is magic. When the docstring is displayed to the user-such as when the user uses apropos or describe-variable—\ [command] is replaced with a representation of a keybinding that invokes command.=

For example, if C-x t invokes insert-time, then the docstring

"*Format for \\[insert-time] (c.f. 'format-time-string')."

is displayed as

*Format for C-x t (c.f. 'format-time-string').

If there is no keybinding for insert-time, then M-x insert-time is used. If there are two or more keybindings for insert-time, Emacs chooses one.

Suppose you want the string \[insert-time] to appear literally in a docstring. How could you prevent its keybinding being substituted? For this purpose there is a special escape sequence: ~\=~. When ~\=~ precedes ~\[. . .~ , the magic replacement of \[. . . ] doesn't happen. Of course, Lisp string syntax dictates that this be written as "~. . . \\=\\[. . . . . .~".

\= is also useful for escaping the =asterisk at the beginning of a defvar docstring=, if you don't want the variable to be a user option but you absolutely must have a docstring that begins with an asterisk.

=All variables that are shared between two or more functions should be declared with defvar.=

=Which of those should be user options? A rule of thumb is that if the variable directly controls a user-visible feature that a user might want to change, and if setting that variable is straightforward (i.e., no complex data structures or specially coded values), then it should be a user option.=

** More Asterisk Magic :lisp:

#+begin_src emacs-lisp
(defun insert-time () 
    "Insert the current time according to insert-time-format." 
    (interactive "*") 
    (insert (format-time-string insert-time-format 
    (current-time)))) 
 
 (defun insert-date () 
    "Insert the current date according to insert-date-format."
    (interactive "*") 
    (insert (format-time-string insert-date-format 
    (current-time))))
#+end_src

=The insert function takes any number of arguments (which must all be strings or characters) and inserts them one after another in the current buffer at the present location of point, moving point forward.=

~(interactive)~
=By now you know that interactive turns a function into a command and specifies how to obtain the function's arguments when invoked interactively.=

But we haven't seen * in the argument of interactive before, and besides, these functions take no arguments, so why does interactive have one?

=The asterisk, when it is the first character in an interactive argument, means "abort this function if the current buffer is read-only."=

A more complicated function, though, might cause irreversible side effects (such as changing global variables), expecting to be able to finish, before discovering that it can't.
