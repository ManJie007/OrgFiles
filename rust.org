#+author: JIE MAN
#+title: rust
* Introduction
Cargo 是内置的依赖管理器和构建⼯具，它能轻松增加、编译和管理依赖，并使依赖在 Rust ⽣态系统中保持⼀致。
Rustfmt 格式化⼯具确保开发者遵循⼀致的代码⻛格。
rust-analyzer 为集成开发环境（IDE）提供了强⼤的代码补全和内联错误信息功能。
* Chapter 1 how to install Rust, how to write a “Hello, world!” program, and how to use Cargo, Rust’s package manager and build tool.
** Installation
~rustup~  managing Rust versions and associated tools

~curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh~

need a linker, which is a program that Rust uses to join its compiled outputs into one file.
  install a C compiler, which will typically include a linker.

macos: ~xcode-select --install~

Linux:GCC/Clang build-essential

windows: [[https://www.rust-lang.org/tools/install]]
         [[https://rust-lang.github.io/rustup/installation/windows-msvc.html]]
** Troubleshooting
~rustc --version~

check $PATH (unix) / %PATH% (windows)
** Updating and Uninstalling
~rust update~
~rust self uninstall~
** Local Documentation
~rustup doc~
** Hello, World!

~mkdir ~/projects~
~cd ~/projects~
~mkdir hello_world~
~cd hello_world~

#+begin_src rust

  //main.rs

  fn main() {
      println!("Hello, world!"); //println! a Rust macro
  }  

#+end_src

~rustc main.rs~
~./main~
** Hello, Cargo!

~cargo --version~

Creating a Project with Cargo
~cargo new project~
~cd project~

project
|-.gitignore
|-Cargo.toml [[https://toml.io/][TOML]] (Tom’s Obvious, Minimal Language) format
|-src
   |-main.rs

~cargo new --vcs=git project~
~cargo new --help~

#+begin_src rust

  //src/main.rs
  fn main() {
    println!("Hello, world!");
  }

#+end_src
               
If you started a project that doesn’t use Cargo, you can convert it to a project that does use Cargo.
  1.Move the project code into the src directory
  2.create an appropriate Cargo.toml file.
  ~cargo init~ create /Cargo.toml/

Building and Running a Cargo Project
~cargo build~
 default build is a debug build
 creates an executable file in target/debug/XXX (or target\debug\XXX.exe on Windows)
 Cargo create /Cargo.lock/ keeps track of the exact versions of dependencies in your project.
 
~cargo run~ build and run

~cargo check~ checks your code to make sure it compiles but doesn’t produce an executable

Building for Release

~cargo build --release~

* Chapter 2 introduction to writing a program in Rust, build up a number guessing game

Learn about =let, match, methods, associated functions, external crates=

Setting Up a New Project
~cargo new guessing_game~
~cd guessing_game~
~cargo run~

Processing a Guess

#+begin_src rust

use std::io;

fn main() { 
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("Your guessed: {}", guess);
}

#+end_src

=std::io= input/output library
/prelude/ a set of items defined in the standard library that it brings into the scope of every program.

println! is a macro prints a string to the screen

** =let= to create the variable
=In Rust, variables are immutable by default=
To make a variable mutable, we add =mut= before the variable name

~let apples = 5; // immutable~
~let mut bananas = 5; // mutable~

** Associated Function
=The :: syntax in the ::new line indicates that new is an associated function of the String type.=
=An associated function is a function that’s implemented on a type, in this case String.=

** Receiving User Input
~use std::io; io::stdin()~ or ~std::io::stdin()~

** reference
The & indicates that this argument is a reference,
which gives you a way to let multiple parts of your code access =one piece of data without needing to copy that data into memory multiple times.=
like variables, references are immutable by default.
Hence, you need to write =&mut guess= rather than =&guess= to make it mutable.

** =Handling Potential Failure with Result=
~.expect("Failed to read line");~
=read_line= puts whatever the user enters into the string we pass to it, but it also returns a =Result= value.
=Result= is an =enumeration=, a type that can be in one of multiple possible states.Each possible state a variant.
=Result= types is to encode error-handling information.
=Result='s variants are =Ok= and =Err=.
  Values of the =Result= type, like values of any type, have methods defined on them.
  An instance of Result has an =expect method=.
  If this instance of =Result= is an =Err= value, =expect= will cause the program to crash and display the message that you passed as an argument to expect.
  If this instance of =Result= is an =Ok= value, =expect= will take the return value that =Ok= is holding and return just that value to you so you can use it.

** Printing Values with println! Placeholders
~println!("You guessed: {}", guess);~
The {} set of curly brackets is a placeholder

#+begin_src rust
  let x = 5;
  let y = 10;

  println!("x = {x} and y + 2 = {}", y + 2);
#+end_src

Generating a Secret Number
[[https://crates.io/crates/rand][rand crate]]

** =a crate is a collection of Rust source code files=
is a library crate

modify the /Cargo.toml/ file to include the =rand crate= as a dependency.
#Cargo.toml
[dependencies]
rand = "0.8.5"

[[http://semver.org/][Semantic Versioning]] (sometimes called SemVer)
| MAJOR | 主版本号：做了不兼容的 API 修改（破坏性变更） |
| MINOR | 次版本号：增加了新功能，但向下兼容            |
| PATCH | 补丁号：修复了 bug，完全兼容                  |

~cargo build~

=registry= a copy of data from [[https://crates.io/][Crates.io]].
=Crates.io= is where people in the Rust ecosystem post their open source Rust projects for others to use.

Ensuring Reproducible Builds with the Cargo.lock File
=Cargo.lock=
When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the =Cargo.lock= file.
When you build your project in the future, Cargo will see that the =Cargo.lock= file exists and will use the versions specified there rather than doing all the work of figuring out versions again. 
Because the =Cargo.lock= file is important for =reproducible builds=, =it’s often checked into source control= with the rest of the code in your project.

Updating a Crate to Get a New Versions
~cargo update~
will ignore the =Cargo.lock= file and figure out all the latest versions that fit your specifications in =Cargo.toml=.
Cargo will then write those versions to the =Cargo.lock= file.

Generating a Random Number

#+begin_src rust

  use rand::Rng;
  use std::io;

  fn main() {
      println!("Guess the number!");

      let secret_number = rand::thread_rng().gen_range(1..=100);

      println!("Please input your guess.");

      let mut guess = String::new();

      io::stdin()
          .read_line(&mut guess)
          .expect("Failed to read line");

      println!("Your guessed: {}", guess);
  }

#+end_src

** =Rng= =trait= defines methods that random number generators implement.
trait 相当于其他语言里的「接口（Interface）」或「特征」。
定义一组行为（函数签名），谁实现了这个 trait，谁就必须实现这些函数。
主要用于 抽象、泛型、多态
~rand::thread_rng~
  the particular random number generator is local to the current thread of execution and is seeded by the operating system

~gen_range~
  method on the random number generator
  defined by the =Rng trait=

~start..=end~
  range expressio
  is inclusive on the lower and upper bounds 左闭右闭区间

each crate has documentation with instructions for using it.
~cargo doc --open~

Comparing the Guess to the Secret Number

#+begin_src rust

use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("Your guessed: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too samll!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}  

#+end_src

~use std::cmp::Ordering;~
  The =Ordering= type is another enum and has the variants =Less=, =Greater=, and =Equal=.


=cmp= method compares two values and =can be called on anything that can be compared.=
  it returns a variant of the =Ordering enum=

** =match= expression
  is made up of arms.
  An arm consists of a pattern to match against, and the code that should be run if the value given to match fits that arm’s pattern.
  Rust takes the value given to match and looks through each arm’s pattern in turn.

Rust has a strong, static type system.
However, it also has type inference.
When we wrote =let mut guess = String::new()=, Rust was able to infer that =guess= should be a =String= and didn’t make us write the type.
The =secret_number=, on the other hand, is a number type.
A few of Rust’s number types can have a value between 1 and 100:
  =i32=
  =u32=
  =i64=
  ...
 Unless otherwise specified, Rust defaults to an =i32=
 unless you add type information

~let guess: u32 = guess.trim().parse().expect("Please type a number!");~
convert the String the program reads as input into a number type

** =Rust allows us to shadow the previous value of guess with a new one.=
=Shadowing lets us reuse the guess variable name=
注意这里同名的同时新的值类型也变了！！！
The =parse= method on strings converts a string to another type.
We need to tell Rust the exact number type we want by using let guess: u32.
The =colon (:)= after guess tells Rust we’ll =annotate the variable’s type.=
the =parse= method returns a =Result type=, much as the =read_line= method does
  [[*=Handling Potential Failure with Result=]]
  If =parse= returns an =Err Result= variant because it couldn’t create a number from the string, the =expect= call will crash the game and print the message we give it.
  If =parse= can successfully convert the string to a number, it will return the =Ok= variant of Result, and =expect= will return the number that we want from the =Ok= value.

** Allowing Multiple Guesses with Looping & Quitting After a Correct Guess

=loop= keyword creates an infinite loop.
=break= statement

#+begin_src rust

use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() { ▶︎ Run |Debug
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = guess.trim().parse().expect("Please type a number!");

        println!("Your guessed: {guess}");

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too samll!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}

#+end_src

Handling Invalid Input
make the game ignore a non-number so the user can continue guessing

#+begin_src rust

use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() { ▶︎ Run |Debug
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("Your guessed: {guess}");

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too samll!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}

#+end_src

=parse= returns a =Result= type and =Result= is an enum that has the variants =Ok= and =Err=.
If =parse= is able to successfully turn the string into a number, it will return an =Ok= value that contains =the resultant number=.
注意这里{}中最后就是返回值
=The underscore, _=, is a =catchall value;=

* Chapter 3 Rust features that are similar to those of other programming languages

=variables, basic types, functions, comments, and control flow=

** Variables and Mutability

=by default, variables are immutable.=
cannot assign twice to immutable variable
~cargo check~
you can make them mutable by adding =mut= in front of the variable name
~let mut x = 5;~
~x = 6;~

*** Constants

/constants/ are values that are bound to a name and are not allowed to change
differences between constants and variables:
  1.not allowed to use =mut= with constants.
  2.declare constants using the =const= keyword
  3.the =type of the value must be annotated=
  4.constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.

~const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;~

Rust’s naming convention for constants is to use =all uppercase with underscores between words.=

*** Shadowing

you can declare a new variable with the same name as a previous variable.
the first variable is =shadowed= by the second,
the second variable overshadows the first, taking any uses of the variable name to itself until =either it itself is shadowed or the scope ends.=
shadow a variable by using =the same variable’s name= and repeating the use of the =let keyword=

#+begin_src rust

  fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
 }

#+end_src

$cargo run
   Compiling variables v0.1.0 (/Users/jieman/Desktop/projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.64s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6

=Shadowing is different from marking a variable as mut=
  1.because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the =let keyword.=
  2.we’re effectively =creating a new variable= when we use the =let keyword again=, we can =change the type= of the value but reuse the same name.
  ~let spaces = "   ";~ string type
  ~let spaces = spaces.len();~ number type

  ~let mut spaces = "   ";~
  ~spaces = spaces.len();~ =get a compile-time error!!!=

** Data Types

=scalar and compound=

Rust is a /statically typed/ language, which means that it must know the types of all variables at compile time.

The compiler can usually =infer= what type we want to use based on the value and how we use it.

In cases when many types are possible, we must add a =type annotation(: type)=

~let guess: u32 = "42".parse().expect("Not a number!");~

*** Scalar Types

=integers, floating-point numbers, Booleans, and characters.=

Integer Types

| Length  | Signed | Unsigned |
|---------+--------+----------|
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

Signed numbers are stored using [[https://en.wikipedia.org/wiki/Two%27s_complement][two’s complement]] representation.

signed variant can store numbers from $-(2^{(n-1)})$ to $2^{(n-1)} - 1$ 左闭右闭区间
n is the number of bits that variant uses.

Unsigned variants can store numbers from 0 to $2^{n} - 1$

number literals

| Number literals | Example     |
|-----------------+-------------|
| Decimal         | 98_222      |
| Hex             | 0xff        |
| Octal           | 0o77        |
| Binary          | 0b1111_0000 |
| Byte (u8 only)  | b'A'        |

Number literals can also use =_= as a visual separator to make the number easier to read

=Integer Overflow=
When you’re compiling in debug mode,
  Rust includes checks for integer overflow that cause your program to =panic= at runtime if this behavior occurs.
  Rust uses the term =panicking= when a program exits with an error;

When you’re compiling in release mode with the =--release= flag
  Rust does not include checks for integer overflow that cause panics.
  if overflow occurs, Rust performs =two’s complement wrapping=.

To explicitly handle the possibility of overflow, can use these families of methods provided by the standard library for primitive numeric types
  Wrap in all modes with the =wrapping_*= methods, such as =wrapping_add=.
  Return the =None= value if there is overflow with the =checked_* methods=.
  Return the value and a boolean indicating whether there was overflow with the =overflowing_*= methods.
  Saturate at the value’s minimum or maximum values with the =saturating_*= methods.

Floating-Point Types
  =f32= and =f64=
  The default type is =f64= because on modern CPUs, it’s roughly the same speed as =f32= but is capable of more precision.
  All floating-point types are =signed=.

  #+begin_src rust
  fn main() {
      let x = 2.0; // f64
  
      let y: f32 = 3.0; // f32
  }    
  #+end_src

  =IEEE-754 standard=

Numeric Operations
  =+,-,*,/,%=

  =Integer division truncates toward zero to the nearest integer.=

The Boolean Type
  =true= and =false=
  one byte in size
  ~: bool~
  The main way to use =Boolean= values is through conditionals, such as an =if expression=.

The Character Type
  =char=
  single quotes =''=
  =four bytes in size and represents a Unicode Scalar Value=
  Unicode Scalar Values range from =U+0000= to =U+D7FF= and =U+E000= to =U+10FFFF= inclusive.
  [[https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings][“Storing UTF-8 Encoded Text with Strings”]]

*** Compound Types

group multiple values into one type
=tuples= and =arrays=

**** The Tuple Type
  Tuples have a =fixed length=: once declared, they cannot grow or shrink in size.
  =comma-separated list of values inside parentheses=
  ~let tup: (i32, f64, u8) = (500, 6.4, 1);~
  a tuple is considered a single compound element.
  =use pattern matching to destructure a tuple value=
  ~let (x, y, z) = tup;~  =destructuring=
  ~let five_hundred = tup.0;~
  ~let six_point_four = tup.1;~
  access a tuple element directly by using a period =(.)= followed by the =index= of the value we want to access

  The tuple without any values has a special name, =unit.=
  This value and its corresponding type are both written =()=
  =在 Rust 中，如果一个函数不返回任何有用的值，它其实返回的是 ()，也就是单元类型。=

**** The Array Type
  =Unlike a tuple, every element of an array must have the same type.=
  arrays in Rust have a =fixed length.=
  =comma-separated list inside square brackets=
  ~let a = [1, 2, 3, 4, 5];~
  Arrays are useful when you want your data allocated on the =stack=,rather than the =heap=
  An array isn’t as flexible as the =vector= type, though.
  =A vector is a similar collection type provided by the standard library that is allowed to grow or shrink in size.=
  ~let a: [i32; 5] = [1, 2, 3, 4, 5];~ [i32; 5] =an array’s type using square brackets with the type of each element, a semicolon, and then the number of elements=

    =initialize an array to contain the same value for each element by specifying the initial value, followed by a semicolon, and then the length of the array=
  ~let a = [3; 5];~

  Accessing Array Elements
  =An array is a single chunk of memory of a known, fixed size that can be allocated on the stack.=
  access elements of an array using indexing
  ~let first = a[0];~
  ~let second = a[1];~

   In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed.
   =Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing.=
   
** Functions

=main= function,entry point of many programs.

uses =snake= case as the conventional style for function and variable names
=all letters are lowercase and underscores separate words.=

#+begin_src rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}  
#+end_src

~fn function_name(parentheses) {body}~

=we defined another_function after the main function in the source code;=
这里和c/cpp的调用函数前需声明不同！！！

Parameters
=parameter= and =argument=
the variables in a function’s definition and the concrete values passed in when you call a function.

#+begin_src rust
  fn main() {
      another_function(5);
      print_labeled_measurement(5, 'h');
  }

  fn another_function(x: i32) {
      println!("The value of x is: {x}");
  }

  fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
  }
#+end_src

=In function signatures, you must declare the type of each parameter.=

** Statements and Expressions

=Function bodies are made up of a series of statements optionally ending in an expression.=

=Rust is an expression-based language=

=Statements= are instructions that perform some action and =do not return a value.=
=Expressions= evaluate to a resultant value.

statement:
  ~let y = 6;~
  ~Function definitions~
  =Statements do not return values.=
  =Therefore, you can’t assign a let statement to another variable=

#+begin_src rust
fn main() {
    let x = (let y = 6); //error
}  
#+end_src

C and Ruby the assignment returns the value of the assignment.

Expressions evaluate to a value
  math operation ~5+6~
  =Calling a function is an expression.=
  =Calling a macro is an expression.=
  =A new scope block created with curly brackets is an expression=
  #+begin_src rust
    let y = {
        let x = 3;
        x + 1 //Expressions do not include ending semicolons.
        //If you add a semicolon to the end of an expression, you turn it into a statement, and it will then not return a value.
    };
  #+end_src

** Functions with Return Values

we must declare their type after an =arrow (->).=
In Rust, the return value of the function is the value of the final expression in the block of the body of a function.
can return early from a function by using the =return= keyword and specifying a value

#+begin_src rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}
#+end_src

** Comments

~// hello, world~

Comments can also be placed at the end of lines containing code:
~let lucky_number = 7; // I’m feeling lucky today~

Rust also has another kind of comment, documentation comments
[[https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html][“Publishing a Crate to Crates.io”]]

** Control Flow

=if=, =else= expressions and loops.

=if= Expressions
#+begin_src rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+end_src

#+begin_src rust
fn main() {
    let number = 3;

    if number { // error, condition must be a bool!!!
        println!("number was three");
    }
}
#+end_src

=Unlike languages such as Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a Boolean.=

=condition must be a boolean=

#+begin_src rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}
#+end_src

Handling Multiple Conditions with =else if=

#+begin_src rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+end_src

=Rust only executes the block for the first true condition, and once it finds one, it doesn’t even check the rest.=

Using =if= in a =let= Statement
~let number = if condition { 5 } else { 6 };~
=the values that have the potential to be results from each arm of the if must be the same type;=
~let number = if condition { 5 } else { "six" }; //error, must same type~

Repetition with Loops
=loop=, =while=, =for=

#+begin_src rust
fn main() {
    loop {
        println!("again!");
    }
}
#+end_src

Most terminals support the keyboard shortcut =ctrl-c= to interrupt a program that is stuck in a continual loop.

*** Returning Values from Loops

add the value you want returned after the =break= expression

#+begin_src rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
#+end_src

 After the loop, we use a =semicolon= to end the statement that assigns the value to result.

 You can also =return= from inside a loop.

 =break= exits the current loop.
 
 =return= exits the current function.
 
*** Loop Labels to Disambiguate Between Multiple Loops

optionally =a loop label= on a loop that you can then use with =break= or =continue= to specify that those keywords apply to the labeled loop instead of the innermost loop.

=single quote=

#+begin_src rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
#+end_src

~cargo run~

*** Conditional Loops with while

It’s possible to implement behavior like this using a combination of =loop=, =if=, =else= and =break=

#+begin_src rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+end_src

*** Looping Through a Collection with for

#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+end_src

we could cause the program to panic if the index value or test condition is incorrect.

For example, if you changed the definition of the a array to have four elements but forgot to update the condition to while index < 4, the code would panic.

=It’s also slow, because the compiler adds runtime code to perform the conditional check of whether the index is within the bounds of the array on every iteration through the loop.=

[[*Data Types]]
=Integer Overflow=
When you’re compiling in debug mode,
  Rust includes checks for integer overflow that cause your program to =panic= at runtime if this behavior occurs.
  Rust uses the term =panicking= when a program exits with an error;

#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
#+end_src

=Range=  provided by the standard library
左闭右开区间

#+begin_src rust
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
#+end_src

* Chapter 4 Rust’s ownership system

=to make memory safety guarantees without needing a garbage collector=

ownership features: =borrowing=, =slices=, and how =Rust lays data out in memory.=

** What Is Ownership?

=a set of rules that govern how a Rust program manages memory=

All programs have to manage the way they use a computer’s memory while running.
  Some languages have garbage collection
  other languages must explicitly allocate and free the memory
  Rust uses a third approach: =memory is managed through a system of ownership with a set of rules that the compiler checks.=

*** The Stack and the Heap

the stack and the heap are parts of memory available at runtime
All data stored on the stack must have a =known, fixed size.=
Data with an unknown size at compile time or a size that might change must be stored on the =heap=.
Because the pointer to the heap is a known, fixed size, you can store the pointer on the stack.
When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s =local variables get pushed onto the stack.=
When the function is over, =those values get popped off the stack.=
=the main purpose of ownership is to manage heap data=

*** Ownership Rules
Each value in Rust =has an owner.=
There can only be =one owner at a time.=
When the =owner goes out of scope=, the value will be =dropped=.

*** Variable Scope
A scope is the range for which an item is valid

#+begin_src rust
{                      // s is not valid here, it’s not yet declared
    let s = "hello";   // s is valid from this point forward

    // do stuff with s
}                      // this scope is now over, and s is no longer valid
#+end_src

*** The String Type

string literals are immutable.

data that is stored on the heap.

~let s = String::from("hello");~

~::~ operator allows us to =namespace= this particular from function under the =String= type

#+begin_src rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() appends a literal to a String

println!("{s}"); // This will print `hello, world!`
#+end_src

Why can String be mutated but literals cannot?

*** Memory and Allocation

string literal is hardcoded directly into the final executable.

String type , in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap
  The memory must be requested from the memory allocator at runtime.
    ~String::from~
  We need a way of returning this memory to the allocator when we’re done with our String.
    In languages with a =garbage collector (GC)=, the GC keeps track of and cleans up memory
    In most languages without a GC, it’s our responsibility to identify when memory is no longer being used and to call code to explicitly free it
      ~free/delete c/cpp~
    Rust takes a different path:
      the memory is automatically returned =once the variable that owns it goes out of scope.=
      #+begin_src rust
      {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
      }                                  // this scope is now over, and s is no
      #+end_src

When a variable goes out of scope, Rust calls a special function for us.
  [[https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop][drop]] function

Rust calls =drop= automatically at the =closing curly bracket.=

RAII In C++, this pattern of deallocating resources at the end of an item’s lifetime is sometimes called Resource Acquisition Is Initialization (RAII).

the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we’ve allocated on the heap.

*** Variables and Data Interacting with Move

#+begin_src rust
    let x = 5;
    let y = x;
#+end_src

bind the value 5 to x; then make a =copy= of the value in x and bind it to y
=two 5 values are pushed onto the stack.=

#+begin_src rust
  let s1 = String::from("hello");
  let s2 = s1;
#+end_src

A String is made up of three parts:
  1.a pointer to the memory that holds the contents of the string
  2.a length
  3.a capacity

[[./pictures/rust/1.png]]

This group of data is stored on the =stack=.
On the right is the memory on the =heap= that holds the contents.

assign =s1= to =s2=, the String =data= is copied,
  we copy the pointer, the length, and the capacity that are =on the stack.=
  =do not copy the data on the heap=

[[./pictures/rust/2.png]]  

when a variable goes out of scope, Rust automatically calls the =drop= function and cleans up the heap memory for that variable.

Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1;

println!("{s1}, world!");
#+end_src

after the line ~let s2 = s1;~
Rust considers ~s1~ as no longer valid.
=Therefore, Rust doesn’t need to free anything when s1 goes out of scope.=
if you try to use s1 after s2 is created; =error!!!=

=shallow copy= and =deep copy=
  shallow copy -- copying the pointer, length, and capacity without copying the data.

=move= -- =Rust also invalidates the first variable, instead of being called a shallow copy=
  [[./pictures/rust/3.png]]
  避免二次free

=Rust will never automatically create “deep” copies of your data.=

*** Scope and Assignment

When you assign a completely new value to an existing variable, Rust will call =drop= and free the original value’s memory immediately.

#+begin_src rust
let mut s = String::from("hello");
s = String::from("ahoy");

println!("{s}, world!");
#+end_src

[[./pictures/rust/4.png]]

*** Variables and Data Interacting with Clone

=clone=
  deeply copy the heap data

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {s1}, s2 = {s2}");
#+end_src

*** Stack-Only Data: Copy

types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make.

a special annotation =Copy= trait
  we can place on types
  =stored on the stack=

If a type implements the =Copy= trait
  not =move=
  trivially copied, =still valid after assignment to another variable=

#+begin_src rust
let x = 5;
let y = x;

println!("x = {x}, y = {y}");
#+end_src

Rust won’t let us annotate a type with =Copy= if the type, or any of its parts, has implemented the =Drop trait=

[[https://doc.rust-lang.org/book/appendix-03-derivable-traits.html][“Derivable Traits”]]

types implement the =Copy= trait:
  simple scalar values
  nothing that requires allocation or is some form of resource
  All the =integer= types, such as u32.
  The =Boolean type=, bool, with values true and false.
  All the =floating-point= types, such as f64.
  The =character type=, char.
  =Tuples=, if they only =contain types that also implement Copy=. For example, (i32, i32) implements Copy, but (i32, String) does not.

*** Ownership and Functions

=Passing a variable to a function will move or copy, just as assignment does.=

#+begin_src rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // because i32 implements the Copy trait,
                                    // x does NOT move into the function,
    println!("{}", x);              // so it's okay to use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{some_string}");
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{some_integer}");
} // Here, some_integer goes out of scope. Nothing special happens.
#+end_src

If we tried to use =s= after the call to =takes_ownership=, Rust would throw a compile-time error.

*** Return Values and Scope

also transfer =ownership=
联想cpp 的拷贝和移动 对象

#+begin_src rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("yours"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
#+end_src

=The ownership of a variable : assigning a value to another variable moves it.=

When a variable that includes data on the heap goes out of scope, the value will be cleaned up by drop unless ownership of the data has been moved to another variable.

=What if we want to let a function use a value but not take ownership?=

1.return multiple values using a =tuple=

#+begin_src rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{s2}' is {len}.");
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
#+end_src

2.using a value without transferring ownership, called =references.=

** References and Borrowing

A reference is like a pointer in that it’s an address we can follow to access the data stored at that address;

Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type =for the life of that reference.!!!=

#+begin_src rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because s does not have ownership of what
  // it refers to, the value is not dropped.
#+end_src

[[./pictures/rust/5.png]]

rust暂时给我的感觉
  c/cpp 的 拷贝和移动
  但是只有一个owner同时，owner出了作用域，如果data没有被move，会执行drop释放

referencing   =&= refer to some value without taking ownership
dereferencing =*=

引用因为没有 ownership，出了作用域，不会释放资源

=borrowing=, the action of creating a reference

=if we try to modify something we’re borrowing? Maybe Error!!!=

#+begin_src rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
#+end_src

=variables are immutable by default, so are references. We’re not allowed to modify something we have a reference to.=

*** Mutable References

mutable variable and mutable reference

#+begin_src rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
#+end_src

#+begin_src rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s; //Error!!!

println!("{}, {}", r1, r2);
#+end_src

Mutable references have one big restriction:
  if you have =a mutable reference= to a value,
  =you can have no other references to that value.=

The benefit of having this restriction is that Rust can =prevent data races= at compile time.

A data race:
  1.Two or more pointers access the same data at the same time.
  2.At least one of the pointers is being used to write to the data.
  3.There’s no mechanism being used to synchronize access to the data.

Data races cause =undefined behavior=

=we can use curly brackets to create a new scope=
  allowing for multiple mutable references

#+begin_src rust
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;
#+end_src

=cannot have a mutable reference while we have an immutable one to the same value.=

#+begin_src rust
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
let r3 = &mut s; // BIG PROBLEM

println!("{}, {}, and {}", r1, r2, r3);
#+end_src

Users of an immutable reference don’t expect the value to suddenly change out from under them!

=multiple immutable references are allowed=
  no one who is just reading the data has the ability to affect anyone else’s reading of the data.

=reference’s scope=
  starts from where it is introduced
  =continues through the last time that reference is used.=

#+begin_src rust
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
println!("{r1} and {r2}");
// variables r1 and r2 will not be used after this point

let r3 = &mut s; // no problem
println!("{r3}");
#+end_src  

this code will compile because the last usage of the immutable references is in the println!, before the mutable reference is introduced.

The scopes of the immutable references r1 and r2 end after the println! where they are last used, which is before the mutable reference r3 is 

*** Dangling References

In Rust, the compiler guarantees that references will never be dangling references

#+begin_src rust
  // Error, cannot compile
  fn main() {
      let reference_to_nothing = dangle();
  }

fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
#+end_src

=lifetimes=

solution here is to return the String directly:

#+begin_src rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
#+end_src

Ownership is moved out, and nothing is deallocated.

*** The Rules of References

At any given time, =you can have either one mutable reference or any number of immutable references.=
References must =always be valid.=

** The Slice Type a different kind of reference

reference a contiguous sequence of elements in a [[https://doc.rust-lang.org/book/ch08-00-common-collections.html][collection]] rather than the whole collection.

a kind of reference, =so it does not have ownership.=

a small programming problem:
  write a function that takes a string of words separated by spaces and returns the first word it finds in that string.
  If the function doesn’t find a space in the string, the whole string must be one word, so the entire string should be returned.

=In idiomatic Rust, functions do not take ownership of their arguments unless they need to, and the reasons for that will become clear as we keep going!=  
  
without using slices
  we could return the index of the end of the word, indicated by a space.
#+begin_src rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#+end_src
  =as_bytes= : convert our String to an array of bytes
  =iter= : create an iterator over the array of bytes
  =enumerate= : wraps the result of iter and returns each element as part of a tuple instead.
  =use patterns to destructure tuple=
  =byte literal syntax= b' '

We’re returning a usize on its own, but it’s only a meaningful number in the context of the &String.
In other words, because it’s a separate value from the String, there’s no guarantee that it will still be valid in the future.

#+begin_src rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // `word` still has the value `5` here, but `s` no longer has any content
    // that we could meaningfully use with the value `5`, so `word` is now
    // totally invalid!
}
#+end_src

~fn second_word(s: &String) -> (usize, usize) {~

Rust has a solution to this problem: string slices.

*** String Slices

 reference to part of a String

#+begin_src rust
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
#+end_src

左开右闭区间

[[./pictures/rust/6.png]]

Rust’s ~..~ range syntax

#+begin_src rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2]; //equal

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..]; //equal

let slice = &s[0..len];
let slice = &s[..]; //equal
#+end_src

#+begin_src rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
#+end_src

We now have a straightforward API that’s much harder to mess up because the compiler will ensure the references into the String remain valid.

#+begin_src rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {word}");
}
#+end_src

=if we have an immutable reference to something, we cannot also take a mutable reference.=
clear needs to truncate the String, it needs to get a mutable reference.
注意引用的scope [[*Mutable References]]
  不是{} 而是最后使用的地方

Rust disallows the mutable reference in clear and the immutable reference in word from existing at the same time, and compilation fails.

*** String Literals as Slices

string literals being stored inside the binary.

~let s = "Hello, world!";~

The type of =s= here is =&str=

=it’s a slice pointing to that specific point of the binary=

This is also why string literals are immutable;
  &str is an immutable reference.

*** String Slices as Parameters

~fn first_word(s: &String) -> &str {~

A more experienced Rustacean would write

~fn first_word(s: &str) -> &str {~

=allows us to use the same function on both &String values and &str values.=
  if we have a string slice, we can pass that directly.
  If we have a String, we can pass a slice of the String or a reference to the String.
    =deref coercions= [[https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods][“Implicit Deref Coercions with Functions and Methods”]]

Defining a function to take a string slice instead of a reference to a String makes our API more general and useful without losing any functionality

#+begin_src rust
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
#+end_src

~let s = "Hello, world!";~

The type of =s= here is =&str=

*** Other Slices

~let a = [1, 2, 3, 4, 5];~
~let slice = &a[1..3];~
~assert_eq!(slice, &[2, 3]);~

左开右闭区间

You’ll use this kind of slice for all sorts of other collections.

** Summary

=ownership=, =borrowing=, and =slices= ensure memory safety in Rust programs at compile time.

The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don’t have to write and debug extra code to get this control.

* CHAPTER 5 structs and methods

=struct= is a custom data type
how to define associated functions

** Defining and Instantiating Structs

tuple [[https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type][The Tuple Type]]

name each piece of data -- /fields/

#+begin_src rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
#+end_src

#+begin_src rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
#+end_src

We don’t have to specify the fields in the =same order in which we declared them in the struct.=

To =get= a specific value from a struct, we use =dot notation.=

#+begin_src rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
#+end_src

the entire instance must be mutable;
Rust doesn’t allow us to mark only certain fields as mutable.

#+begin_src rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
#+end_src

=Luckily, there’s a convenient shorthand!=

*** Using the Field Init Shorthand

注意与 ./go.org 中的 =Named Return Values= 异同

#+begin_src rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
#+end_src

=the same name=

*** Creating Instances from Other Instances with Struct Update Syntax

#+begin_src rust
fn main() {
    // --snip--

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
#+end_src

~..~ struct update syntax
=specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance=

#+begin_src rust
fn main() {
    // --snip--

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
#+end_src

~..user1~ must come last
can choose to specify values for as many fields in any order

struct update syntax ~=~ like an assignment
  it =moves the data=
  [[*Variables and Data Interacting with Move]]

  can no longer use =user1= after creating =user2=
  the =String= in the =username= field of =user1= was =moved= into =user2=.

  if we had given =user2 new String values= for both email and username, and thus only used the active and sign_in_count values from user1,
  then =user1= would still be =valid= after creating user2.

  =active= and =sign_in_count= implement the =Copy= trait
  [[* Stack-Only Data: Copy]]
  
*** Using Tuple Structs Without Named Fields to Create Different Types

=tuple structs=

struct name provides but don’t have names fields

useful:
  want to give the whole tuple a name
  make the tuple a different type from other tuples

#+begin_src rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
#+end_src

a function that takes a parameter of type Color cannot take a Point as an argument

use a ~.~ followed by the ~index~ to access an individual value

~black.0~
[[*Compound Types]]

destructure:
  require you to name the type of the struct
  ~let Point(x, y, z) = point;~

*** Unit-Like Structs Without Any Fields

=unit-like structs= structs that don’t have any fields!

similarly to =()= [[https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type][The Tuple Type]]

=useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself.=

#+begin_src rust
struct AlwaysEqual; //declaring

fn main() {
    let subject = AlwaysEqual; //instantiating
}
#+end_src

*** Ownership of Struct Data

It’s also possible for structs to =store references= to data owned by something else, but to do so requires the use of =lifetimes=, a Rust feature that we’ll discuss in Chapter 10.

try to store a reference in a struct without specifying lifetimes, like the following;
=Error=

#+begin_src rust
struct User {
    active: bool,
    username: &str,
    email: &str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}
#+end_src

In Chapter 10, we’ll discuss how to fix these errors so you can store references in structs

** An Example Program Using Structs

calculates the area of a rectangle

~cargo new rectangle~

#+begin_src rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
#+end_src

=we defined another_function after the main function in the source code;=
这里和c/cpp的调用函数前需声明不同！！！

it’s not clear anywhere in our program that the parameters are related.

It would be more readable and more manageable to group width and height together.

using tuples [[*Compound Types]]

*** Refactoring with Tuples

#+begin_src rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
#+end_src

[[*Compound Types]]

Mixing up the width and height wouldn’t matter for the area calculation, but if we want to draw the rectangle on the screen, it would matter!

This would be even harder for someone else to figure out and keep in mind if they were to use our code.

 Because we haven’t conveyed the meaning of our data in our code, it’s now easier to introduce errors.

*** Refactoring with Structs: Adding More Meaning

use structs to add meaning by labeling the data

transform : tuple -> struct

#+begin_src rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
#+end_src

reference borrow the struct rather than take ownership of it.

This is a win for clarity.

*** Adding Useful Functionality with Derived Traits

1.using the [[https://doc.rust-lang.org/std/macro.println.html][println! marco]]

#+begin_src rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1); //Error!!!
}
#+end_src

=error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`=

The =println! macro= can do many kinds of formatting
the curly brackets ={}= tell println! to use formatting known as =Display=

But with structs, the way println! should format the output is less clear because there are more display possibilities
  Rust doesn’t try to guess what we want,
  and structs don’t have a provided implementation of Display to use with println! and the {} placeholder.

=help: the trait `std::fmt::Display` is not implemented for `Rectangle`=
=note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead=

=println!("rect1 is {rect1:?}");= tells =println!= we want to use an output format called =Debug=.

=Debug trait=
  enables us to print our struct

=error[E0277]: `Rectangle` doesn't implement `Debug`=

=add the outer attribute #[derive(Debug)]=

#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {rect1:?}");
}
#+end_src

When we have larger structs, it’s useful to have output that’s a bit easier to read;
  use ~{:#?}~ instead of ~{:?}~ in the ~println!~ string.

2.using [[https://doc.rust-lang.org/std/macro.dbg.html][dbg! marco]] -- Another way to print out a value using the =Debug= format

  which =takes ownership of an expression= (as opposed to =println!, which takes a reference=)

  returns ownership of the value.

  prints the =file and line number=

  =dbg! macro= prints to the standard error console stream =(stderr)=
  =println!= prints to the standard output console stream =(stdout)=

  [[https://doc.rust-lang.org/book/ch12-06-writing-to-stderr-instead-of-stdout.html]["Writing Error Messages to Standard Error Instead of Standard Output” section in Chapter 12]]

#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
#+end_src

=dbg!=  returns ownership of the expression’s value

We don’t want =dbg! to take ownership of rect1=, so we =use a reference= to rect1 in the next call.

use =derive= attribute

[[https://doc.rust-lang.org/book/appendix-03-derivable-traits.html][traits]]

how we can continue to refactor this code by turning the area function into an area method defined on our Rectangle type.

** Method Syntax

Unlike functions,
  1.defined within the context of a =struct (or an enum or a trait object)=
  2.first parameter is always =self=, which =represents the instance= of the struct the method is being called on.
    为什么是self 可以看侯捷的深入理解C++对象模型，方法是单独的内存，不和class在一起 要不然每个实例一份函数 内存太大

*** Defining Methods

#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
#+end_src

=impl(implementation)= block
  will be associated with the =that type=

=&self= is actually short for =self: &Self=
  =Self= is an alias for the type that the =impl= block is for

=self= take ownership of =self=
       want to prevent the caller from using the original instance
=&self= method borrows the =Self= instance
        borrow =self= immutably
=&mut self= borrow =self= mutably

The main reason for using methods instead of functions is for =organization=.

we can choose to give a method the same name as one of the struct’s fields.

#+begin_src rust
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
#+end_src

/getters/ a method the same name as a field we want it to only return the value in the field and do nothing else.

[[https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword][public and private are and how to designate a field or method as public or private]]

*** Where’s the -> Operator?

C and C++
  ~.~  calling a method on the object directly
  ~->~ calling the method on a pointer to the object
  if =object= is a pointer
    =object->something()= equal to =(*object).something()=

Rust has a feature =automatic referencing and dereferencing=
  Calling methods is with this behavior.
  call a method with =object.something()=, Rust automatically adds in =&=, =&mut=, or =*=
  so =object= matches the signature of the method.

方法（method）有明确的接收者（receiver） —— 也就是 self 的类型。
在 Rust 中，当方法有 self 作为接收者时，编译器能清楚判断这个方法到底是：
  只读（&self）：方法只是借用当前对象，不会修改；
  可变（&mut self）：方法会可变借用，可能会修改对象；
  消费（self）：方法会获取所有权，调用后对象被拿走（move）。
正因为 Rust 能自动根据 self 的类型来推断是否借用、可变借用或是移动，所以方法调用时不需要手动写引用或解引用，这些繁琐的操作都被编译器处理掉了。
这种设计让 Rust 的所有权和借用系统在实际编程中更加易用和优雅，不会让程序员被繁杂的语法细节困扰。

*** Methods with More Parameters

#+begin_src rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
#+end_src

=&self= is actually short for =self: &Self=
  =Self= is an alias for the type that the =impl= block is for

*** Associated Functions

All functions defined within an =impl= block
because they’re associated with the type named after the =impl=

=We can define associated functions that don’t have ~self~ as their first parameter (and thus are not methods) because they don’t need an instance of the type to work with.=
有点像静态函数 不需要self 只限定作用的类型

eg: ~String::from~

often used for =constructors= that will =return a new instance= of the struct.

#+begin_src rust
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
#+end_src

=Self= are aliases for the type that appears after the =impl= keyword

=::= syntax with the struct name to call this associated function

=::= syntax is used for both =associated functions= and =namespaces= created by modules.

*** Multiple impl Blocks

Each struct is allowed to have multiple =impl= blocks.

#+begin_src rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
#+end_src

see a case in which =multiple impl= blocks are useful in Chapter 10, where we discuss =generic types and traits.=

** Summary

=structs aren’t the only way you can create custom types: Rust’s enum=

* Chapter 6 enums, match expressions, and the if let control flow constructs

=enumerations=, =Option= a particularly useful enum, =pattern matching= run different code for different values of an enum

** Defining an Enum

=enums give you a way of saying a value is one of a possible set of values=

#+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}
#+end_src

IpAddrKind is now a =custom data type= that we can use elsewhere in our code.

*** Enum Values

create instances

#+begin_src rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
#+end_src

the same type: =IpAddrKind=

~fn route(ip_kind: IpAddrKind) {}~

#+begin_src rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
#+end_src

#+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
#+end_src

=However, representing the same concept using just an enum is more concise:=
=rather than an enum inside a struct, we can put data directly into each enum variant.=
Better!!!

#+begin_src rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

=no need for an extra struct=

=the name of each enum variant that we define also becomes a function that constructs an instance of the enum=
  automatically get this constructor function defined as a result of defining the enum

=each variant can have different types and amounts of associated data.=
  we wouldn’t be able to with a struct. Enums handle this case with ease

#+begin_src rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

[[https://doc.rust-lang.org/std/net/enum.IpAddr.html][the standard library has a definition we can use!]]

#+begin_src rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#+end_src

you can put any kind of data inside an =enum variant: strings, numeric types, or struct, even another enum=

#+begin_src rust
enum Message {
    Quit,                        // Quit has no data associated with it at all.
    Move { x: i32, y: i32 },     // Move has named fields, like a struct does.
    Write(String),               // Write includes a single String.
    ChangeColor(i32, i32, i32),  // ChangeColor includes three i32 values.
}
#+end_src

=比下面的方式好=
=感觉{}后面就没有;, 空或者()后面就有;=

#+begin_src rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
#+end_src

if we used the different structs, each of which has its own type, we couldn’t as easily define a function to take any of these kinds of messages as we could with the Message enum defined, which is a single type.

just as we’re able to define methods on structs using =impl=
able to define methods on =enums=
=这就感觉enums 是相同类型的struct "加强版"=

#+begin_src rust
impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
#+end_src

*** The Option Enum and Its Advantages Over Null Values

a value could be something or it could be nothing

在 Rust（或者其他有类似类型系统的语言）中，你不能随便“相信”某个操作一定会返回一个值。你得用 Option（可能有/没有）这种类型去处理，让编译器帮你把所有可能的情况都考虑进去。

这样做虽然写起来稍微繁琐一点，但能让程序更健壮、更不容易出错。

variables: =null or not-null=

#+begin_src rust
enum Option<T> {
    None,
    Some(T),
}
#+end_src

=Its variants are also included in the prelude=
use =Some= and =None= directly without the =Option::= prefix

=<T>= a generic type parameter

#+begin_src rust
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
#+end_src

=the compiler can’t infer the type that the corresponding Some variant will hold by looking only at a None value.=
语法要求更具编译器的能力来说 比如:None 无法推断出是什么类型 所以需要显示T

So why is having =Option<T>= any better than having null?

In short, because =Option<T> and T (where T can be any type) are different types=,
the compiler =won’t let us use an Option<T> value as if it were definitely a valid value.=

#+begin_src rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y; //Error!!! different type
#+end_src

Rust doesn’t understand how to add an =i8= and an =Option<i8>=, because they’re different types.

Everywhere that a value has a type that isn’t an =Option<T>=, =you can safely assume that the value isn’t null.=

how do you get the =T= value out of a =Some= variant when you have a value of type =Option<T>=?
  =Option<T>= enum has a large number of methods
  [[https://doc.rust-lang.org/std/option/enum.Option.html][document]]

=match= will run different code depending on which variant of the enum it has

** The match Control Flow Construct

Patterns can be made up of =literal values=, =variable names=, =wildcards=, and =many other things=;

#+begin_src rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
#+end_src

=感觉{}后面就没有;, 空或者()后面就有;=

=if=, the condition needs to evaluate to a =Boolean value=, but here it =can be any type=.

#+begin_src rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
#+end_src

=use curly brackets, and the comma following the arm is then optional.=
=感觉{}后面就没有;, 空或者()后面就有;=

*** Patterns That Bind to Values

From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side.

#+begin_src rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {state:?}!");
            25
        }
    }
}
#+end_src

[[*Adding Useful Functionality with Derived Traits]]

*** Matching with Option<T>

#+begin_src rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#+end_src

=match= against an =enum=, bind a variable to the data inside, and then execute code based on it.

*** Matches Are Exhaustive

=the arms’ patterns must cover all possibilities.=

#+begin_src rust
  fn plus_one(x: Option<i32>) -> Option<i32> {
      match x {
  	//Error, didn’t handle the None case
          Some(i) => Some(i + 1), 
      }
  }
#+end_src

*** Catch-all Patterns and the _ Placeholder

#+begin_src rust
  let dice_roll = 9;
  match dice_roll {
      3 => add_fancy_hat(),
      7 => remove_fancy_hat(),
      other => move_player(other), //covers every other possible value
                                   //have to put the catch-all arm last
  }

  fn add_fancy_hat() {}
  fn remove_fancy_hat() {}
  fn move_player(num_spaces: u8) {}
#+end_src

~_~ =a special pattern that matches any value and does not bind to that value.=

#+begin_src rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
#+end_src

unit value (the =empty tuple type= we mentioned in [[https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type][“The Tuple Type”]])

#+begin_src rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => (),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
#+end_src

** Concise Control Flow with if let and let else

add : ~while let~ [[*Counting Up on Two Tasks Using Message Passing]]

=a less verbose= way to handle values that match one pattern while =ignoring the rest.=

#+begin_src rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {max}"),
    _ => (), //unit value!!! 注意这个用法
}
#+end_src

unit value (the =empty tuple type= we mentioned in [[https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type][“The Tuple Type”]])

#+begin_src rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {max}");
}
#+end_src

works the same way as a =match=

only runs if the value =matches the pattern.=

=syntax sugar= for a =match= that runs code when the value =matches one pattern and then ignores all other values.=

#+begin_src rust
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("State quarter from {state:?}!"),
    _ => count += 1,
}

// equal

let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {state:?}!");
} else {
    count += 1;
}
#+end_src

*** Staying on the “happy path” with let else

perform some computation when a value is present and return a default value otherwise.

#+begin_src rust
impl UsState {
    fn existed_in(&self, year: u16) -> bool {
        match self {
            UsState::Alabama => year >= 1819,
            UsState::Alaska => year >= 1959,
            // -- snip --
        }
    }
}

fn describe_state_quarter(coin: Coin) -> Option<String> {
    if let Coin::Quarter(state) = coin {
        if state.existed_in(1900) {
            Some(format!("{state:?} is pretty old, for America!"))
        } else {
            Some(format!("{state:?} is relatively new."))
        }
    } else {
        None
    }
}
#+end_src

[[*Method Syntax]]

That gets the job done, but it =has pushed the work into the body of the if let statement, and if the work to be done is more complicated, it might be hard to follow exactly how the top-level branches relate.=

=take advantage of the fact that expressions produce a value=

#+begin_src rust
fn describe_state_quarter(coin: Coin) -> Option<String> {
    let state = if let Coin::Quarter(state) = coin {
        state
    } else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} is pretty old, for America!"))
    } else {
        Some(format!("{state:?} is relatively new."))
    }
}
#+end_src

=let else=
  If the pattern =matches=, it will bind the value from the pattern =in the outer scope.!!!=
  If the pattern =does not match=, the program will flow into the =else arm=, which must =return from the function.=
  =else 分支必须使用return=

#+begin_src rust
fn describe_state_quarter(coin: Coin) -> Option<String> {
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} is pretty old, for America!"))
    } else {
        Some(format!("{state:?} is relatively new."))
    }
}
#+end_src

** Summary

=match=
=if let=
=let else=

* Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).

A package
  =multiple binary crates=
  =optionally one library crate=

=extract parts into separate crates that become external dependencies=

Cargo provides [[https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html][workspaces]]

scope
  can’t have two items with the same name in the same scop

=Crates=
  A tree of modules that produces a =library or executable=

=Packages=: A Cargo feature that lets you build, test, and share crates
=Crates=: A tree of modules that produces a library or executable
=Modules= and use: Let you control the organization, scope, and privacy of paths
=Paths=: A way of naming an item, such as a struct, function, or module  
 
** Packages and Crates

=crate= the smallest amount of code that the Rust compiler considers at a time.
  ~cargo~ or ~rustc~
  two forms: =a binary crate= or a =library crate=.
             have ~main~           don't have ~main~

/crate root/  is a source file that the Rust compiler starts from and makes up the root module of your crate
              [[https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html][“Defining Modules to Control Scope and Privacy”]]

=package=
  one or more crates
  contains a =Cargo.toml=
  can contain =as many binary crates= as you like, but at most only =one library crate.=
  must contain =at least one crate=, whether that’s a library or binary crate.

~cargo new my-prohject~
my-project
├── Cargo.toml
└── src
    └── main.rs

=src/main.rs= is the =crate root of a binary crate= with the =same name as the package.=

=src/lib.rs=  is the =crate root of a package crate= with the =same name as the package.=

If a package contains =src/main.rs and src/lib.rs=, it has two crates: =a binary and a library, both with the same name as the package.=

=can have multiple binary crates= in =src/bin=

** Defining Modules to Control Scope and Privacy

=Paths=: A way of naming an item, such as a struct, function, or module

=use= keyword that =brings a path into scope;=

=pub= make items public.

=as=

=external packages=,

the =glob operator.=

*** Modules Cheat Sheet

=Start from the crate root=
  compiling a crate, the compiler first looks in the =crate root file=
  (usually =src/lib.rs= for a library crate or =src/main.rs= for a binary crate)

=Declaring modules=
    In the =crate root file=, you can =declare new modules;=
    =mod module_name;=
    module’s code:
      =1.Inline= ~mod model_name {}~
      =2.src/model_name.rs=
      =3.src/model_name/mod.rs=

=Declaring submodules=
   The compiler will look for the =submodule’s code= within the =directory named for the parent module= in these places:
     =1.Inline= ~mod submodule_name{}~
     =2.src/model_name/submodule_name=
     =3.src/model_name/submodule_name/mod.rs=

=Paths to code in modules=
   Once a module is part of your crate
   refer to code in that module from anywhere else in that same crate

   eg:an Asparagus type in the garden vegetables module would be found at crate::garden::vegetables::Asparagus.

=Private vs. public=
   a module is private from its parent modules by default. 
   =mod= and =pub mod=
   =pub= before their declarations to make items within a public module public as well
   mod 和 里面的item 默认私有 如果要暴露出来 使用pub

=use=
   cpp 中 using

backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs

src/main.rs
#+begin_src rust
use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {plant:?}!");
}
#+end_src

the entire module tree is =rooted under the implicit module named crate.=

src/garden.rs
#+begin_src rust
pub mod vegetables;
#+end_src

means the code in src/garden/vegetables.rs is included too.

src/garden/vegetables.rs
#+begin_src rust
#[derive(Debug)]
pub struct Asparagus {}
#+end_src

[[*Adding Useful Functionality with Derived Traits]]

*** Grouping Related Code in Modules

=Modules= let us organize code within a =crate= for readability and easy reuse.

code within a module is =private by default.=

=Create a new library=
  ~cargo new module --lib~
  edit =src/lib.rs=

src/lib.rs
#+begin_src rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
#+end_src

Modules can also hold definitions for =other items, such as structs, enums, constants, traits, and functions.=

=crate roots=
  =src/main.rs= and =src/lib.rs=
  the contents of either of these two files =form a module named crate at the root of the crate’s module structure=

crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment

=This tree shows how some of the modules nest inside other modules;=

If module A is contained inside module B, we say that module A is the child of module B and that module B is the parent of module A.

the entire module tree is =rooted under the implicit module named crate.=

this is a very apt comparison!

just like files in a directory, we need a way to find our modules.

** Paths for Referring to an Item in the Module Tree

=Paths=: A way of naming an item, such as a struct, function, or module

show Rust where to find an item in a module tree
  =other items, such as structs, enums, constants, traits, and functions.=

=use a path in the same way we use a path when navigating a filesystem=

two forms:
  =1.An absolute path=
    the entire module tree is =rooted under the implicit module named crate.=
    current crate : ~crate::...~
    external crate : ~external_crate_name::~
  =2.A relative path=
    =Modules= let us organize code within a =crate= for readability and easy reuse.
    starts from the current module
    uses =self=, =super=, or =an identifier= in the current module.
 
#+begin_src rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() { //public API, so we mark it with the pub keyword.
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path, 想想文件系统
    front_of_house::hosting::add_to_waitlist();
}
#+end_src

the entire module tree is =rooted under the implicit module named crate.=

[[https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword][“Exposing Paths with the pub Keyword”]]

=You can imagine a filesystem with the same structure=

Our preference in general is to specify absolute paths because it’s more likely we’ll want to move code definitions and item calls independently of each other.

=In Rust, all items (functions, methods, structs, enums, modules, and constants) are private to parent modules by default.=

=but items in child modules can use the items in their ancestor modules.=

Rust chose to have the module system function this way so that hiding inner implementation details is the default. 

=pub= keyword to make an item public.

*** Exposing Paths with the pub Keyword

#+begin_src rust
mod front_of_house {
    pub mod hosting { //The pub keyword on a module only lets code in its ancestor modules refer to it, not access its inner code.
        fn add_to_waitlist() {} 
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
#+end_src

The pub keyword on a module only lets code in its ancestor modules refer to it, not access its inner code.

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
#+end_src

In the absolute path
  =crate=, the root of our crate’s module tree.
  =front_of_house isn't public=
    =eat_at_restaurant function is defined in the same module as front_of_house (that is, eat_at_restaurant and front_of_house are siblings), we can refer to front_of_house from eat_at_restaurant.=
    =因为 eat_at_restaurant 和 mod front_of_house 是 siblings 关系 所以可以直接调用=
    =同时 子module 可以调用 祖先module 所有 item=
    =other items, such as structs, enums, constants, traits, and functions.=
    =默认子module 对 祖先module 是private 除非加pub=

[[https://rust-lang.github.io/api-guidelines/][The Rust API Guidelines]]

*** Best Practices for Packages with a Binary and a Library

a package can contain both a =src/main.rs= binary crate root as well as a =src/lib.rs= library crate root, and both crates will have the package name by default.

=a binary crate will have just enough code in the binary crate to start an executable that calls code within the library crate.=

=The binary crate becomes a user of the library crate=

can only use the public API.

*** Starting Relative Paths with super

like starting a filesystem path with the ~..~ syntax.

=super= allows us to reference an item in the parent module
    =因为 eat_at_restaurant 和 mod front_of_house 是 siblings 关系 所以可以直接调用=
    =同时 子module 可以调用 祖先module 所有 item=
    =other items, such as structs, enums, constants, traits, and functions.=
    =默认子module 对 祖先module 是private 除非加pub=

#+begin_src rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
#+end_src

*** Making Structs and Enums Public

=other items, such as structs, enums, constants, traits, and functions.=

=pub= to designate structs and enums as public

=pub= before a struct definition, we make the struct public, but the struct’s fields will still be private.

#+begin_src rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
#+end_src

if we make an enum public, all of its variants are then public.

#+begin_src rust
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
#+end_src

Enums aren’t very useful unless their variants are public;

=the default for enum variants is to be public.=

=Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with pub.=

** Bringing Paths into Scope with the use Keyword

we can create a shortcut to a =path= with the =use= keyword

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+end_src

=similar to creating a symbolic link in the filesystem.=

only creates the shortcut for the =particular scope in which the use occurs.=


#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist(); //Error!!!a different scope than the use statement, so the function body won’t compile.
    }
}
#+end_src

To fix this problem
  move the use within the customer module
  or reference the shortcut in the parent module with super::hosting within the child customer module.
  [[*Starting Relative Paths with super]]

*** Creating Idiomatic use Paths

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
#+end_src

not the idiomatic way to bring a function into scope with use

=Specifying the parent module when calling the function makes it clear that the function isn’t locally defined while still minimizing repetition of the full path.=

=when bringing in structs, enums, and other items with use, it’s idiomatic to specify the full path.=

#+begin_src rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
#+end_src

=There’s no strong reason behind this idiom: it’s just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way.=

 if we’re bringing two items with the same name into scope with use statements, because Rust doesn’t allow that.

=how to bring two Result types into scope that have the same name but different parent modules, and how to refer to them.=

#+begin_src rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
}

fn function2() -> io::Result<()> {
    // --snip--
}
#+end_src

If instead we specified use std::fmt::Result and use std::io::Result, we’d have two Result types in the same scope, and Rust wouldn’t know which one we meant when we used Result.

有点类似cpp的命名空间

*** Providing New Names with the as Keyword

起别名非常重要 对于代码的维护来说！！！
c/cpp 中的 typedef，using

#+begin_src rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
}

fn function2() -> IoResult<()> {
    // --snip--
}
#+end_src

*** Re-exporting Names with pub use

=When we bring a name into scope with the use keyword, the name available in the new scope is private.=

=re-exporting=
  bringing an item into scope but also making that item available for others to bring into their scope.

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+end_src


external code would have to call the add_to_waitlist function
  before path: ~restaurant::front_of_house::hosting::add_to_waitlist()~
  after =re-exporting= path: ~restaurant::hosting::add_to_waitlist()~

=Re-exporting is useful when the internal structure of your code is different from how programmers calling your code would think about the domain.=

=With pub use, we can write our code with one structure but expose a different structure.=

Doing so makes our library well organized for programmers working on the library and programmers calling the library.

[[https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use][“Exporting a Convenient Public API with pub use”]]

*** Using External Packages

=1.add in Cargo.toml=
  [[https://crates.io/][creates.io]]
=2.use XXX::XXX=

the standard std library is also a crate that’s external to our package.
the standard library is shipped with the Rust language, we don’t need to change Cargo.toml to include std.
need to refer to it with use to bring items from there into our package’s scope.

=3.cargo build=
  [[*=a crate is a collection of Rust source code files=]]
  
*** Using Nested Paths to Clean Up Large use Lists

#+begin_src rust
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
#+end_src

to

#+begin_src rust
// --snip--
use std::{cmp::Ordering, io};
// --snip--
#+end_src

#+begin_src rust
use std::io;
use std::io::Write;
#+end_src

to

#+begin_src rust
use std::io::{self, Write};
#+end_src

*** The Glob Operator

bring all public items

#+begin_src rust
use std::collections::*;
#+end_src

=The glob operator is often used when testing to bring everything under test into the tests module;=

[[https://doc.rust-lang.org/book/ch11-01-writing-tests.html#how-to-write-tests][“How to Write Tests”]]

** Separating Modules into Different Files

src/lib.rs
#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+end_src

to

src/lib.rs
#+begin_src rust
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+end_src

src/front_of_house.rs
#+begin_src rust
pub mod hosting {
    pub fn add_to_waitlist() {}
}
#+end_src
[[*Modules Cheat Sheet]]
[[*Re-exporting Names with pub use]]

The compiler knows to look in this file because it came across the module declaration in the crate root with the name front_of_house.

=you only need to load a file using a mod declaration once in your module tree.=

Once the compiler knows the file is part of the project (and knows where in the module tree the code resides because of where you’ve put the mod statement),
=other files in your project should refer to the loaded file’s code using a path to where it was declared,=
as covered in the [[*Paths for Referring to an Item in the Module Tree]] section.

=mod is not an “include” operation that you may have seen in other programming languages.=


to

src/front_of_house.rs
#+begin_src rust
pub mod hosting;
#+end_src

src/front_of_house/hosting.rs
#+begin_src rust
pub fn add_to_waitlist() {}
#+end_src

[[*Modules Cheat Sheet]]

=use a path in the same way we use a path when navigating a filesystem=

*** Alternate File Paths

For a module named front_of_house declared in the crate root, the compiler will look for the module’s code in:

src/front_of_house.rs (what we covered)
src/front_of_house/mod.rs (older style, still supported path)

For a module named hosting that is a submodule of front_of_house, the compiler will look for the module’s code in:

src/front_of_house/hosting.rs (what we covered)
src/front_of_house/hosting/mod.rs (older style, still supported path)

[[*Modules Cheat Sheet]]

=use both styles for the same module, you’ll get a compiler error.=

** Summary

Rust lets you split a package into multiple crates

split a crate into modules so you can refer to items defined in one module from another module.

package -> multiple crates -> multiple modules -> multiple items
  =other items, such as structs, enums, constants, traits, and functions.=

specifying absolute or relative paths.
  [[*Paths for Referring to an Item in the Module Tree]]

=use=

=as=

=pub=
  Module code is private by default, but you can make definitions public by adding the pub keyword.

* CHAPTER 8 common collection data structures that the standard library provides, such as vectors, strings, and hash maps.

the data stored =on the heap=

=vector=

=string=

=hash map=

** Storing Lists of Values with Vectors

can only store values of the =same type=

*** Creating a New Vector

~let v: Vec<i32> = Vec::new();~

=using generics;=

or

=vec! macro=

~let v = vec![1, 2, 3];~

*** Updating a Vector

#+begin_src rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#+end_src

*** Reading Elements of Vectors

via =indexing= or by using the =get= method.

#+begin_src rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {third}");

let third: Option<&i32> = v.get(2); //Option<&T>
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}

let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];  // panic, it references a nonexistent element
let does_not_exist = v.get(100);  // None without panicking
#+end_src

when has a valid reference,
the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this =reference and any other references to the contents of the vector remain valid.=

#+begin_src rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {first}");
#+end_src

[[*References and Borrowing]]

This error is due to the way vectors work: because vectors put the values next to each other in memory, adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn’t enough room to put all the elements next to each other where the vector is currently stored.

[[https://doc.rust-lang.org/nomicon/vec/vec.html][“The Rustonomicon”]]
 
*** Iterating Over the Values in a Vector

#+begin_src rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}


let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
#+end_src

=*= dereference operator

[[https://doc.rust-lang.org/book/ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator][“Following the Pointer to the Value with the Dereference Operator”]]

*** Using an Enum to Store Multiple Types

#+begin_src rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
#+end_src

all the enum variants will be considered the same type: that of the enum.

Instead, you can use a =trait object=, which we’ll cover in Chapter 18.

[[https://doc.rust-lang.org/std/vec/struct.Vec.html][the API documentation]]

*** Dropping a Vector Drops Its Elements

#+begin_src rust
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v
} // <- v goes out of scope and is freed here
#+end_src

** Storing UTF-8 Encoded Text with Strings
*** What Is a String?

string slice =str=

=String literals, for example, are stored in the program’s binary and are therefore string slices.=

[[*The Slice Type a different kind of reference]]

The String type is a growable, mutable, owned, UTF-8 encoded string type. 

*** Creating a New String

String is actually implemented as a wrapper around a vector of bytes

~let mut s = String::new();~

=to_string= available on any type that implements the =Display trait=, as =string literals do.=

#+begin_src rust
let data = "initial contents";

let s = data.to_string();

// the method also works on a literal directly:
let s = "initial contents".to_string();
#+end_src

~let s = String::from("initial contents");~

#+begin_src rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שלום");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
#+end_src

*** Updating a String

=+= operator or the =format! macro= to concatenate String values.

**** Appending to a String with push_str and push

#+begin_src rust
    let mut s = String::from("foo");
    s.push_str("bar");
#+end_src

=The push_str method takes a string slice because we don’t necessarily want to take ownership of the parameter.=
[[*The Slice Type a different kind of reference]]

#+begin_src rust
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");
#+end_src

The push method takes =a single character= as a parameter and adds it to the String.

#+begin_src rust
    let mut s = String::from("lo");
    s.push('l');
#+end_src

**** Concatenation with the + Operator or the format! Macro

#+begin_src rust
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
#+end_src

=s1 is no longer valid after the addition=
=the reason we used a reference to s2, has to do with the signature of the method that’s called when we use the + operator.=

=The + operator uses the add method=
~fn add(self, s: &str) -> String {~

In the standard library, =add= defined using =generics= and =associated types.=
[[*Associated Functions]]

=s2 has an &, meaning that we’re adding a reference of the second string to the first string.=
=s parameter in the add function: we can only add a &str to a String;=
we can’t add two String values together.

=the type of &s2 is &String, not &str, as specified in the second parameter to add. So why does it compile?=
[[*The Slice Type a different kind of reference]]
[[*String Slices as Parameters]]
the compiler can coerce the &String argument into a &str.
=a deref coercion=

=add takes ownership of self because self does not have an &.=
=s1 will be moved into the add call and will no longer be valid after that.=

~let s3 = s1 + &s2;~
  =takes ownership of s1, appends a copy of the contents of s2, and then returns ownership of the result.=

#+begin_src rust
  let s1 = String::from("tic");
  let s2 = String::from("tac");
  let s3 = String::from("toe");

  let s = s1 + "-" + &s2 + "-" + &s3;
#+end_src

=format! marco=

#+begin_src rust
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
#+end_src

=the code generated by the format! macro uses references=
so that this call =doesn’t take ownership of any of its parameters.=

**** Indexing into Strings

if you try to access parts of a String using indexing syntax in Rust, you’ll get =an error.=

#+begin_src rust
    let s1 = String::from("hello");
    let h = s1[0];
#+end_src

=Rust strings don’t support indexing.=
But why not? To answer that question, we need to discuss how Rust stores strings in memory.

**** Internal Representation

=A String is a wrapper over a Vec<u8>.=

#+begin_src rust
  let hello = String::from("Hola"); // 4 bytes long

  let hello = String::from("Здравствуйте"); // 24 bytes long
#+end_src

the number of bytes it takes to encode “Здравствуйте” in UTF-8
each Unicode scalar value in that string takes 2 bytes of storage. 
[[*Shadowing]]

=Therefore, an index into the string’s bytes will not always correlate to a valid Unicode scalar value.=

#+begin_src rust
let hello = "Здравствуйте";
let answer = &hello[0];
#+end_src

When encoded in UTF-8, the first byte of З is 208 and the second is 151,
so it would seem that answer should in fact be 208,
=but 208 is not a valid character on its own.=

这里GO是通过[]rune来解决
go.org *Fix the invalid string error

Users generally don’t want the byte value returned, even if the string =contains only Latin letters:=
if &"hi"[0] were valid code that =returned the byte value, it would return 104, not h.=

**** Bytes and Scalar Values and Grapheme Clusters! Oh My!

Another point about UTF-8 is three relevant ways to look at strings from Rust’s perspective: as =bytes, scalar values, and grapheme clusters.=

look at the Hindi word “नमस्ते” written in the Devanagari script,

stored as a vector of u8 values
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
=18 bytes and is how computers ultimately store this data.=

as Unicode scalar values, which are what =Rust’s char type= is
['न', 'म', 'स', '्', 'त', 'े']
six char values here, but the fourth and sixth are not letters: they’re diacritics that don’t make sense on their own.

as grapheme clusters, we’d get what a person would call the four letters that make up the Hindi word:
["न", "म", "स्", "ते"]

=Rust provides different ways of interpreting the raw string data=

A final reason Rust doesn’t allow us to index into a String to get a character is that indexing operations are expected to always take constant time (O(1)).
But it isn’t possible to guarantee that performance with a String, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.

=Rust 区分字节（byte）、字符（char）、字符簇（grapheme cluster），并设计 String 时不允许用索引访问，是出于 性能一致性 + Unicode 正确性 的考虑。=

**** Slicing Strings

Indexing into a string is often a bad idea
=because it’s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice.=

use [] with a range to create a string slice
[[*The Slice Type a different kind of reference]]

#+begin_src rust
let hello = "Здравствуйте";

let s = &hello[0..4];
#+end_src

the number of bytes it takes to encode “Здравствуйте” in UTF-8
each Unicode scalar value in that string takes 2 bytes of storage.
means s will be Зд.

=If we were to try to slice only part of a character’s bytes with something like &hello[0..1]=
=Rust would panic at runtime in the same way as if an invalid index were accessed in a vector=

**** Methods for Iterating Over Strings

=The best way to operate on pieces of strings is to be explicit about whether you want characters or bytes.=

=For individual Unicode scalar values, use the chars method.=
#+begin_src rust
for c in "Зд".chars() {
    println!("{c}");
}
#+end_src

=the bytes method returns each raw byte=
#+begin_src rust
for b in "Зд".bytes() {
    println!("{b}");
}
#+end_src

=Getting grapheme clusters from strings=, as with the Devanagari script, =is complex, so this functionality is not provided by the standard library.=

Crates are available on [[https://crates.io/][crates.io]] if this is the functionality you need.

**** Strings Are Not So Simple

The good news is that the standard library offers a lot of functionality built off the String and &str types to help handle these complex situations correctly.

Be sure to check out the documentation for useful methods like =contains= for searching in a string and =replace= for substituting parts of a string with another string.

** Storing Keys with Associated Values in Hash Maps

The type HashMap<K, V> stores a mapping of keys of type K to values of type V
=using a hashing function, which determines how it places these keys and values into memory.=

Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type.

many more goodies are hiding in the functions defined on HashMap<K, V> by the standard library.
check the standard library documentation for more information.

*** Creating a New Hash Map

use =new= and to add elements with =insert.=

#+begin_src rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
#+end_src


it’s not included in the features brought into scope automatically in the prelude.
need to first use the HashMap from the collections portion of the standard library.
there’s no built-in macro to construct them.

=Just like vectors, hash maps store their data on the heap.=

Like vectors, hash maps are homogeneous: =all of the keys must have the same type, and all of the values must have the same type.=

[[*Using an Enum to Store Multiple Types]]

*** Accessing Values in a Hash Map

#+begin_src rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&team_name).copied().unwrap_or(0);
#+end_src

=get= method returns an =Option<&V>;=
   if there’s no value for that key in the hash map, get will return None.
calling =copied= to get an =Option<i32> rather than an Option<&i32>,=
=unwrap_or= to set score to zero if scores doesn’t have an entry for the key.

iterate over each key–value pair in a hash map in a similar manner as we do with vectors, using a for loop:

#+begin_src rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    for (key, value) in &scores {
        println!("{key}: {value}");
    }
#+end_src

*** Hash Maps and Ownership

For =types that implement the Copy trait=, like i32, =the values are copied into the hash map.=

For owned values like =String=, the values will be =moved= and the =hash map will be the owner= of those values

#+begin_src rust
    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
#+end_src

We aren’t able to use the variables field_name and field_value after they’ve been moved into the hash map with the call to insert.

If we insert references to values into the hash map, the values won’t be moved into the hash map.
=The values that the references point to must be valid for at least as long as the hash map is valid.=

[[https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes][“Validating References with Lifetimes”]]

*** Updating a Hash Map
**** Overwriting a Value

#+begin_src rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{scores:?}");
#+end_src

[[*Adding Useful Functionality with Derived Traits]]

**** Adding a Key and Value Only If a Key Isn’t Present

if the key does exist in the hash map, the existing value should remain the way it is;
if the key doesn’t exist, insert it and a value for it.

=entry=
The return value of the entry method is an enum called =Entry= that represents a value that might or might not exist.
The =or_insert= method on =Entry= is defined to return a =mutable reference= to the value for the corresponding Entry key if that key exists,
  if not, it inserts the parameter as the new value for this key and returns a =mutable reference to the new value.=

#+begin_src rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    println!("{scores:?}");
#+end_src

**** Updating a Value Based on the Old Value

#+begin_src rust
    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
#+end_src

You might see the same key–value pairs printed in a different order

[[https://doc.rust-lang.org/book/ch08-03-hash-maps.html#accessing-values-in-a-hash-map][“Accessing Values in a Hash Map”]] iterating over a hash map happens in an arbitrary order.

=split_whitespace= method returns an =iterator= over subslices, separated by whitespace, of the value in text.

=or_insert= method returns a =mutable reference (&mut V)= to the value for the specified key.

=dereference= count using the =asterisk (*)=

**** Hashing Functions

=HashMap= uses a hashing function called =SipHash= that can provide resistance to denial-of-service (DoS) attacks involving =hash tables.=
https://en.wikipedia.org/wiki/SipHash

=you can switch to another function by specifying a different hasher.=

=A hasher is a type that implements the BuildHasher trait.=

[[https://crates.io/][crates.io]] has libraries shared by other Rust users that provide hashers implementing many common hashing algorithms.

* CHAPTER 9 Rust’s error-handling philosophy and techniques.

Rust groups errors into two major categories: =recoverable= and =unrecoverable= errors.

Rust doesn’t have exceptions.

it has the type =Result<T, E> for recoverable errors= and the =panic! macro= that stops execution when the program encounters =an unrecoverable error.=
[[*=Handling Potential Failure with Result=]]

** Unrecoverable Errors with panic!

 two ways to cause a panic in practice:
   1.taking an action that causes our code to panic : such as accessing an array past the end
   2.explicitly calling the panic! macro.

 =Unwinding the Stack or Aborting in Response to a Panic=
   Rust, therefore, allows you to choose the alternative of immediately aborting, which ends the program without cleaning up.
   =If in your project you need to make the resultant binary as small as possible, you can switch from unwinding to aborting upon a panic by adding panic = 'abort' to the appropriate [profile] sections in your Cargo.toml file.=
   Cargo.toml
   #+begin_src toml
   [profile.release]
   panic = 'abort'
   #+end_src

   main.rs
   #+begin_src rust
fn main() {
    panic!("crash and burn");
}
   #+end_src

   ~cargo run~

   ➜  example git:(master) ✗ cargo run        
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.70s
     Running `target/debug/example`

  thread 'main' panicked at src/main.rs:2:5:
  crash and burn!!!
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

  main.rs
  #+begin_src rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
  #+end_src

  =In C, attempting to read beyond the end of a data structure is undefined behavior.=

  =buffer overread=

  To protect your program from this sort of vulnerability, if you try to read an element at an index that doesn’t exist, Rust will stop execution and refuse to continue.

  ~cargo run~
  ➜  example git:(master) ✗ cargo run 
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.03s
     Running `target/debug/example`

  thread 'main' panicked at src/main.rs:4:6:
  index out of bounds: the len is 3 but the index is 99
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

  ~RUST_BACKTRACE=1 cargo run~
  ➜  example git:(master) ✗ RUST_BACKTRACE=1 cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/example`

thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/std/src/panicking.rs:692:5
   1: core::panicking::panic_fmt
             at /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/panicking.rs:75:14
   2: core::panicking::panic_bounds_check
             at /rustc/4eb161250e340c8f48f66e2b929ef4a5bed7c181/library/core/src/panicking.rs:273:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /Users/jieman/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/slice/index.rs:274:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /Users/jieman/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/slice/index.rs:16:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /Users/jieman/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3361:9
   6: example::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at /Users/jieman/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.

=Backtraces in Rust work as they do in other languages: the key to reading the backtrace is to start from the top and read until you see files you wrote.=
The lines above that spot are code that your code has called; the lines below are code that called your code.

In order to get backtraces with this information, =debug symbols must be enabled.=
=Debug symbols are enabled by default when using cargo build or cargo run without the --release flag=, as we have here.

** Recoverable Errors with Result

[[*=Handling Potential Failure with Result=]]
[[*The match Control Flow Construct]]

Rust enum
#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src

The T and E are generic type parameters

Because Result has these generic type parameters, we can use the Result type and the functions defined on it in many different situations where the success value and error value we want to return may differ.

main.rs
#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {error:?}"),
    };
}
#+end_src

The return type of =File::open= is a =Result<T, E>.=
=T -- std::fs::File a file handle=
=E -- std::io::Error=

[[*Statements and Expressions]]

=like the Option enum, the Result enum and its variants have been brought into scope by the prelude=
so we don’t need to specify Result:: before the Ok and Err variants in the match arms.

➜  example git:(master) ✗ cargo run
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
warning: unused variable: `greeting_file`
 --> src/main.rs:6:9
  |
6 |     let greeting_file = match greeting_file_result {
  |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_greeting_file`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: `example` (bin "example") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.53s
     Running `target/debug/example`

thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

*** Matching on Different Errors

#+begin_src rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file : {e:?}"),
            },
            other_error => {
                panic!("Problem opening the file : {other_error:?}");
            }
        },
    };
}
#+end_src

*** Alternatives to Using match with Result<T, E>

=closures=  which are used with many of the methods defined on Result<T, E>.

#+begin_src rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
}
#+end_src

=unwrap_or_else= method

*** Shortcuts for Panic on Error: unwrap and expect

Using =match= can be a bit verbose and doesn’t always communicate intent well.

The =Result<T, E>= type has many helper methods
  =unwrap= method is a shortcut method
    If the Result value is the Ok variant, =unwrap will return the value inside the Ok.=
    If the Result is the Err variant, =unwrap will call the panic! macro for us.=

#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
#+end_src

Using =expect= instead of =unwrap= and =providing good error messages= can convey your intent and make tracking down the source of a panic easier.

#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
#+end_src

use =expect= in the same way as =unwrap=: to return the file handle or call the panic! macro.

=In production-quality code, most Rustaceans choose expect rather than unwrap= and give more context about why the operation is expected to always succeed.

*** Propagating Errors

=return the error to the calling code so that it can decide what to do.=

#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
#+end_src

[[*Using Nested Paths to Clean Up Large use Lists]]
[[*The match Control Flow Construct]]
[[*Statements and Expressions]]
[[*Using an Enum to Store Multiple Types]]

=This pattern of propagating errors is so common in Rust that Rust provides the question mark operator ? to make this easier.=

*** A Shortcut for Propagating Errors: the ? Operator

shows an implementation of read_username_from_file that has the same functionality as above

=? operator=

#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
#+end_src

The =?= placed after a =Result value= is defined to work in almost the same way as the =match expressions= we defined to handle the Result values

If the value of the Result is an =Ok=, the value inside the =Ok= will get returned from this expression, and the program will =continue.=
If the value is an =Err=, the Err will be =returned= from the whole function as if we had used the =return keyword= so the error value gets propagated to the calling code.

error values that have the =? operator= called on them go through =the from function,=
=defined in the From trait= in the standard library,
which is used to convert values from one type into another.

=When the ? operator calls the from function, the error type received is converted into the error type defined in the return type of the current function.=
  For example, we could change the =read_username_from_file= function aboved to return a custom error type named =OurError= that we define.
  If we also define =impl From<io::Error>= for =OurError= to construct an instance of =OurError from an io::Error,=
  then the =? operator= calls in the body of =read_username_from_file= will call =from= and convert the error types without needing to add any more code to the function.

[[*Statements and Expressions]]

The =? operator= eliminates a lot of boilerplate and makes this function’s implementation simpler.

could =even shorten this code further by chaining method calls= immediately after the =?=

#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
#+end_src

a way to make this even shorter using fs::read_to_string

#+begin_src rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
#+end_src

=fs::read_to_string= function that opens the file, creates a new String, reads the contents of the file, puts the contents into that String, and returns it.

*** Where The ? Operator Can Be Used

=The ? operator can only be used in functions whose return type is compatible with the value the ? is used on.=

This is because the ? operator is defined to perform an early return of a value out of the function

if we use the ? operator in a main function with a return type that is incompatible with the type of the value we use ? on.
ERROR!!!
#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}
#+end_src

➜  example git:(master) ✗ cargo run    
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --> src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`                                           
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`
help: consider adding return type
  |
3 ~ fn main() -> Result<(), Box<dyn std::error::Error>> {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `example` (bin "example") due to 1 previous error

=main function has the return type of (), not Result.=
[[*The Tuple Type]]
it’s the entry point and exit point of an executable program
=main can also return a Result<(), E>=
=The main function may return any types that implement the std::process::Termination trait,
 which contains a function report that returns an ExitCode.=

we’re only allowed to use the ? operator in a function that returns =Result, Option, or another type that implements FromResidual.=

To fix the error, you have two choices
  1.to change the return type of your function to be =compatible with the value you’re using the ? operator= on as long as you have no restrictions preventing that.
  2.use a =match or one of the Result<T, E> methods= to handle the =Result<T, E>= in whatever way is appropriate.

=? can be used with Option<T> values as well.=

if the value is None, the None will be returned early from the function at that point.
If the value is Some, the value inside the Some is the resultant value of the expression, and the function continues.

#+begin_src rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
#+end_src

是的，只有调用 next()，迭代器才会“产出”一个值。在 Rust 里，迭代器是惰性的（lazy），不会在你创建它的时候就立即处理数据。
当你通过 .lines() 创建迭代器的时候，它还没有“指向”任何具体的值，它只是一个结构体，记录了它要遍历的数据来源（比如字符串切片），以及当前遍历到哪里（还没开始，就是起点）。

=main can also return a Result<(), E>=
we’ve changed the return type of main to be Result<(), Box<dyn Error>> and added a return value Ok(()) to the end.

#+begin_src rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
#+end_src

The =Box<dyn Error> type= is a =trait object=
[[https://doc.rust-lang.org/book/ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types][“Using Trait Objects that Allow for Values of Different Types”]]

When a main function returns a Result<(), E>, the executable will exit with a value of 0 if main returns Ok(()) and will exit with a nonzero value if main returns an Err value.

=Executables written in C return integers when they exit:
programs that exit successfully return the integer 0, and programs that error return some integer other than 0.=

** To panic! or Not to panic!

当程序调用了 panic!，是无法恢复的中断。你可以对任何错误情况使用 panic!，无论这个错误是否可以恢复；
  但这样你就是替调用者做了一个决定：这个错误无法恢复。
如果你返回一个 Result，你就是把选择权交给了调用方：
  调用者可以选择如何恢复；
  也可以自己调用 panic!，将这个“可恢复的错误”变成“不可恢复的 panic”。

*** Examples, Prototype Code, and Tests

更适合使用 panic!

When you’re writing an example to illustrate some concept, also including robust error-handling code can make the example less clear.

Similarly, the =unwrap and expect methods= are very handy when prototyping, before you’re ready to decide how to handle errors.

*** Cases in Which You Have More Information Than the Compiler

有时候你有比编译器更多的信息 —— 你能保证不会出错，但编译器无法判断。
  比如某些操作返回 Result，但你知道在当前上下文中它永远不会失败；
  编译器还是会要求你处理 Result，这时你可以放心使用 unwrap 或 expect。

#+begin_src rust
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1"
    .parse()
    .expect("硬编码的 IP 地址应该是合法的");
#+end_src  

It would also be appropriate to call =unwrap or expect= when you have some other logic that ensures the Result will have an Ok value, but the logic isn’t something the compiler understands.

*** Guidelines for Error Handling

It’s advisable to have your code panic when it’s possible that your code could end up in a bad state.
a bad state is when some assumption, guarantee, contract, or invariant has been broken

如果别人调用你的库，并传入了无效值：
最好是返回一个 Result 错误，这样用户可以自己决定怎么处理；
但如果这个错误会造成 安全隐患或不可恢复的错误，那就应当调用 panic!，在开发阶段提醒用户：“你的代码有 bug，要修！”

什么时候该返回 Result 而不是 panic？
当 失败是可以预期的情况，应返回 Result，不要 panic。比如：
  一个解析器接收到不合法的数据；
  一个 HTTP 请求返回了“请求频率超限”；
  用户输入不对格式等；
这些情况是业务上允许失败的，而不是程序出 bug，返回 Result 是更好的选择，让调用者自己决定怎么处理。

为了安全，某些情况下你必须检查值是否合法
如果你的函数在收到非法值时继续执行，可能导致安全问题，那就要提前检查并 panic。比如：
  Rust 标准库在你数组越界访问时会 panic；
  因为访问不属于你的内存区域是严重安全漏洞；
  很多函数有“契约” —— 它们只有在满足某些前提时才保证行为正确。
所以，当调用者违反契约（contract），直接 panic 是合理的，因为这是调用者的 bug，不应该让调用者去“处理错误”，而是去修代码。

Rust 类型系统能帮你减少很多错误检查
频繁写错误检查会很啰嗦，但 Rust 的类型系统可以帮你在编译阶段提前验证很多事情：
  如果函数参数是一个具体类型，而不是 Option，你就能保证这个值一定存在；
  所以函数里就不需要再检查 None 的情况；
  如果有人传了 None，代码甚至都编译不过。
  再比如，用 u32 代替 i32，就能保证参数永远不会是负数。
这样你的函数逻辑就可以更加简洁、专注于“有效输入”的情况，不必重复防御性检查。

*** Creating Custom Types for Validation

take the idea of using Rust’s type system to ensure we have a valid value

#+begin_src rust
    loop {
        // --snip--

        let guess: i32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        if guess < 1 || guess > 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&secret_number) {
            // --snip--
    }
#+end_src

=having a check like this in every function would be tedious (and might impact performance).=

=we can make a new type and put the validations in a function to create an instance of the type rather than repeating the validations everywhere.=

#+begin_src rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {  // getter
        self.value
    }
}
#+end_src

[[*CHAPTER 5 structs and methods]]
[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]

* Chapter 10 generics, traits, and lifetimes, which give you the power to define code that applies to multiple types

Every programming language has tools for effectively handling the duplication of concepts.

Generic Types
  =Option<T>, Vec<T>, HashMap<K, V>, Result<T, E>=
  Generics : a placeholder that represents multiple types to remove code duplication.

traits
  =define behavior in a generic way=

lifetimes
  =a variety of generics that give the compiler information about how references relate to each other.=

** Removing Duplication by Extracting a Function

#+begin_src rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}  
#+end_src

[[*Where’s the -> Operator?]]
Rust has a feature =automatic referencing and dereferencing=
  Calling methods is with this behavior.
  call a method with =object.something()=, Rust automatically adds in =&=, =&mut=, or =*=
  so =object= matches the signature of the method.

[[*Shadowing]]

duplicating code is tedious and error prone.

create an abstraction by defining a function

#+begin_src rust
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {result}");
}
#+end_src

[[*Statements and Expressions]]

Identify duplicate code.
Extract the duplicate code into the body of the function, and specify the inputs and return values of that code in the function signature.
Update the two instances of duplicated code to call the function instead.

** Generic Data Types

create definitions for =items like function signatures or structs=, which we can then =use with many different concrete data types.=

*** In Function Definitions

To parameterize the types in a new single function, we need to name the type parameter
Rust’s type-naming convention is UpperCamelCase.
use a type parameter name in a function signature, we have to declare the type parameter name before we use it.
cpp会根据代码调用来在编译时期推断T的类型
<>和cpp一样
模版参数写在函数名和函数参数之间 和 Go一样
./go.org *Generics

#+begin_src rust
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {result}");
}
#+end_src

➜  example git:(master) ✗ cargo run
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
error[E0369]: binary operation `>` cannot be applied to type `&T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- &T
  |            |
  |            &T
  |
help: consider restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `example` (bin "example") due to 1 previous error

=To enable comparisons, the standard library has the std::cmp::PartialOrd trait that you can implement on types=

*** In Struct Definitions

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
#+end_src

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 }; // ERROR!!!
}
#+end_src

In this example, when we assign the integer value 5 to x, we let the compiler know that the generic type T will be an integer for this instance of Point<T>. Then when we specify 4.0 for y, which we’ve defined to have the same type as x, we’ll get a type mismatch error like this:

➜  example git:(master) ✗ cargo run
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `example` (bin "example") due to 1 previous error

=can use multiple generic type parameters=

#+begin_src rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
#+end_src

*** In Enum Definitions

#+begin_src rust
enum Option<T> {
    Some(T),
    None,
}
#+end_src

=use multiple generic types as well=

#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src

*** In Method Definitions

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
#+end_src

=注意方法中impl 和 名字 后都有<T>=

=通过在 impl 中声明泛型参数 T，Rust 才能识别出 Point 中尖括号里的类型是一个泛型类型，而不是具体类型。=

=can also specify constraints on generic types when defining methods on the type.=
=cpp中的模版全特化=
=注意这里impl 后面没有<f32>=

#+begin_src rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#+end_src

=Generic type parameters in a struct definition aren’t always the same as those you use in that same struct’s method signatures=

#+begin_src rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
#+end_src

=The purpose of this example is to demonstrate a situation in which some generic parameters are declared with impl and some are declared with the method definition.=

*** Performance of Code Using Generics

using generic types won’t make your program run any slower than it would with concrete types.

=Rust accomplishes this by performing monomorphization of the code using generics at compile time=
和cpp一样 在编译时期生成对应代码
the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.

** Traits: Defining Shared Behavior

=use traits to define shared behavior in an abstract way.=

=use trait bounds to specify that a generic type= can be any type that =has certain behavior.=

*** Defining a Trait

#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String;
}
#+end_src

declare a trait using the =trait= keyword

declare the trait =as pub so that crates depending on this crate can make use of this trait too=
[[*Paths for Referring to an Item in the Module Tree]]

Each type =implementing this trait must provide its own custom behavior for the body of the method.=

=The compiler will enforce that any type that has the Summary trait will have the method summarize defined with this signature exactly.=

*** Implementing a Trait on a Type

src/lib.rs
#+begin_src rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
#+end_src

[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]

Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.

users of the crate can call the trait methods on instances of NewsArticle and Tweet in the same way we call regular methods.
=有点像接口的感觉，定义抽象方法给具体类型实现=

=must bring the trait into scope as well as the types.=

~cargo new aggregator --lib~

src/main.rs
#+begin_src rust
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
#+end_src

~cargo run~

也可以
在 lib.rs 中 ~pub mod {}~
在 src/example_mod.rs 中去实现
在 src/main.rs 中 ~use aggregator::example_mod::{};~
[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]

=One restriction to note is that we can implement a trait on a type only if either the trait or the type, or both, are local to our crate.=

part of a property called =coherence=, and more specifically the =orphan rule=

*** Default Implementations

=useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type.=

=we can keep or override each method’s default behavior.=

#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
#+end_src

To use a =default implementation= to =summarize= instances of =NewsArticle=,
we =specify an empty impl block= with ~impl Summary for NewsArticle {}.~
=Even though we’re no longer defining the summarize method on NewsArticle directly=

[[*Statements and Expressions]]

src/main.rs
#+begin_src rust
use aggregator::{NewsArticle, Summary};

fn main() {
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
}
#+end_src

=must bring the trait into scope as well as the types.=

 the syntax for overriding a default implementation is the same as the syntax for implementing a trait method that doesn’t have a default implementation.

 =Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation.=
    In this way, a trait can provide a lot of useful functionality and only require implementors to specify a small part of it.

#+begin_src rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
#+end_src

To use this version of Summary, we only need to define summarize_author when we implement the trait on a type

#+begin_src rust
  impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
 }
#+end_src

#+begin_src rust
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
#+end_src

➜  aggregator git:(master) ✗ cargo run                 
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/aggregator`
1 new tweet: (Read more from @horse_ebooks...)

*** Traits as Parameters

=impl Trait= syntax

=use traits to define functions that accept many different types.=

#+begin_src rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

*** Trait Bound Syntax

=place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.=

#+begin_src rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

=impl Trait= syntax is convenient and makes for more concise code in simple cases

=the fuller trait bound= syntax can express more complexity in other cases.

~pub fn notify<T: Summary>(item1: &T, item2: &T) {~
allow item1 and item2 to have different types (as long as both types implement Summary).
force both parameters to have the same type

*** Specifying Multiple Trait Bounds with the + Syntax

specify more than one trait bound.

=+= syntax

#+begin_src rust
pub fn notify(item: &(impl Summary + Display)) {
#+end_src

on generic types:

#+begin_src rust
pub fn notify<T: Summary + Display>(item: &T) {
#+end_src

*** Clearer Trait Bounds with where Clauses

Using too many trait bounds has its downsides.

Each generic has its own trait bounds, so functions with multiple generic type parameters can contain lots of trait bound information between the function’s name and its parameter list, making the function signature hard to read.

Rust has alternate syntax for =specifying trait bounds inside a where clause= after the function signature.

#+begin_src rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {

//equal

fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
#+end_src

This function’s signature is less cluttered

*** Returning Types That Implement Traits

also use =the impl Trait syntax= in the =return position= to return a value of some type that implements a trait

#+begin_src rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
#+end_src

The ability to specify a return type only by the trait it implements is especially =useful in the context of closures and iterators=

The =impl Trait= syntax lets you concisely specify that a function =returns some type that implements the Iterator trait= without needing to write out a very long type.

=you can only use impl Trait if you’re returning a single type.=

#+begin_src rust
fn returns_summarizable(switch: bool) -> impl Summary { // ERROR!!!
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            retweet: false,
        }
    }
}
#+end_src

=Returning either a NewsArticle or a Tweet isn’t allowed due to restrictions around how the impl Trait syntax is implemented in the compiler.=

[[https://doc.rust-lang.org/book/ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types][“Using Trait Objects That Allow for Values of Different Types”]]

*** Using Trait Bounds to Conditionally Implement Methods

[[*In Method Definitions]]
=中的模版“全特化”=

By =using a trait bound with an impl block= that uses generic type parameters,
we can =implement methods conditionally for types that implement the specified traits.=

For example, the type Pair<T> always implements the new function to return a new instance of Pair<T>
=Self is a type alias for the type of the impl block, which in this case is Pair<T>=
[[*Method Syntax]]
But in the next impl block,
Pair<T> only implements the cmp_display method =if its inner type T implements the PartialOrd trait= that enables comparison =and the Display trait= that enables printing.

#+begin_src rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
#+end_src

=We can also conditionally implement a trait for any type that implements another trait.=

还可以有条件地为任何实现了某个 trait 的类型实现另一个 trait。

=blanket implementations= 泛用实现 ，在 Rust 标准库中被大量使用。

=the standard library implements the ToString trait on any type that implements the Display trait.=

#+begin_src rust
impl<T: Display> ToString for T {
    // --snip--
}
#+end_src

=can call the to_string method defined by the ToString trait on any type that implements the Display trait.=
For example, we can turn integers into their corresponding String values like this
because integers implement Display:
~let s = 3.to_string();~

=Traits and trait bounds let us write code that uses generic type parameters to reduce duplication
but also specify to the compiler that we want the generic type to have particular behavior.=

=The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior.=

=In dynamically typed languages, we would get an error at runtime if we called a method on a type which didn’t define the method.=
=Rust moves these errors to compile time so we’re forced to fix the problems before our code is even able to run.=
和cpp一样 编译器解决

=improves performance without having to give up the flexibility of generics.=

** Validating References with Lifetimes

add : [[*Defining the page_title Function]]

=lifetimes ensure that references are valid as long as we need them to be.=

=every reference in Rust has a lifetime,
which is the scope for which that reference is valid.=

Most of the time,
=lifetimes are implicit and inferred=
=types are inferred=
=We must annotate types only when multiple types are possible.=
=感觉超出编译器的上限（推断不出的时候）就需要我们人工介入了=
=we must annotate lifetimes when the lifetimes of references could be related in a few different ways.=
  annotate the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.

*** Preventing Dangling References with Lifetimes

main aim is to =prevent dangling references=, which cause a program to reference data other than the data it’s intended to reference. 

#+begin_src rust
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {r}");
}
#+end_src

➜  example git:(master) ✗ cargo run        
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
error[E0597]: `x` does not live long enough
 --> src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `example` (bin "example") due to 1 previous error

variable x “does not live long enough.”
The reason is that x will be out of scope when the inner scope ends on line 7.
But r is still valid for the outer scope; because its scope is larger, we say that it “lives longer.”
If Rust allowed this code to work, r would be referencing memory that was deallocated when x went out of scope, and anything we tried to do with r wouldn’t work correctly.
=how does Rust determine that this code is invalid? It uses a borrow checker.=

*** The Borrow Checker

=The Rust compiler has a borrow checker that compares scopes to determine whether all borrows are valid.=

#+begin_src rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
#+end_src

annotated the lifetime of r with 'a
the lifetime of x with 'b
=At compile time, Rust compares the size of the two lifetimes and sees that r has a lifetime of 'a but that it refers to memory with a lifetime of 'b.=
The program is rejected because 'b is shorter than 'a:
=the subject of the reference doesn’t live as long as the reference.=

fixes the code so it doesn’t have a dangling reference and it compiles without any errors.
#+begin_src rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+
#+end_src

x has the lifetime 'b, which in this case is larger than 'a.
=This means r can reference x because Rust knows that the reference in r will always be valid while x is valid.=

*** Generic Lifetimes in Functions

write a function that returns the longer of two string slices.
This function will take two string slices and return a single string slice.
[[*The Slice Type a different kind of reference]]

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}
#+end_src

we want the function to take string slices, which are references, rather than strings,
because we don’t want the longest function to take ownership of its parameters.

[[https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices-as-parameters][“String Slices as Parameters”]]

#+begin_src rust
fn longest(x: &str, y: &str) -> &str { // Cannot Compile!!!
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

➜  example git:(master) ✗ cargo run
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `example` (bin "example") due to 1 previous error

=the return type needs a generic lifetime parameter on it because Rust can’t tell whether the reference being returned refers to x or y.=
we don’t know either
  When we’re defining this function, we don’t know the concrete values that will be passed into this function, so we don’t know whether the if case or the else case will execute.
  =We also don’t know the concrete lifetimes of the references that will be passed in=
  =The borrow checker can’t determine this either, because it doesn’t know how the lifetimes of x and y relate to the lifetime of the return value.!!!=

To fix this error,
we’ll add generic lifetime parameters that define the relationship between the references
=so the borrow checker can perform its analysis.=

*** Lifetime Annotation Syntax

=Lifetime annotations don’t change how long any of the references live.=
=they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.=

functions can accept any type when the signature specifies a generic type parameter,
=functions can accept references with any lifetime by specifying a generic lifetime parameter.=

Lifetime annotations syntax :
  =the names of lifetime parameters must start with an apostrophe (') a=
  =usually all lowercase and very short=
  e.g. ~'a~
  =place lifetime parameter annotations after the & of a reference=

#+begin_src rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
#+end_src

One lifetime annotation by itself doesn’t have much meaning
  =the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other.=

*** Lifetime Annotations in Function Signatures

=need to declare the generic lifetime parameters inside angle brackets between the function name and the parameter list=

#+begin_src rust
// the returned reference will be valid as long as both the parameters are valid.
// This is the relationship between lifetimes of the parameters and the return value. 
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

The function signature now tells Rust that
for some lifetime 'a,
the function takes two parameters, 
both of which are string slices that live =at least as long as= lifetime 'a.

The function signature also tells Rust that
the string slice returned from the function will live =at least as long as= lifetime 'a.

=at least as long as=
=这个很有意思=
=至少让编译器知道了不会是 Deadline referencing 足够了！！！=

it means that the lifetime of the reference returned by the longest function is the same as
=the smaller= of the lifetimes of the values referred to by the function arguments.

we’re specifying that =the borrow checker should reject any values that don’t adhere to these constraints=.

the longest function doesn’t need to know exactly how long x and y will live,
=only that some scope can be substituted for 'a that will satisfy this signature.=
=the concrete lifetime that is substituted for 'a is the part of the scope of x that overlaps with the scope of y.=
=the generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y.=

#+begin_src rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
#+end_src

=try an example that shows that the lifetime of the reference in result must be the smaller lifetime of the two arguments.=

#+begin_src rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
#+end_src

➜  example git:(master) ✗ cargo run
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
error[E0597]: `string2` does not live long enough
  --> src/main.rs:14:44
   |
13 |         let string2 = String::from("xyz");
   |             ------- binding `string2` declared here
14 |         result = longest(string1.as_str(), string2.as_str());
   |                                            ^^^^^^^ borrowed value does not live long enough                                 
15 |     }
   |     - `string2` dropped here while still borrowed
16 |     println!("The longest string is {result}");
   |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `example` (bin "example") due to 1 previous error

The error shows that for result to be valid for the println! statement,
                         string2 would need to be valid until the end of the outer scope.

=Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter 'a.=
=We’ve told Rust that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the references passed in.=
=通过 life time generic parameters=
  在声明中return type 的lifetime 和  string1 和 string2 较小的lifetime 相同

=at least as long as=
=这个很有意思=
=至少让编译器知道了不会是 Deadline referencing 足够了！！！=

it means that the lifetime of the reference returned by the longest function is the same as
=the smaller= of the lifetimes of the values referred to by the function arguments.

we’re specifying that =the borrow checker should reject any values that don’t adhere to these constraints=.

the longest function doesn’t need to know exactly how long x and y will live,
=only that some scope can be substituted for 'a that will satisfy this signature.=
=the concrete lifetime that is substituted for 'a is the part of the scope of x that overlaps with the scope of y.=
=the generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y.=

这个签名表达了以下约束：
  函数返回的引用将会在 x 和 y 都有效的情况下才有效；
  我们通过将生命周期 'a 应用到所有引用上，来告诉编译器它们之间的关系。
  这表示：返回值的生命周期 不会比参数中任何一个更长。

'a 是一个生命周期参数，编译器并不知道它具体多长，只知道它是“某个有效作用域”；
=编译器会保证：调用者传入的引用们，必须满足返回引用的生命周期不会超出这两个参数引用中“较短”的那个；=
也就是说：返回值的生命周期是 x 和 y 生命周期中较短的那个

~fn longest<'a>(x: &'a str, y: &'a str) -> &'a str~
Rust 推理的逻辑是：
=返回值最多只能活得跟 'a 一样久，而 'a 是 x 和 y 的共同生命周期（重叠部分）。=

*** Thinking in Terms of Lifetimes

The way in which =you need to specify lifetime parameters=
=depends on what your function is doing.=

=超出编译器能力的时候才需要显示“操作”=

#+begin_src rust
//if we changed the implementation of the longest function to always return the first parameter rather than the longest string slice
//we wouldn’t need to specify a lifetime on the y parameter.
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
#+end_src

=When returning a reference from a function,=
  =the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters.!!!=
  =If the reference returned does not refer to one of the parameters=
    it must refer to a value created within this function.
    this would be a =dangling reference=
    because the value will go out of scope at the end of the function.

#+begin_src rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str() // ERROR!!! out of scope, dangling reference
}
#+end_src

=the return value lifetime is not related to the lifetime of the parameters at all.=

➜  example git:(master) ✗ cargo run     
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
warning: unused variable: `x`
 --> src/main.rs:1:16
  |
1 | fn longest<'a>(x: &str, y: &str) -> &'a str {
  |                ^ help: if this is intentional, prefix it with an underscore: `_x`         
  |
  = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `y`
 --> src/main.rs:1:25
  |
1 | fn longest<'a>(x: &str, y: &str) -> &'a str {
  |                         ^ help: if this is intentional, prefix it with an underscore: `_y`         

error[E0515]: cannot return value referencing local variable `result`
 --> src/main.rs:3:5
  |
3 |     result.as_str()
  |     ------^^^^^^^^^
  |     |
  |     returns a value referencing data owned by the current function
  |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
warning: `example` (bin "example") generated 2 warnings
error: could not compile `example` (bin "example") due to 1 previous error; 2 warnings emitted

=result goes out of scope and gets cleaned up at the end of the longest function.=
=the best fix would be to return an owned data type rather than a reference=

=Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions=
Once they’re connected,
  Rust has enough information to allow memory-safe operations
  disallow operations that would create dangling pointers or otherwise violate memory safety.
=超出编译器能力的时候才需要显示“操作”=

*** Lifetime Annotations in Struct Definitions

=define structs to hold references=
=in that case we would need to add a lifetime annotation on every reference in the struct’s definition.=

#+begin_src rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
#+end_src

=和函数一样 都是在名称后面=
=go的类型在变量后面，正好和rust 变量 : 类型 顺序一致=

=means an instance of ImportantExcerpt can’t outlive the reference it holds in its part field.=

*** Lifetime Elision

=every reference has a lifetime and that you need to specify lifetime parameters for functions or structs that use references.=

#+begin_src rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
#+end_src

=The reason this function compiles without lifetime annotations is historical:=
=in early versions (pre-1.0) of Rust, this code wouldn’t have compiled because every reference needed an explicit lifetime.=
At that time, the function signature would have been written like this:
~fn first_word<'a>(s: &'a str) -> &'a str {~

After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations.
These situations were predictable and followed =a few deterministic patterns.=
=The developers programmed these patterns into the compiler’s code so the borrow checker could infer the lifetimes in these situations and wouldn’t need explicit annotations.=

=This piece of Rust history is relevant because it’s possible that more deterministic patterns will emerge and be added to the compiler.=
In the future, even fewer lifetime annotations might be required.

=lifetime elision rules=
  a set of particular cases that the compiler will consider, and if your code fits these cases, you don’t need to write the lifetimes explicitly.
  If there is still ambiguity as to what lifetimes the references have after Rust applies the rules, the compiler won’t guess what the lifetime of the remaining references should be.
  =超出编译器能力的时候才需要显示“操作”=

=input lifetimes=
  Lifetimes on function or method parameters

=output lifetimes=
  lifetimes on return values

The compiler uses =three rules= to figure out the lifetimes of the references =when there aren’t explicit annotations.=
=If the compiler gets to the end of the three rules and there are still references for which it can’t figure out lifetimes, the compiler will stop with an error.=
=超出编译器能力的时候才需要显示“操作”=
=编译器先隐式先做，出现歧义，才要求显示声明lifetime=
  =1.the compiler assigns a lifetime parameter to each parameter that’s a reference.=
    ~fn foo<'a>(x: &'a i32)~
    ~fn foo<'a, 'b>(x: &'a i32, y: &'b i32)~
  =2.if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters=
    ~fn foo<'a>(x: &'a i32) -> &'a i32~
  =3.if there are multiple input lifetime parameters, but one of them is &self or &mut self because this is a method=
    =the lifetime of self is assigned to all output lifetime parameters.=
    makes methods much nicer to read and write because fewer symbols are necessary.

pretend we’re the compiler.
~fn first_word(s: &str) -> &str {~
  apply rule 1
  ~fn first_word<'a>(s: &'a str) -> &str {~
  apply rule 2
  ~fn first_word<'a>(s: &'a str) -> &'a str {~
  all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.

~fn longest(x: &str, y: &str) -> &str {~
  apply rule 1
  ~fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {~
  apply rule 2
  =出现歧义，需要人工显示声明 lifetime=
  After working through all three rules, we still haven’t figured out what the return type’s lifetime is.

*** Lifetime Annotations in Method Definitions

[[*Lifetime Elision]]
rule 3
  =3.if there are multiple input lifetime parameters, but one of them is &self or &mut self because this is a method=
    =the lifetime of self is assigned to all output lifetime parameters.=
    makes methods much nicer to read and write because fewer symbols are necessary.

[[*Generic Data Types]]    
  [[*In Method Definitions]]

Where we declare and use the lifetime parameters
=depends on whether they’re related to the struct fields or the method parameters and return values.=

 In addition, the =lifetime elision rules= =often make it so that lifetime annotations aren’t necessary in method signatures.=

rule1 + rule2 / rule3 
#+begin_src rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
#+end_src

rule1 + rule3
#+begin_src rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {announcement}");
        self.part
    }
}
#+end_src

*** The Static Lifetime

='static=

=the affected reference can live for the entire duration of the program.=

=All string literals have the 'static lifetime=
[[*String Literals as Slices]]

~let s: &'static str = "I have a static lifetime.";~

*** Generic Type Parameters, Trait Bounds, and Lifetimes Together

#+begin_src rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

[[*In Function Definitions]]
[[*Clearer Trait Bounds with where Clauses]]

* CHAPTER 11 testing, which even with Rust’s safety guarantees is necessary to ensure your program’s logic is correct.
** How to Write Tests

=test= attribute, a =few macros=, and the =should_panic= attribute.

*** The Anatomy of a Test Function

a test in Rust is a function that’s annotated with the =test= attribute.

=Attributes are metadata about pieces of Rust code;=

=derive= attribute
[[*Adding Useful Functionality with Derived Traits]]

add =#[test]= on the line before =fn=

~cargo test~
Rust builds a test runner binary that =runs the annotated functions= and reports on whether each test function passes or fails.

Whenever we =make a new library project with Cargo=,
=a test module with a test function in it is automatically generated for us.=

~cargo new adder --lib~
~cd adder~

src/lib.rs
#+begin_src rust
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    // We might also have non-test functions in the tests module to help set up common scenarios or perform common operations

    #[test] // indicates this is a test function
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
#+end_src

=assert_eq!= macro to assert that result

~cargo test~
➜  adder git:(master) ✗ cargo test           
   Compiling adder v0.1.0 (/Users/jieman/Desktop/projects/rust/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.86s
     Running unittests src/lib.rs (target/debug/deps/adder-3fb1943005761646)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s              

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

=It’s possible to mark a test as ignored so it doesn’t run in a particular instance;=
[[https://doc.rust-lang.org/book/ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested][“Ignoring Some Tests Unless Specifically Requested”]]

[[https://doc.rust-lang.org/unstable-book/library-features/test.html][the documentation about benchmark tests]]

=can pass an argument to the cargo test command to run only tests whose name matches a string=
[[https://doc.rust-lang.org/book/ch11-02-running-tests.html#running-a-subset-of-tests-by-name][“Running a Subset of Tests by Name”]]

=Rust can compile any code examples that appear in our API documentation.=
[[https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests][“Documentation Comments as Tests”]]

#+begin_src rust
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}
#+end_src

make a test that fails!
=Each test is run in a new thread,=
=and when the main thread sees that a test thread has died,=
=the test is marked as failed.=

~cargo test~
➜  adder git:(master) ✗ cargo test
   Compiling adder v0.1.0 (/Users/jieman/Desktop/projects/rust/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.17s
     Running unittests src/lib.rs (target/debug/deps/adder-3fb1943005761646)

running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----

thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s              

error: test failed, to rerun pass `--lib`
[[https://doc.rust-lang.org/book/ch11-02-running-tests.html#controlling-how-tests-are-run][“Controlling How Tests Are Run”]]

*** Checking Results with the assert! Macro

=assert!= macro
  an argument that evaluates to a Boolean. 
  =If the value is false, the assert! macro calls panic! to cause the test to fail.=

src/lib.rs  
#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&smaller));
    }

    #[test]
    fn smaller_cannot_hould_lager() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };

        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&larger));
    }
}
#+end_src

~use super::*;~
[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]
[[*Paths for Referring to an Item in the Module Tree]]
[[*Bringing Paths into Scope with the use Keyword]]
=super= allows us to reference an item in the parent module
    =因为 eat_at_restaurant 和 mod front_of_house 是 siblings 关系 所以可以直接调用=
    =同时 子module 可以调用 祖先module 所有 item=
    =other items, such as structs, enums, constants, traits, and functions.=
    =默认子module 对 祖先module 是private 除非加pub=
[[*The Glob Operator]]    

=the tests module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module.=

➜  adder git:(master) ✗ cargo test
   Compiling adder v0.1.0 (/Users/jieman/Desktop/projects/rust/adder)
warning: struct `Rectangle` is never constructed
 --> src/lib.rs:2:8
  |
2 | struct Rectangle {
  |        ^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: method `can_hold` is never used
 --> src/lib.rs:8:8
  |
7 | impl Rectangle {
  | -------------- method in this implementation
8 |     fn can_hold(&self, other: &Rectangle) -> bool {
  |        ^^^^^^^^

warning: `adder` (lib) generated 2 warnings
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.12s
     Running unittests src/lib.rs (target/debug/deps/adder-3fb1943005761646)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hould_lager ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s              

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

*** Testing Equality with the assert_eq! and assert_ne! Macros

=assert_eq! and assert_ne!=
   These macros compare two arguments for equality or inequality
   They’ll also print the two values if the assertion fails, which makes it easier to see why the test failed;

#+begin_src rust
pub fn add_two(a: usize) -> usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}
#+end_src

~cargo test~

Under the surface, the =assert_eq! and assert_ne! macros= use the operators == and !=,
When the assertions fail, these macros print their arguments using debug formatting,
=which means the values being compared must implement the PartialEq and Debug traits=
=both traits are derivable traits=
=this is usually as straightforward as adding the #[derive(PartialEq, Debug)] annotation to your struct or enum definition.=
[[https://doc.rust-lang.org/book/appendix-03-derivable-traits.html][“Derivable Traits,”]]

[[*Adding Useful Functionality with Derived Traits]]
[[*Traits: Defining Shared Behavior]]
[[*Macros]]

*** Adding Custom Failure Messages

can also add a custom message to be printed with the failure message
=as optional arguments to the assert!, assert_eq!, and assert_ne! macros.=

=Any arguments specified after the required arguments are passed along to the format! macro=
[[*Concatenation with the + Operator or the format! Macro]]
format! macro uses references

src/lib.rs
#+begin_src rust
pub fn greeting(_name: &str) -> String {
    // format!("Hello {name}!")
    format!("Hello")
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
}
#+end_src

~cargo test~

➜  adder git:(master) ✗ cargo test
   Compiling adder v0.1.0 (/Users/jieman/Desktop/projects/rust/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.15s
     Running unittests src/lib.rs (target/debug/deps/adder-3fb1943005761646)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:14:9:
Greeting did not contain name, value was `Hello`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`

*** Checking for Panics with should_panic

=The test passes if the code inside the function panics;=

src/lib.rs
#+begin_src rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.")
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#+end_src

=place the #[should_panic] attribute after the #[test] attribute=

~cargo test~

src/lib.rs
#+begin_src rust
// --snip--

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value > 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#+end_src

=The test harness will make sure that the failure message contains the provided text.=

*** Using Result<T, E> in Tests

=We can also write tests that use Result<T, E>!=
=return an Err instead of panicking:=

src/lib.rs
#+begin_src rust
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() -> Result<(), String> {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
#+end_src

[[*The Tuple Type]]

=return a Result<T, E> enables you to use the question mark operator in the body of tests=
[[*A Shortcut for Propagating Errors: the ? Operator]]

=can’t use the #[should_panic] annotation on tests that use Result<T, E>.=

To assert that an operation returns an Err variant, don’t use the question mark operator on the Result<T, E> value.
=Instead, use assert!(value.is_err()).=

** Controlling How Tests Are Run

~cargo run~ compiles your code and then runs the resultant binary
~cargo test~ compiles your code in test mode and runs the resultant test binary.

~cargo test~ default behavior
  =run all the tests in parallel=
  ~cargo test --~ then the ones that go to the test binary.
  ~cargo test -- --help~
  ~cargo test --help~ displays the options you can use with cargo test

https://doc.rust-lang.org/rustc/tests/index.html

*** Running Tests in Parallel or Consecutively

by default they run in parallel using threads

Because the tests are running at the same time,
  you must =make sure your tests don’t depend on each other or on any shared state, including a shared environment,=

If you don’t want to run the tests in parallel or if you want more fine-grained control over the number of threads used
~cargo test -- --test-threads=1~

*** Showing Function Output

if we call println! in a test and the test passes, we won’t see the println! output in the terminal;
If a test fails, we’ll see whatever was printed to standard output with the rest of the failure message.

~cargo test -- --show-output~

*** Running a Subset of Tests by Name

src/lib.rs
#+begin_src rust
pub fn add_two(a: usize) -> usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = add_two(3);
        assert_eq!(result, 5);
    }

    #[test]
    fn one_hundred() {
        let result = add_two(100);
        assert_eq!(result, 102);
    }
}
#+end_src

~cargo test one_hundred~

*** Filtering to Run Multiple Tests

=can specify part of a test name, and any test whose name matches that value will be run.=

~cargo test add~

Also note that the module in which a test appears becomes part of the test’s name,
=so we can run all the tests in a module by filtering on the module’s name.=

*** Ignoring Some Tests Unless Specifically Requested

Rather than listing as arguments all tests you do want to run,
you can instead =annotate the time-consuming tests using the ignore attribute to exclude them=, as shown here:

src/lib.rs
#+begin_src rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}
#+end_src

~cargo test -- --ignored~

~cargo test -- --include-ignored~

** Test Organization

=unit tests and integration tests=

*** Unit Tests

The convention is to create a =module named tests in each file= to contain the test functions and to =annotate the module with cfg(test).=

=The Tests Module and #[cfg(test)]=

=The #[cfg(test)] annotation on the tests module= tells Rust to compile and run the test code =only when you run cargo test=, =not when you run cargo build.=
  This saves compile time when you only want to build the library
  saves space in the resultant compiled artifact because the tests are not included.
  =#[cfg(test)] to specify that they shouldn’t be included in the compiled result.=

=integration tests go in a different directory, they don’t need the #[cfg(test)] annotation.=

src/lib.rs
#+begin_src rust
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
#+end_src

=the attribute cfg stands for configuration=
  =tells Rust that the following item should only be included given a certain configuration option.=
  ~cargo test~

*** Testing Private Functions

=Rust’s privacy rules do allow you to test private functions.=

src/lib.rs
#+begin_src rust
pub fn add_two(a: usize) -> usize {
    internal_adder(a, 2)
}

fn internal_adder(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}
#+end_src

internal_adder function is not marked as pub.
=Tests are just Rust code, and the tests module is just another module.=
[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]
[[*Paths for Referring to an Item in the Module Tree]]

=items in child modules can use the items in their ancestor modules.=
~use super::*;~
[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]
[[*Paths for Referring to an Item in the Module Tree]]
[[*Bringing Paths into Scope with the use Keyword]]
=super= allows us to reference an item in the parent module
    =因为 eat_at_restaurant 和 mod front_of_house 是 siblings 关系 所以可以直接调用=
    =同时 子module 可以调用 祖先module 所有 item=
    =other items, such as structs, enums, constants, traits, and functions.=
    =默认子module 对 祖先module 是private 除非加pub=
[[*The Glob Operator]]

=即使你在子模块中使用了 use super::*;，也只能访问上级模块中那些被 pub 明确公开的项。没有 pub 的 item 是私有的，不会被导入，也不能访问。=

*** Integration Tests

=In Rust, integration tests are entirely external to your library.=

=which means they can only call functions that are part of your library’s public API.=
[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]
[[*Paths for Referring to an Item in the Module Tree]]

=To create integration tests, you first need a tests directory.=

*** The tests Directory

adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs

=Cargo will compile each of the files as an individual crate.=

tests/integration_test.rs
#+begin_src rust
use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}
#+end_src

=Each file in the tests directory is a separate crate=
  =so we need to bring our library into each test crate’s scope.=

=don’t need to annotate any code in tests/integration_test.rs with #[cfg(test)].=

=Cargo treats the tests directory specially and compiles files in this directory only when we run cargo test.=

~cargo test~ output include the =unit tests, the integration test, and the doc tests.=

=can still run a particular integration test function by specifying the test function’s name=
~cargo test -- --test integration_test~

*** Submodules in Integration Tests

might want to make more files in the tests directory to help organize them;

As mentioned earlier, =each file in the tests directory is compiled as its own separate crate=

=instead of creating tests/common.rs, we’ll create tests/common/mod.rs.=
[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]
注意和 [[*Modules Cheat Sheet]] 区别！！！

├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs

=the older naming convention=

=Naming the file this way tells Rust not to treat the common module as an integration test file.=

tests/integration_test.rs
#+begin_src rust
use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}
#+end_src

[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]

*** Integration Tests for Binary Crates

If our project =is a binary crate that only contains a src/main.rs file and doesn’t have a src/lib.rs file=,
we =can’t create integration tests in the tests directory= and =bring functions defined in the src/main.rs file into scope with a use statement.=

=Only library crates expose functions that other crates can use;=

=src/main.rs file that calls logic that lives in the src/lib.rs file.=

=integration tests can test the library crate with use to make the important functionality available.=

[[*The tests Directory]]
[[*Submodules in Integration Tests]]

* Chapter 12 build our own implementation of a subset of functionality from the grep command line tool that searches for text within files.
* Chapter 13 closures and iterators

Programming in a functional style often includes
  using functions as values by passing them in arguments
  returning them from other functions
  assigning them to variables for later execution
  so forth.

Closures, a function-like construct you can store in a variable
Iterators, a way of processing a series of elements
How to use closures and iterators to improve the I/O project
The performance of closures and iterators (Spoiler alert: they’re faster than you might think!)

** Closures: Anonymous Functions that Capture Their Environment

=Rust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions.=

=closures can capture values from the scope in which they’re defined.!!!=

函数是一等公民 + env 捕获

*** Capturing the Environment with Closures

=use closures to capture values from the environment they’re defined in for later use.=

src/main.rs
#+begin_src rust
#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec<ShirtColor>,
}

impl Inventory {
    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&self) -> ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &self.shirts {
            match color {
                ShirtColor::Red => num_red += 1,
                ShirtColor::Blue => num_blue += 1,
            }
        }
        if num_red > num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
#+end_src

unwrap_or_else
https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else
[[*Alternatives to Using match with Result<T, E>]]
is defined by the standard library.
one argument: a closure without any arguments that returns a value T (the same type stored in the Some variant of the Option<T>, in this case ShirtColor).
  If the Option<T> is the Some variant, unwrap_or_else returns the value from within the Some.
  If the Option<T> is the None variant, unwrap_or_else calls the closure and returns the value returned by the closure.

=closure expression=  ~|| {}~
~cargo run~

=The closure captures an immutable reference to the self Inventory instance and passes it with the code we specify to the unwrap_or_else method.=
=Functions, on the other hand, are not able to capture their environment in this way.=

*** Closure Type Inference and Annotation

=Closures don’t usually require you to annotate the types of the parameters or the return value like fn functions do.=
=Type annotations are required on functions because the types are part of an explicit interface exposed to your users.=

Closures, on the other hand, aren’t used in an exposed interface like this: they’re stored in variables and used without naming them and exposing them to users of our library.
Closures are typically short and relevant only within a narrow context rather than in any arbitrary scenario.

=Within these limited contexts, the compiler can infer the types of the parameters and the return type, similar to how it’s able to infer the types of most variables=

=As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary.=

src/main.rs
#+begin_src rust
    let expensive_closure = |num: u32| -> u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
#+end_src

src/main.rs

#+begin_src rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
// The add_one_v3 and add_one_v4 lines require the closures to be evaluated to be able to compile
// because the types will be inferred from their usage.
// similar to let v = Vec::new(); needing either type annotations or values of some type to be inserted into the Vec for Rust to be able to infer the type.  
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
#+end_src

=For closure definitions, the compiler will infer one concrete type for each of their parameters and for their return value.=

src/main.rs
#+begin_src rust
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5); // ERROR
#+end_src

=The first time we call example_closure with the String value, the compiler infers the type of x and the return type of the closure to be String.=
=Those types are then locked into the closure in example_closure, and we get a type error when we next try to use a different type with the same closure.=

*** Capturing References or Moving Ownership

Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter:
  =borrowing immutably, borrowing mutably, and taking ownership.=

The closure will decide which of these to use =based on what the body of the function does with the captured values.=

=captures an immutable reference=
src/main.rs
#+begin_src rust
fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}
#+end_src

=we can have multiple immutable references to list at the same time=
[[*Chapter 4 Rust’s ownership system]]
[[*References and Borrowing]]

=closure now captures a mutable reference:=
src/main.rs
#+begin_src rust
fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}
#+end_src

=Note that there’s no longer a println! between the definition and the call of the borrows_mutably closure=
=编译器根据你写的代码来 infer 和 判断是否违背 ownership=
=when borrows_mutably is defined, it captures a mutable reference to list.=
=We don’t use the closure again after the closure is called, so the mutable borrow ends.=
=Between the closure definition and the closure call, an immutable borrow to print isn’t allowed=
[[*Chapter 4 Rust’s ownership system]]
[[*References and Borrowing]]

=force the closure to take ownership of the values it uses in the environment even= though the body of the closure doesn’t strictly need ownership
~move~ keyword
=is mostly useful when passing a closure to a new thread to move the data so that it’s owned by the new thread.!!!=
线程之间寄存器，栈独立 但是 页表，文件描述符数组等资源公用
具体看操作系统真相还原

src/main.rs
#+begin_src rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}
#+end_src

=If the main thread maintained ownership of list but ended before the new thread did and dropped list, the immutable reference in the thread would be invalid.=

*** Moving Captured Values Out of Closures and the Fn Traits

=Closures will automatically implement one, two, or all three of these Fn traits,=
=depending on how the closure’s body handles the values=
  =1.FnOnce applies to closures that can be called once.=
    All closures implement at least this trait, because all closures can be called. 
    A closure that moves captured values out of its body will only implement FnOnce and none of the other Fn traits, because it can only be called once.
  =2.FnMut applies to closures that don’t move captured values out of their body, but that might mutate the captured values.=
    These closures can be called more than once.
  =3.Fn applies to closures that don’t move captured values out of their body and that don’t mutate captured values, as well as closures that capture nothing from their environment.=
    These closures can be called more than once without mutating their environment
    which is important in cases such as calling a closure =multiple times concurrently.=

Rust 会根据闭包内部对捕获变量的使用方式，自动决定闭包是 Fn / FnMut / FnOnce 类型。
闭包会根据它体内对捕获变量的使用方式，以“增量的方式”自动实现这三个 trait 中的一个、两个或三个。
1.FnOnce：能被调用一次的闭包
  FnOnce 适用于只能调用一次的闭包。
  所有闭包至少都会实现 FnOnce，因为所有闭包都可以被调用一次。
  如果一个闭包把捕获的变量“移出”闭包体，它就只能实现 FnOnce，不能再实现 FnMut 或 Fn，因为变量已经被 move 掉了，只能调用一次。
2.FnMut：可变调用的闭包
  FnMut 适用于那些没有 move 捕获变量、但可能会修改它们的闭包。
  这些闭包可以被调用多次。
3.Fn：纯读调用的闭包
  Fn 适用于既不移动捕获变量、也不修改它们的闭包，
  甚至包括完全不捕获环境变量的闭包。
  这些闭包可以被多次调用，且不会修改外部环境，非常适合在并发调用时使用。

=C++ 中的闭包（Closure）就是一个函数对象（Function Object），=
=也叫 函数仿函数（Functor）对象。=
=你可以把 闭包 = 匿名类 + operator() 重载 理解成一种语法糖，它本质上是编译器自动生成的一个带状态的类对象。=

=Rust 中的 trait 本质上是：定义一组方法签名，只要某个类型实现了这些方法，就实现了这个 trait。=
[[*Traits: Defining Shared Behavior]]
=闭包在 Rust 中其实是 编译器自动生成的匿名结构体，并自动实现了 FnOnce / FnMut / Fn trait 中的某一个或多个。=
=闭包 = 结构体 + 捕获变量作为字段 + 实现 Fn* trait 的 call 方法=
这就跟 C++ 中闭包是一个匿名类一样，在 Rust 中闭包就是一个匿名类型。

the definition of the unwrap_or_else method on Option<T>
#+begin_src rust
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
#+end_src

=在 F: FnMut() 里，这个括号 () 是什么意思？我们不是通常只写 F: SomeTrait 吗？为什么这里加了 ()？=
=这里的 () 不是 trait bound 的语法，而是 FnMut trait 的参数类型 —— 它的完整形式其实是一个 “可调用 trait”，你可以把它理解为：=
=“这个 F 是一个能被调用的东西，且不接受参数（() 表示空参数），且使用 FnMut 模式调用。”=

=深入解释：Fn/FnMut/FnOnce 是特例！=
=Rust 中这三个 trait 是“可调用 trait”，不是普通 trait。它们的声明其实是带泛型参数的：=

#+begin_src rust
pub trait Fn<Args> {
    type Output;
    fn call(&self, args: Args) -> Self::Output;
}
#+end_src

=Fn() 就是 Fn<()>，表示“这个东西可以被调用，接受 () 参数”=
=FnMut(String) -> bool 表示“一个可以被调用的东西，接受 String，返回 bool，以 FnMut 调用方式”=
=F: Fn(X) -> Y 是一种 trait bound 特例，表示 F 是一个 可调用的对象，它实现了 Fn（或 FnMut、FnOnce）这个 trait，括号里的内容是参数类型。=

=类比：Rust 的 Fn vs C++ 的 operator()！！！=

The F type is the type of the parameter named f, which =is the closure we provide when calling unwrap_or_else.=

The trait bound specified on the generic type F is FnOnce() -> T, =which means F must be able to be called once=, take no arguments, and return a T.
[[*Clearer Trait Bounds with where Clauses]]
[[*Traits: Defining Shared Behavior]]

If what we want to do doesn’t require capturing a value from the environment, we can use the name of a function rather than a closure.
For example, ~unwrap_or_else(Vec::new)~ on a ~Option<Vec<T>>~

the standard library method =sort_by_key= defined on slices
uses =FnMut= instead of =FnOnce= for the trait bound.
[[*Clearer Trait Bounds with where Clauses]]
[[*Traits: Defining Shared Behavior]]
is useful when you want to sort a slice by a particular attribute of each item.
#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}
#+end_src

The reason =sort_by_key= is defined to take an =FnMut= closure is that
=it calls the closure multiple times: once for each item in the slice.=
The closure |r| r.width doesn’t capture, mutate, or move out anything from its environment, so it meets the trait bound requirements.
=shows an example of a closure that implements just the FnOnce trait, because it moves a value out of the environment.=
=The compiler won’t let us use this closure with sort_by_key:=
#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value); // ERROR!!! that value can’t be moved out of the closure because the closure must implement FnMut
        r.width
    });
    println!("{list:#?}");
}
#+end_src

=C++ 中的闭包（Closure）就是一个函数对象（Function Object），=
=也叫 函数仿函数（Functor）对象。=
=你可以把 闭包 = 匿名类 + operator() 重载 理解成一种语法糖，它本质上是编译器自动生成的一个带状态的类对象。=
=Rust 中的 trait 本质上是：定义一组方法签名，只要某个类型实现了这些方法，就实现了这个 trait。=
[[*Traits: Defining Shared Behavior]]
=闭包在 Rust 中其实是 编译器自动生成的匿名结构体，并自动实现了 FnOnce / FnMut / Fn trait 中的某一个或多个。=
=闭包 = 结构体 + 捕获变量作为字段 + 实现 Fn* trait 的 call 方法=
这就跟 C++ 中闭包是一个匿名类一样，在 Rust 中闭包就是一个匿名类型。
[[*Trait Bound Syntax]]
[[*Traits: Defining Shared Behavior]]

Rust 会根据闭包内部对捕获变量的使用方式，自动决定闭包是 Fn / FnMut / FnOnce 类型。
闭包会根据它体内对捕获变量的使用方式，以“增量的方式”自动实现这三个 trait 中的一个、两个或三个。

错误核心：闭包试图 移动（move）捕获的变量 value，而 sort_by_key 要求的是实现 FnMut 的闭包。
为什么这里的闭包只实现了 FnOnce？ ~sort_operations.push(value);~
这一行把 value 所有权 move 出去了：String 类型没有实现 Copy，所以不能复制，只能 move。
                               一旦 move 到 push 里，下一次闭包再调用时 value 就没了。
但 sort_by_key 要求的是 FnMut
=匹配不了 Trait bound=

To fix this, we need to change the closure body so that it doesn’t move values out of the environment.
#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}
#+end_src

=The Fn traits are important when defining or using functions or types that make use of closures.=

* Chapter 14 Cargo in more depth and talk about best practices for sharing your libraries with others
** Publishing a Crate to Crates.io
[[https://crates.io/][crates.io]]
*** Making Useful Documentation Comments
=documentation comment, that will generate HTML documentation.=

=Documentation comments use three slashes, ///, instead of two =
=and support Markdown notation for formatting the text.=

#+begin_src rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
#+end_src

~cargo doc~ generate the HTML documentation from this documentation comment
  runs the ~rustdoc~ and =puts the generated HTML documentation in the target/doc directory.=

~cargp doc --open~
  build the HTML for your current crate’s documentation
  and open the result in a web browser.
*** Commonly Used Sections
Here are some other sections that crate authors commonly use in their documentation:
=Panics=
=Errors=
=Safety=
*** Documentation Comments as Tests
Adding example code blocks in your documentation comments can help demonstrate how to use your library
=and doing so has an additional bonus=

~cargo test~
  =will run the code examples in your documentation as tests!=
*** Commenting Contained Items
The style of doc comment //! adds documentation to the item that contains the comments rather than to the items following the comments.
=//! 是模块级或 crate 级别的文档注释，用于描述当前模块整体的用途，通常写在 src/lib.rs 文件顶部。=

#+begin_src rust
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
#+end_src
*** Exporting a Convenient Public API with pub use
[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]

=you can re-export items to make a public structure that’s different from your private structure by using pub use.=
[[*Re-exporting Names with pub use]]
Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.

#+begin_src rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        // --snip--
    }
}
#+end_src

Another crate that depends on this library would need use statements that bring the items from art into scope, specifying the module structure that’s currently defined.

#+begin_src rust
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
#+end_src

to

#+begin_src rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
#+end_src

#+begin_src rust
use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
}
#+end_src

~cargo doc --open~

=In cases where there are many nested modules, re-exporting the types at the top level with pub use can make a significant difference in the experience of people who use the crate.=
=Another common use of pub use is to re-export definitions of a dependency in the current crate to make that crate’s definitions part of your crate’s public API.=
*** Setting Up a Crates.io Account
Before you can publish any crates, you need to create an account on [[https://crates.io/][crates.io]] and get an API token.

~cargo login~
=and paste your API key when prompted=

=This command will inform Cargo of your API token and store it locally in ~/.cargo/credentials.=
*** Adding Metadata to a New Crate
Cargo.toml
need to add some metadata in the [package] section

need a unique name
  =Once a crate name is taken, no one else can publish a crate with that name.=

=a description and license are required so people will know what your crate does and under what terms they can use it.=
http://spdx.org/licenses/

#+begin_src toml
[package]
name = "guessing_game"
license = "MIT"
#+end_src

=If you want to use a license that doesn’t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use license-file to specify the name of that file instead of using the license key.=

#+begin_src toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
#+end_src
=you can also specify multiple license identifiers separated by OR to have multiple licenses for your project.=

https://doc.rust-lang.org/cargo/
*** Publishing to Crates.io
=a publish is permanent.=

~cargo publish~
*** Publishing a New Version of an Existing Crate
=change the version value specified in your Cargo.toml file and republish.=
~cargo publish~

[[http://semver.org/][Semantic Versioning rules]]
(sometimes called SemVer)
| MAJOR | 主版本号：做了不兼容的 API 修改（破坏性变更） |
| MINOR | 次版本号：增加了新功能，但向下兼容            |
| PATCH | 补丁号：修复了 bug，完全兼容                  |
*** Deprecating Versions from Crates.io with cargo yank
=Yanking a version prevents new projects from depending on that version while allowing all existing projects that depend on it to continue.=
=Essentially, a yank means that all projects with a Cargo.lock will not break, and any future Cargo.lock files generated will not use the yanked version.=

~cargo yank --vers 1.0.1~

By adding --undo to the command, you can also undo a yank and allow projects to start depending on a version again:

~cargo yank --vers 1.0.1 --undo~
** Cargo Workspaces
=A workspace is a set of packages that share the same Cargo.lock and output directory.=

~mkdir add~
~cd add~
~touch Cargo.toml~

Cargo.toml
#+begin_src toml
[workspace]
resolver = "2"
#+end_src

This file won’t have a [package] section.
Instead, it will start with a [workspace] section that will allow us to add members to the workspace.

~cargo new adder~
  automatically adds the newly created package to the members key in the [workspace] definition in the workspace Cargo.toml
  
Cargo.toml
#+begin_src toml
[workspace]
resolver = "2"
members = ["adder"]
#+end_src

The workspace has =one target directory= at the top level that the compiled artifacts will be placed into;
the adder package doesn’t have its own target directory.
=By sharing one target directory, the crates can avoid unnecessary rebuilding.=
*** Creating the Second Package in the Workspace
~cargo new add_one --lib~

Cargo.toml
#+begin_src toml
[workspace]
resolver = "2"
members = ["adder", "add_one"]
#+end_src

➜  add tree
.
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
├── Cargo.lock
├── Cargo.toml
└── target

add_one/src/lib.rs
#+begin_src rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}
#+end_src

adder/Cargo.toml
#+begin_src toml
[dependencies]
add_one = { path = "../add_one" }
#+end_src

=explicit about the dependency relationships.=

adder/src/main.rs
#+begin_src rust
fn main() {
    let num = 10;
    println!("Hello, world! {num} plus one is {}!", add_one::add_one(num));
}
#+end_src

~cargo build~
~cargo run -p adder~
*** Depending on an External Package in a Workspace
=Notice that the workspace has only one Cargo.lock file at the top level, rather than having a Cargo.lock in each crate’s directory.=
=This ensures that all crates are using the same version of all dependencies.=
=If we add the rand package to the adder/Cargo.toml and add_one/Cargo.toml files,=
=Cargo will resolve both of those to one version of rand and record that in the one Cargo.lock.=

add_one/Cargo.toml
#+begin_src toml
[dependencies]
rand = "0.8.5"
#+end_src

~use rand;~

~cargo build~
=Cargo will ensure that every crate in every package in the workspace using the rand package will be using the same version as long as they specify compatible versions of rand, saving us space and ensuring that the crates in the workspace will be compatible with each other.=
*** Adding a Test to a Workspace

add_one/src/lib.rs
#+begin_src rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
#+end_src

~cargo test~
~cargo test -p add_one~
*** Installing Binaries with cargo install
=allows you to install and use binary crates locally.=
=can only install packages that have binary targets.=
  A binary target is the runnable program that is created if the crate has a src/main.rs file or another file specified as a binary, as opposed to a library target that isn’t runnable on its own but is suitable for including within other programs.

~cargo install ripgrep~
=If you installed Rust using rustup.rs and don’t have any custom configurations, this directory will be $HOME/.cargo/bin.=
*** Extending Cargo with Custom Commands
=Cargo is designed so you can extend it with new subcommands without having to modify Cargo.=
=If a binary in your $PATH is named cargo-something, you can run it as if it was a Cargo subcommand by running cargo something.=
=Custom commands like this are also listed when you run cargo --list.=
* Chapter 15 smart pointers that the standard library provides and the traits that enable their functionality

The most common kind of pointer in Rust is a reference
[[*Method Syntax]]
[[*Where’s the -> Operator?]]

Smart pointers, are data structures that act like a pointer =but also have additional metadata and capabilities.=

originated in C++

Rust, =with its concept of ownership and borrowing=, has an additional difference between references and smart pointers:
[[*Chapter 4 Rust’s ownership system]]
  =references only borrow data=
  =smart pointers own the data they point to.=

=String, Vec<T>= smart pointers

=Smart pointers are usually implemented using structs.=
  implement the =Deref and Drop traits.=
  The =Deref= trait allows an instance of the smart pointer struct to behave like a reference
  The =Drop= trait allows you to customize the code that’s run when an instance of the smart pointer goes out of scope.

=Box<T>= for allocating values on the heap
=Rc<T>=, a reference counting type that enables multiple ownership
=Ref<T>= and =RefMut<T>=, accessed through =RefCell<T>=, a type that enforces the borrowing rules at runtime instead of compile time

=interior mutability pattern= where an immutable type exposes an API for =mutating an interior value.=

=reference cycles=: how they can leak memory and how to prevent them.

** Using Box<T> to Point to Data on the Heap

allow you to store data on the heap rather than the =stack.=
remains on the stack is the pointer =to the heap data.=
[[*Chapter 4 Rust’s ownership system]]

use them most often in these situations:
  1.When you have a =type whose size can’t be known at compile time= and you want to use a value of that type in a context that requires an exact size
  2.When you have a large amount of data and you want to transfer ownership but =ensure the data won’t be copied when you do so=
  3.When you want to own a value and =you care only that it’s a type that implements a particular trait rather than being of a specific type=

*** Using a Box<T> to Store Data on the Heap

src/main.rs
#+begin_src rust
fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}
#+end_src

when a box goes out of scope
The deallocation happens both for =the box (stored on the stack)= and =the data it points to (stored on the heap).=

*** Enabling Recursive Types with Boxes

A value of recursive type can have another value of the same type as part of itself.

=Recursive types pose an issue because at compile time Rust needs to know how much space a type takes up.=

=Because boxes have a known size, we can enable recursive types by inserting a box in the recursive type definition.=

=cons list= an example of a recursive type
  a data type commonly found in functional programming languages.
  
*** More Information About the Cons List

A cons list is =a data structure that comes from the Lisp programming language= and its dialects and is made up of nested pairs, and is the Lisp version of a linked list.

=cons= "construct function"

~(1, (2, (3, Nil)))~

The cons list isn’t a commonly used data structure in Rust. Most of the time when you have a list of items in Rust, Vec<T> is a better choice to use.

#+begin_src rust
enum List {
    Cons(i32, List), //ERROR won’t compile yet because the List type doesn’t have a known size
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
#+end_src

=Rust can’t figure out how much space it needs to store a List value.=

*** Computing the Size of a Non-Recursive Type

#+begin_src rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#+end_src

To determine how much space to allocate for a Message value,
=Rust goes through each of the variants to see which variant needs the most space.=

An infinite List consisting of infinite Cons variants
[[./pictures/rust/7.png]]
=Rust can’t figure out how much space it needs to store a List value.=

*** Using Box<T> to Get a Recursive Type with a Known Size

=Box<T>=

src/main.rs
#+begin_src rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
#+end_src

[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]

=The Cons variant needs the size of an i32 plus the space to store the box’s pointer data.=

To determine how much space to allocate for a Message value,
=Rust goes through each of the variants to see which variant needs the most space.=
=The Nil variant stores no values, so it needs less space than the Cons variant.=

A List that is not infinitely sized because Cons holds a Box
[[./pictures/rust/8.png]]

=Boxes provide only the indirection and heap allocation;=

The =Box<T>= type is a smart pointer because it implements the =Deref= trait,
  =allows Box<T> values to be treated like references.=
When a Box<T> value goes =out of scope,=
  the heap data that the box is pointing to is cleaned up as well =because of the Drop trait implementation.=
  
** Treating Smart Pointers Like Regular References with the Deref Trait

Implementing the =Deref= trait allows you to =customize the behavior of the dereference operator *=

=By implementing Deref in such a way= that =a smart pointer can be treated like a regular reference=

=Rust’s deref coercion feature=

*** Following the Pointer to the Value

=A regular reference is a type of pointer=

src/main.rs
#+begin_src rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
#+end_src

=we have to use *y to follow the reference to the value it’s pointing to (hence dereference) so the compiler can compare the actual value.=

注意
[[*Method Syntax]]
[[*Where’s the -> Operator?]]

*** Using Box<T> Like a Reference

use a Box<T> instead of a reference;

=the dereference operator used on the Box<T> in the same way as the dereference operator used on the reference=

src/main.rs
#+begin_src rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
#+end_src

*** Defining Our Own Smart Pointer

src/main.rs
#+begin_src rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
#+end_src

[[*Generic Data Types]]
[[*In Method Definitions]]

src/main.rs
#+begin_src rust
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y); // ERROR Rust doesn’t know how to dereference MyBox!!!
}
#+end_src

=To enable dereferencing with the * operator, we implement the Deref trait.=

*** Treating a Type Like a Reference by Implementing the Deref Trait

src/main.rs
#+begin_src rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
#+end_src

[[*Traits: Defining Shared Behavior]]

The =Deref= trait, provided by the standard library, requires us to implement one method named =deref= that borrows =self= and =returns a reference to the inner data.=

~type Target = T;~
=defines an associated type for the Deref trait to use.=
=Associated types are a slightly different way of declaring a generic parameter=
=cover them in more detail in Chapter 20.=

在 deref 方法中写的是 &self.0，这样就能返回一个对内部值的引用，以便我们用 * 操作符访问它。
.0 是访问元组结构体第一个字段的方式
[[*The Tuple Type]]
[[*Using Tuple Structs Without Named Fields to Create Different Types]]

=The deref method gives the compiler the ability to take a value of any type that implements Deref and call the deref method to get a & reference that it knows how to dereference.=

~*(y.deref())~
=和深入理解cpp对象模型中构造函数和析构函数中生成生成对应代码一样!!!=

=注意deref返回的是引用，没有拿走ownership=

*** Implicit Deref Coercions with Functions and Methods

=Deref coercion converts a reference to a type that implements the Deref trait into a reference to another type.=
  e.g. convert &String to &str [[*String Slices as Parameters]]
  because =String implements the Deref trait such that it returns &str.=

=Deref coercion=
  works =only on types that implement the Deref trait.=
  =happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition.=

Deref coercion was added to Rust
  so that =programmers writing function and method calls don’t need to add as many explicit references and dereferences with & and *.=

src/main.rs
#+begin_src rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

fn hello(name: &str) {
    println!("Hello, {name}!");
}

fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
#+end_src

Deref coercion makes it possible to call hello with a reference to a value of type MyBox<String>
[[*The Slice Type a different kind of reference]]

Here we’re calling the hello function with the argument =&m, which is a reference to a MyBox<String> value.=
Because we =implemented the Deref trait on MyBox<T>=
Rust can =turn &MyBox<String> into &String by calling deref.=

=The standard library provides an implementation of Deref on String that returns a string slice=
Rust calls deref again to turn the &String into &str

If Rust didn’t implement =deref coercion=, we would have to write the code

src/main.rs
#+begin_src rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
#+end_src
=Deref coercion allows Rust to handle these conversions for us automatically.=

=When the Deref trait is defined for the types involved, Rust will analyze the types and use Deref::deref as many times as necessary to get a reference to match the parameter’s type.=

*** How Deref Coercion Interacts with Mutability

you can use the =DerefMut trait to override the * operator on mutable references.=

=From &T to &U when T: Deref<Target=U>=
=From &mut T to &mut U when T: DerefMut<Target=U>=
=From &mut T to &U when T: Deref<Target=U>=

=The third case is trickier: Rust will also coerce a mutable reference to an immutable one.=
=But the reverse is not possible=

Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn’t compile).
[[*Chapter 4 Rust’s ownership system]]
=Converting one mutable reference to one immutable reference will never break the borrowing rules.=
=Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don’t guarantee that.=

** Running Code on Cleanup with the Drop Trait

lets you =customize what happens when a value is about to go out of scope.=
=有点像cpp的析构函数=
that code can be used to release resources like files or network connections.
=the compiler will insert this code automatically=
=看深入理解cpp对象模型=

In some languages, for some types, the programmer must call code to free memory or resources every time they finish using an instance of those types.
Examples include file handles, sockets, or locks.
If they forget, the system might become overloaded and crash.

src/main.rs
#+begin_src rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
#+end_src

=The Drop trait is included in the prelude=
~cargo run~

=Variables are dropped in the reverse order of their creation, so d was dropped before c.=

*** Dropping a Value Early with std::mem::drop

=Unfortunately, it’s not straightforward to disable the automatic drop functionality.=

=Occasionally, however, you might want to clean up a value early.=
  e.g. using smart pointers that manage locks

=Rust doesn’t let you call the Drop trait’s drop method manually;=
=instead you have to call the std::mem::drop function provided by the standard library if you want to force a value to be dropped before the end of its scope.=

src/main.rs
#+begin_src rust
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop(); // ERROR Rust doesn’t let you call the Drop trait’s drop method manually;
    println!("CustomSmartPointer dropped before the end of main.");
}
#+end_src

=A destructor is analogous to a constructor, which creates an instance.=
The =drop= function in Rust is one particular destructor.

=This would cause a double free error=

use the =std::mem::drop= function.
The function is in the =prelude=

src/main.rs
#+begin_src rust
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}
#+end_src

** Rc<T>, the Reference Counted Smart Pointer

ownership is clear: you know exactly which variable owns a given value.
[[*Chapter 4 Rust’s ownership system]]

=However, there are cases when a single value might have multiple owners.=
  e.g.  in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it.
  A node shouldn’t be cleaned up unless it doesn’t have any edges pointing to it and so has no owners.

=Rc<T>= enable =multiple ownership=

reference counting

=Note that Rc<T> is only for use in single-threaded scenarios.=

how to do reference counting in multithreaded programs. [[*Chapter 16 walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly.]]

*** Using Rc<T> to Share Data

[[./pictures/rust/9.png]]

src/main.rs
#+begin_src rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a)); // ERROR value used here after move
}
#+end_src

=感觉可以把Box<T>想象成cpp的unique_ptr=
=Rc<T>想象成cpp的shared_ptr=

The Cons variants own the data they hold, so when we create the b list, a is moved into b and b owns a.
Then, when we try to use a again when creating c, we’re not allowed to because a has been moved.

src/main.rs
#+begin_src rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
#+end_src

We could change the definition of Cons to hold references instead, but then we would have to specify lifetime parameters.
=By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list.=
[[*Validating References with Lifetimes]]

=use statement to bring Rc<T> into scope because it’s not in the prelude.=
[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]
[[*Bringing Paths into Scope with the use Keyword]]

=We could have called a.clone() rather than Rc::clone(&a), but Rust’s convention is to use Rc::clone in this case.=
=The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do.=

*** Cloning an Rc<T> Increases the Reference Count

src/main.rs
#+begin_src rust
use std::rc::Rc;

enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let _b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let _c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
#+end_src

➜  example git:(master) ✗ cargo run 
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
warning: fields `0` and `1` are never read
 --> src/main.rs:4:10
  |
4 |     Cons(i32, Rc<List>),
  |     ---- ^^^  ^^^^^^^^
  |     |
  |     fields in this variant
  |
  = note: `#[warn(dead_code)]` on by default
help: consider changing the fields to be of unit type to suppress this warning while preserving the field numbering, or remove the fields
  |
4 |     Cons((), ()),
  |          ~~  ~~

warning: `example` (bin "example") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.09s
     Running `target/debug/example`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2

=This function is named strong_count rather than count because the Rc<T> type also has a weak_count;=
=the implementation of the Drop trait decreases the reference count automatically when an Rc<T> value goes out of scope.=

=Using Rc<T> allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.=

=multiple mutable borrows to the same place can cause data races and inconsistencies.=
[[*Chapter 4 Rust’s ownership system]]

the =RefCell<T>= type that you can use in conjunction with an =Rc<T>= to work with this immutability restriction.

** RefCell<T> and the Interior Mutability Pattern

=Interior mutability= is a design pattern in Rust that =allows you to mutate data even when there are immutable references to that data;=
[[*Chapter 4 Rust’s ownership system]]

To mutate data, the pattern uses =unsafe code= inside a data structure to bend Rust’s usual rules

=RefCell<T> type= that follows the =interior mutability= pattern.

*** Enforcing Borrowing Rules at Runtime with RefCell<T>

the =RefCell<T>= type represents =single ownership= over the data it holds

=At any given time, you can have either (but not both) one mutable reference or any number of immutable references.=
=References must always be valid=
[[*Chapter 4 Rust’s ownership system]]

With references and =Box<T>, the borrowing rules’ invariants are enforced at compile time.=
With =RefCell<T>=, these =invariants are enforced at runtime.=
With =references=, if you break these rules, you’ll get a =compiler error.=
With =RefCell<T>=, if you break these rules, your program will =panic and exit.(runtime)=

The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand.
checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust’s default.

The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, where they would’ve been disallowed by the compile-time checks.

Because some analysis is impossible, if the Rust compiler can’t be sure the code complies with the ownership rules, it might reject a correct program;
in this way, it’s conservative.

=RefCell<T> is only for use in single-threaded scenarios=
We’ll talk about how to get the functionality of RefCell<T> in a multithreaded program in Chapter 16. [[*Chapter 16 walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly.]]

=Rc<T>= enables =multiple owners of the same data=; =Box<T> and RefCell<T>= have =single owners.=
=Box<T> allows immutable or mutable borrows checked at compile time;Rc<T> allows only immutable borrows checked at compile time; RefCell<T> allows immutable or mutable borrows checked at runtime.=
Because =RefCell<T> allows mutable borrows checked at runtime,= you can =mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.=

=Mutating the value inside an immutable value= is the =interior mutability pattern.=

*** Interior Mutability: A Mutable Borrow to an Immutable Value

=when you have an immutable value, you can’t borrow it mutably.=

src/main.rs
#+begin_src rust
fn main() {
    let x = 5;
    let y = &mut x; // ERROR
}
#+end_src

However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code.

=Using RefCell<T> is one way to get the ability to have interior mutability,=
but RefCell<T> doesn’t get around the borrowing rules completely
  =the borrow checker in the compiler allows this interior mutability=
  and the borrowing rules are =checked at runtime instead.=
[[*The Borrow Checker]]

*** A Use Case for Interior Mutability: Mock Objects

=Mock objects= are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.
Rust doesn’t have mock object functionality built into the standard library as some other languages do.
However, =you can definitely create a struct that will serve the same purposes as a mock object.=

src/main.rs
#+begin_src rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
where
    T: Messenger,
{
    pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}
#+end_src

[[*Chapter 10 generics, traits, and lifetimes, which give you the power to define code that applies to multiple types]]

the Messenger trait has one method called send that takes an immutable reference to self and the text of the message.
we want to test the behavior of the set_value method on the LimitTracker.
We need a =mock object= that, instead of sending an email or text message when we call send, will only keep track of the messages it’s told to send.

src/main.rs
#+begin_src rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80); // ERROR self` is a `&` reference, so the data it refers to cannot be borrowed as mutable

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
#+end_src

We can’t modify the MockMessenger to keep track of the messages,
=because the send method takes an immutable reference to self.=

=also can’t take the suggestion from the error text to use &mut self in both the impl method and the trait definition.=
=We do not want to change the Messenger trait solely for the sake of testing.=

=interior mutability= can help!
=store the sent_messages within a RefCell<T>=,
and then the send method will be able to modify sent_messages to store the messages we’ve seen.

src/main.rs
#+begin_src rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
#+end_src

~borrow_mut~
to get a mutable reference to the value inside the RefCell<Vec<String>>, which is the vector.

~borrow~
on the RefCell<Vec<String>> to get an immutable reference to the vector.

[[*Chapter 4 Rust’s ownership system]]
[[*CHAPTER 5 structs and methods]]
[[*Chapter 7 Rust’s module system and about privacy rules for organizing your code and its public Application Programming Interface (API).]]

在测试中，如果你需要在一个 &self 的方法中修改对象的内部状态，就可以用 RefCell<T> 来启用“内部可变性”模式 —— 让你的 mock 对象记录行为而不破坏原有 trait 接口。

*** Keeping Track of Borrows at Runtime with RefCell<T>

When =creating immutable and mutable references, we use the & and &mut syntax=

With =RefCell<T>, we use the borrow and borrow_mut methods=, which are part of the safe API that belongs to RefCell<T>.
  The =borrow= method returns the smart pointer type =Ref<T>,=
  and =borrow_mut= returns the smart pointer type =RefMut<T>.=
  Both types implement =Deref trait=, so we can treat them like regular references.

The =RefCell<T>= keeps track of =how many Ref<T> and RefMut<T>= smart pointers are currently active.
  Every time we call =borrow=, the =RefCell<T> increases its count= of =how many immutable borrows= are active.
  When a =Ref<T>= value =goes out of scope=, the count of =immutable borrows= goes down by one.

=最重要的一句！！！=  
Just =like the compile-time borrowing rules, RefCell<T> lets us have many immutable borrows or one mutable borrow at any point in time.=
[[*Chapter 4 Rust’s ownership system]]
=注意RefCell<T>是runtime，而不是compile time=
=说明下面程序编译可以，但是运行会出错=

src/main.rs
#+begin_src rust
impl Messenger for MockMessenger {
    fn send(&self, message: &str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut(); // ERROR Just =like the compile-time borrowing rules, RefCell<T> lets us have many immutable borrows or one mutable borrow at any point in time.=

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
#+end_src

=RefCell<T> handles violations of the borrowing rules at runtime.=

 Also, your code would incur a small runtime performance penalty as a result of keeping track of the borrows at runtime rather than compile time.
 
*** Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T>

=A common way to use RefCell<T> is in combination with Rc<T>.=

=Rc<T>= lets you =have multiple owners of some data=, but =it only gives immutable access= to that data.
=RefCell<T>= to =gain the ability to change the values= in the lists.

src/main.rs
#+begin_src rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}
#+end_src

=We could have called a.clone() rather than Rc::clone(&a), but Rust’s convention is to use Rc::clone in this case.=
=The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do.=
[[*Rc<T>, the Reference Counted Smart Pointer]]

~value.borrow_mut()~
=automatic dereferencing feature=
=智能指针也是reference=
[[*Where’s the -> Operator?]]
~*value.borrow_mut()~ returns a RefMut<T> smart pointer, and we use the dereference operator on it and change the inner value.

=RefCell<T>= we have an outwardly immutable List value.
~borrow_mut()~ provide access to its interior mutability
=RefCell<T> does not work for multithreaded code!=
注意是check on runtime 而不是compile time
[[*Chapter 4 Rust’s ownership system]]
=Mutex<T> is the thread-safe version of RefCell<T>= [[*Chapter 16 walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly.]]

** Reference Cycles Can Leak Memory

=Rust allows memory leaks by using Rc<T> and RefCell<T>=: it’s possible to create references where items refer to each other in a cycle.
   This creates memory leaks because the reference count of each item in the cycle will never reach 0, and the values will never be dropped.

*** Creating a Reference Cycle

src/main.rs
#+begin_src rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
#+end_src

src/main.rs
#+begin_src rust
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}
#+end_src

=We could have called a.clone() rather than Rc::clone(&a), but Rust’s convention is to use Rc::clone in this case.=
=The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do.=
[[*Rc<T>, the Reference Counted Smart Pointer]]

~value.borrow_mut()~
=automatic dereferencing feature=
=智能指针也是reference=
[[*Where’s the -> Operator?]]
~*value.borrow_mut()~ returns a RefMut<T> smart pointer, and we use the dereference operator on it and change the inner value.

Rust vs C++ 对比：结构体/对象中引用字段
对比点	        Rust	              C++
引用字段	        支持，需生命周期标注     支持，必须在构造函数初始化
生命周期检查	编译器静态检查	      不检查，靠程序员约束
构造时初始化	可以字段赋值	      必须在构造函数初始化列表中初始化引用
是否允许空引用	不允许	              不允许（必须初始化）
默认实现派生支持	需实现 Copy/Clone 等   默认拷贝构造支持引用复制（浅拷贝）
安全性	        强，防悬垂引用、空引用 ️ 稍弱，容易产生悬垂指针、野引用

[[*Concise Control Flow with if let and let else]]

➜  src git:(master) ✗ cargo run  
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
warning: field `0` is never read
 --> src/main.rs:7:10
  |
7 |     Cons(i32, RefCell<Rc<List>>),
  |     ---- ^^^
  |     |
  |     field in this variant
  |
  = note: `List` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
  = note: `#[warn(dead_code)]` on by default
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
  |
7 |     Cons((), RefCell<Rc<List>>),
  |          ~~

warning: `example` (bin "example") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.85s
     Running `/Users/jieman/Desktop/projects/rust/example/target/debug/example`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2

[[./pictures/rust/10.png]]

If you uncomment the last println! and run the program, Rust will try to print this cycle with a pointing to b pointing to a and so forth =until it overflows the stack.=

Another solution for avoiding reference cycles is reorganizing your data structures =so that some references express ownership and some references don’t.=

*** Preventing Reference Cycles: Turning an Rc<T> into a Weak<T>

calling =Rc::clone= increases the =strong_count= of an =Rc<T>= instance
an =Rc<T>= instance is only cleaned up if its =strong_count= is 0.

create a =weak reference= to the value within an =Rc<T>= instance by calling =Rc::downgrade=
and passing a reference to the =Rc<T>=

=Strong references are how you can share ownership of an Rc<T> instance.=
Weak references don’t express an ownership relationship, and their count doesn’t affect when an Rc<T> instance is cleaned up.
=weak references will be broken once the strong reference count of values involved is 0.=

calling =Rc::downgrade= increases the =weak_count= by 1.
=Instead of increasing= the =strong_count= in the =Rc<T>= instance by 1,

The =Rc<T>= type uses =weak_count= to keep track of how many =Weak<T>= references exist, similar to =strong_count=.
=weak_count= doesn’t need to be =0= for the =Rc<T>= instance to be cleaned up.

Because the value that =Weak<T>= references =might have been dropped,=
calling the =upgrade= method on a =Weak<T>= instance, which will return an =Option<Rc<T>>.=

*** Creating a Tree Data Structure: a Node with Child Nodes

src/main.rs
#+begin_src rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
#+end_src

=We could have called a.clone() rather than Rc::clone(&a), but Rust’s convention is to use Rc::clone in this case.=
=The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do.=
[[*Rc<T>, the Reference Counted Smart Pointer]]

[[*Running Code on Cleanup with the Drop Trait]]
=Variables are dropped in the reverse order of their creation, so d was dropped before c.=

 but there’s no way to get from leaf to branch.
 
*** Adding a Reference from a Child to Its Parent

a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well.
a child should not own its parent: if we drop a child node, the parent should still exist. =This is a case for weak references!=

src/main.rs
#+begin_src rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}
#+end_src

~value.borrow_mut()~
=automatic dereferencing feature=
=智能指针也是reference=
[[*Where’s the -> Operator?]]
~*value.borrow_mut()~ returns a RefMut<T> smart pointer, and we use the dereference operator on it and change the inner value.

=We could have called a.clone() rather than Rc::clone(&a), but Rust’s convention is to use Rc::clone in this case.=
=The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do.=
[[*Rc<T>, the Reference Counted Smart Pointer]]

*** Visualizing Changes to strong_count and weak_count

src/main.rs
#+begin_src rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
#+end_src

=All of the logic that manages the counts and value dropping is built into Rc<T> and Weak<T> and their implementations of the Drop trait.=

* Chapter 16 walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly.

Many languages are dogmatic about the solutions they offer for handling concurrent problems.
  Erlang has elegant functionality for message-passing concurrency but has only obscure ways to share state between threads.

Supporting only a subset of possible solutions is a reasonable strategy for higher-level languages, because a higher-level language promises benefits from giving up some control to gain abstractions.
However, lower-level languages are expected to provide the solution with the best performance in any given situation and have fewer abstractions over the hardware.

** Using Threads to Run Code Simultaneously

In most current operating systems, an executed program’s code is run in a process, and the operating system will manage multiple processes at once.

For example, a web server could have multiple threads so that it could respond to more than one request at the same time.

=threads can run simultaneously=

This can lead to problems, such as:
  =Race conditions=, where threads are accessing data or resources in an inconsistent order
  =Deadlocks=, where two threads are waiting for each other, preventing both threads from continuing
  =Bugs= that happen only in certain situations and are hard to reproduce and fix reliably

Programming languages implement threads in a few different ways, and many operating systems provide an API the language can call for creating new threads.
  =The Rust standard library uses a 1:1 model of thread implementation=
  =There are crates that implement other models of threading that make different tradeoffs to the 1:1 model.=
    =Rust’s async system=

*** Creating a New Thread with spawn

src/main.rs
#+begin_src rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}
#+end_src

[[*Closures: Anonymous Functions that Capture Their Environment]]

=when the main thread of a Rust program completes, all spawned threads are shut down, whether or not they have finished running.=

operating system schedules the threads.

*** Waiting for All Threads to Finish Using join Handles

 fix the problem of the spawned thread not running or ending prematurely by =saving the return value of thread::spawn in a variable.=
 The return type of thread::spawn is =JoinHandle.=
 we call the =join= method on it, will wait for its thread to finish.

src/main.rs
#+begin_src rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
#+end_src

Calling join on the handle blocks the thread currently running until the thread represented by the handle terminates.

*** Using move Closures with Threads

often use the =move= keyword with closures passed to =thread::spawn=
because the closure will then =take ownership of the values it uses from the environment,=
thus transferring ownership of those values =from one thread to another.=

=force the closure to take ownership of the values it uses in the environment even= though the body of the closure doesn’t strictly need ownership
~move~ keyword
=is mostly useful when passing a closure to a new thread to move the data so that it’s owned by the new thread.!!!=
线程之间寄存器，栈独立 但是 页表，文件描述符数组等资源公用
具体看操作系统真相还原
[[*Capturing References or Moving Ownership]]

src/main.rs
#+begin_src rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}"); // ERROR  To use data from the main thread in the spawned thread, the spawned thread’s closure must capture the values it needs.
    });

    handle.join().unwrap();
}
#+end_src

=To use data from the main thread in the spawned thread, the spawned thread’s closure must capture the values it needs.=

=Rust infers how to capture v, and because println! only needs a reference to v, the closure tries to borrow v=
[[*Capturing References or Moving Ownership]]
[[*Moving Captured Values Out of Closures and the Fn Traits]]
However, there’s a problem:
  =Rust can’t tell how long the spawned thread will run, so it doesn’t know if the reference to v will always be valid.=

src/main.rs
#+begin_src rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    drop(v); // oh no! ERROR there’s a possibility the spawned thread would be immediately put in the background without running at all. 

    handle.join().unwrap();
}
#+end_src

src/main.rs
#+begin_src rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}
#+end_src

force the closure to take ownership of the values it’s using
rather than allowing Rust to infer that it should borrow the values.

If we added move to the closure, we would move v into the closure’s environment,
=and we could no longer call drop on it in the main thread.=

=By telling Rust to move ownership of v to the spawned thread, we’re guaranteeing Rust that the main thread won’t use v anymore.=

*** Using Message Passing to Transfer Data Between Threads

=One increasingly popular approach to ensuring safe concurrency is message passing,=
=where threads or actors communicate by sending each other messages containing data.=

the idea in a slogan from [[https://golang.org/doc/effective_go.html#concurrency][the Go language documentation]]
  “Do not communicate by sharing memory; instead, share memory by communicating.”

=A channel is a general programming concept by which data is sent from one thread to another.=

=A channel has two halves: a transmitter and a receiver.=

=A channel is said to be closed if either the transmitter or receiver half is dropped.=

src/main.rs
#+begin_src rust
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel(); // ERROR Rust can’t tell what type of values we want to send over the channel.
}
#+end_src

=mpsc stands for multiple producer, single consumer.=

=Rust’s standard library implements channels means a channel can have multiple sending ends that produce values=
=but only one receiving end that consumes those values.=

=mpsc::channel=
  returns a tuple, the first element of which is the sending end-the transmitter
  and the second element is the receiving end—the receiver

using a let statement with a pattern that destructures the tuples;
  [[*The Tuple Type]]

src/main.rs
#+begin_src rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}
#+end_src  

=using move to move tx into the closure so the spawned thread owns tx.=
=The send method returns a Result<T, E> type=,
  so if the receiver has already been dropped and there’s nowhere to send a value,
  the send operation will return an error.

~unwrap~
[[*Recoverable Errors with Result]]

src/main.rs
#+begin_src rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
#+end_src

The receiver has two useful methods: =recv and try_recv.=
  using recv, short for receive, which will =block= the main thread’s execution and wait until a value is sent down the channel.
  Once a value is =sent=, recv will return it in a =Result<T, E>.=
  =When the transmitter closes=, recv will =return an error= to signal that no more values will be coming.

  The =try_recv= method =doesn’t block=, but will instead =return a Result<T, E> immediately=
  an =Ok= value holding a message if one is available and
  an =Err= value if there aren’t any messages this time.

Using =try_recv= is useful if this thread has other work to do while waiting for messages:
=we could write a loop that calls try_recv every so often=, handles a message if one is available, and otherwise does other work for a little while until checking again.

*** Channels and Ownership Transference

=The ownership rules= play a vital role in message sending because they help you write safe, concurrent code.
[[*Chapter 4 Rust’s ownership system]]

src/main.rs
#+begin_src rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
#+end_src

=once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again.=
 Potentially, the other thread’s modifications could cause errors or unexpected results due to inconsistent or nonexistent data.

➜  src git:(master) ✗ cargo run
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
error[E0382]: borrow of moved value: `val`
  --> src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait                   
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `example` (bin "example") due to 1 previous error

=The send function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it.=

如果是你自己定义的类型，然后给它实现了 Copy 和 Clone，它的行为会和内置的 Copy 类型一样
发送时是“值拷贝”，不会 move 所有权，你可以继续使用这个值。

*** Sending Multiple Values and Seeing the Receiver Waiting

src/main.rs
#+begin_src rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}
#+end_src

=instead, we’re treating rx as an iterator.=
=When the channel is closed, iteration will end.=

*** Creating Multiple Producers by Cloning the Transmitter

=mpsc was an acronym for multiple producer, single consumer.=
=clone=
   This will give us a new transmitter

src/main.rs
#+begin_src rust
    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }

    // --snip--
#+end_src

** Shared-State Concurrency

for multiple threads to access the same shared data.

=Consider this part of the slogan from the Go language documentation again: “do not communicate by sharing memory.”=

=In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value.=
=Shared memory concurrency is like multiple ownership=  multiple threads can access the same memory location at the same time.
线程之间寄存器，栈独立 但是 页表，文件描述符数组等资源公用
具体看操作系统真相还原

Rust’s type system and ownership rules greatly assist in getting this management correct.

*** Using Mutexes to Allow Access to Data from One Thread at a Time

=Mutex is an abbreviation for mutual exclusion=

a mutex allows only one thread to access some data at any given time.

1.You must attempt to =acquire the lock= before using the data.
2.When you’re done with the data that the mutex guards, you =must unlock the data= so =other threads can acquire the lock.=

*** The API of Mutex<T>

src/main.rs
#+begin_src rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}
#+end_src

=lock= method to acquire the lock.
will =block= the current thread so it can’t do any work until it’s our turn to have the lock.
如果另一个持有锁的线程发生了 panic，那么再次调用 lock 会失败。
此时锁被“毒化”（poisoned），防止其他线程继续访问潜在不一致的数据。
所以我们使用 .unwrap() 来直接 panic，以简化处理。
=unwrap=

After we’ve acquired the lock, we can treat the return value, named num in this case, =as a mutable reference to the data inside.=
The type of =m= is =Mutex<i32>=, not i32, so we =must call lock= to be able to use the i32 value.

=Mutex<T> is a smart pointer.=
the call to =lock= returns a smart pointer called =MutexGuard=, wrapped in a =LockResult= that we handled with the call to =unwrap.=
The =MutexGuard= smart pointer =implements Deref= to point at our inner data;
the smart pointer also has a =Drop implementation= that releases the lock automatically when a =MutexGuard goes out of scope,=
[[*Treating Smart Pointers Like Regular References with the Deref Trait]]
[[*Running Code on Cleanup with the Drop Trait]]

~value.borrow_mut()~
=automatic dereferencing feature=
=智能指针也是reference=
[[*Where’s the -> Operator?]]
~*value.borrow_mut()~ returns a RefMut<T> smart pointer, and we use the dereference operator on it and change the inner value.

*** Sharing a Mutex<T> Between Multiple Threads

src/main.rs
#+begin_src rust
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
#+end_src

➜  src git:(master) ✗ cargo run 
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
error[E0382]: borrow of moved value: `counter`
  --> src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex<i32>`, which does not implement the `Copy` trait           
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop                                                              
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `example` (bin "example") due to 1 previous error

The error message states that the counter value was moved in the previous iteration of the loop.
=Rust is telling us that we can’t move the ownership of counter into multiple threads.=

*** Multiple Ownership with Multiple Threads

gave a value multiple owners by using the smart pointer Rc<T> to create a reference counted value.

src/main.rs
#+begin_src rust
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
#+end_src

➜  example git:(master) ✗ cargo run
   Compiling example v0.1.0 (/Users/jieman/Desktop/projects/rust/example)
error[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely
   --> src/main.rs:11:36
    |
11  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
    | |                      |
    | |                      required by a bound introduced by this call
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________^ `Rc<Mutex<i32>>` cannot be sent between threads safely
    |
    = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc<Mutex<i32>>`  
note: required because it's used within this closure
   --> src/main.rs:11:36
    |
11  |         let handle = thread::spawn(move || {
    |                                    ^^^^^^^
note: required by a bound in `spawn`
   --> /Users/jieman/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/thread/mod.rs:731:8
    |
728 | pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    |        ----- required by a bound in this function
...
731 |     F: Send + 'static,
    |        ^^^^ required by this bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `example` (bin "example") due to 1 previous error

=`Rc<Mutex<i32>>` cannot be sent between threads safely.=
=the trait `Send` is not implemented for `Rc<Mutex<i32>>`=
=it’s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.=
=Rc<T> is not safe to share across threads.=
When Rc<T> manages the reference count,
   it adds to the count for each call to clone
   subtracts from the count when each clone is dropped.
   =it doesn’t use any concurrency primitives to make sure that changes to the count can’t be interrupted by another thread.=

[[*Rc<T>, the Reference Counted Smart Pointer]]
=Using Rc<T> allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.=

*** Atomic Reference Counting with Arc<T>

=Arc<T> is a type like Rc<T> that is safe to use in concurrent situations.=

=a stands for atomic=
=Arc<T>, it’s an atomically reference counted type=

concurrency primitive
  [[https://doc.rust-lang.org/std/sync/atomic/index.html][std::sync::atomic]]

=atomics work like primitive types but are safe to share across threads.=

The reason why all primitive types aren’t atomic and why standard library types aren’t implemented to use Arc<T> by default.
  =thread safety comes with a performance penalty=

=Arc<T> and Rc<T> have the same API=  

src/main.rs
#+begin_src rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
#+end_src

https://doc.rust-lang.org/std/sync/atomic/index.html
=These types provide safe, concurrent, atomic access to primitive types.=

*** Similarities Between RefCell<T>/Rc<T> and Mutex<T>/Arc<T>

=Mutex<T> provides interior mutability, as the Cell family does.=
[[*RefCell<T> and the Interior Mutability Pattern]]

In the same way we used =RefCell<T>= to allow us to =mutate contents inside an Rc<T>=, we use =Mutex<T> to mutate contents inside an Arc<T>.=
[[*Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T>]]

using Rc<T> came with the risk of creating reference cycles, where two Rc<T> values refer to each other, causing memory leaks.
[[*Reference Cycles Can Leak Memory]]
=Similarly, Mutex<T> comes with the risk of creating deadlocks.=

** Extensible Concurrency with the Sync and Send Traits

two concurrency concepts are embedded in the language: =the std::marker traits Sync and Send.=

*** Allowing Transference of Ownership Between Threads with Send

The =Send marker trait= indicates =that ownership of values of the type implementing Send can be transferred between threads.=

=Almost every Rust type is Send=, but there are =some exceptions=, including =Rc<T>=
  Rc<T> is implemented for use in single-threaded situations
  where you don’t want to pay the thread-safe performance penalty.

=Rust’s type system and trait bounds ensure that you can never accidentally send an Rc<T> value across threads unsafely.=

=Any type composed entirely of Send types is automatically marked as Send as well=

Almost all primitive types are Send, aside from raw pointers, which we’ll discuss in Chapter 20.

*** Allowing Access from Multiple Threads with Sync

The =Sync marker trait= indicates that =it is safe for the type implementing Sync to be referenced from multiple threads.=

=any type T is Sync if &T (an immutable reference to T) is Send, meaning the reference can be sent safely to another thread.=

=primitive types are Sync, and types composed entirely of types that are Sync are also Sync.=

Rc<T> is also not Sync for the same reasons that it’s not Send.
RefCell<T> type and the family of related Cell<T> types are not Sync.
  =The implementation of borrow checking that RefCell<T> does at runtime is not thread-safe.=

Mutex<T> is Sync and can be used to share access with multiple threads  

*** Implementing Send and Sync Manually Is Unsafe

=Because types that are made up of Send and Sync traits are automatically also Send and Sync=
, we don’t have to implement those traits manually.

As =marker traits, they don’t even have any methods to implement.=

=Manually implementing these traits involves implementing unsafe Rust code.=

https://doc.rust-lang.org/nomicon/index.html

* Chapter 17 Rust’s async and await syntax and the lightweight concurrency model they support.

Modern computers offer two techniques for working on more than one operation at a time: =parallelism and concurrency.=

=asynchronous programming= where =operations may not finish sequentially in the order they were started.=

=Rust’s Futures, Streams, the async and await syntax=

the operating system’s invisible interrupts provide a form of concurrency.
  happens only at the level of the entire program
=从计算机执行程序的中断中考虑到语言中执行流的中断。。。=

CPU-bound（compute-bound）/ IO-bound

=In many cases, because we understand our programs at a much more granular level than the operating system does, we can spot opportunities for concurrency that the operating system can’t see.=
  avoid blocking our main thread by spawning a dedicated thread
  the overhead of those threads would eventually become a problem.
  It would be preferable if the call didn’t block in the first place.

Parallelism and Concurrency
  并行是同时做不同的任务
  并发是一段时间内做不同的任务，一个时刻只能做一个任务

并行和并发并不是完全独立的
  任务之间可能有依赖关系
  并发和并行可以同时存在
    Using tools such as threads, processes, and async, the computer can pause one activity and switch to others before eventually cycling back to that first activity again.
    On a machine with multiple CPU cores, it can also do work in parallel.

  async in Rust 是 并发
  但是结合操作系统 和 the async runtime 是并行

** Futures and the Async Syntax

=future= a value that may not be ready now but will become ready at some point in the future.
  对应其他语言中的task 和 promise

=Future= trait
  be implemented with different data structures
    =async 块 或者 函数 被编译为能保存 “当前状态” 和 实现 Future trait 的匿名结构体=
  but with a common interface.
    =poll= 方法

async 用于 ~{}~ 或者 ~fn~
  =async 块 或者 函数 被编译为能保存 “当前状态” 和 实现 Future trait 的匿名结构体=
  里面可以用 ~await~ 会被编译为对应的”状态“
  同时也是 “暂停” 和 “继续” 的位置

=Rust 的 async fn 本质是编译器生成的 状态机结构体 + Future 实现，=
=每个 .await 对应一个“暂停点”，整个函数会被转化为一个 poll() 推进的状态机。=

eg:
#+begin_src rust
async fn say_hello() -> u32 {
    println!("hello");
    42
}
#+end_src

编译器会把上面的 async fn 变成一个结构体 + impl Future 实现：

#+begin_src rust
struct SayHello {
    state: u8, // 状态机当前状态
    // 局部变量，比如 println! 等等
}

impl Future for SayHello {
    type Output = u32;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<u32> {
        match self.state {
            0 => {
                println!("hello");
                self.state = 1;
                Poll::Ready(42)
            }
            _ => Poll::Pending,
        }
    }
}
#+end_src

每一个 .await 语句，都会让编译器：
  插入一个状态编号（state = n）
  保存当前所有的局部变量到结构体字段中（防止中断后丢失）
  在下次 poll() 时跳回这个状态
  如果子 Future 还没准备好 → 返回 Poll::Pending
  准备好 → 执行下一段逻辑

#+begin_src rust
async fn run() {
    let a = get_a().await;
    let b = get_b().await;
    println!("{a}, {b}");
}
#+end_src

译器生成的状态机会有：
  状态 0：调用 get_a() → await → 返回 Pending
  状态 1：获取 a，调用 get_b() → await → 返回 Pending
  状态 2：获取 b → 打印输出 → Ready

.await = 调用子 Future 的 .poll() 方法，直到它返回 Poll::Ready(val)。
  实际上就是：把一个子任务（即另一个 Future）传给当前任务的状态机，调用它的 .poll() 方法，等待它完成。
    当前 async fn 是一个 Future（比如我们叫它 FutureA）
    它内部调用了另一个 async fn（我们叫它 FutureB）
    当 FutureA 遇到 future_b.await，它就会暂停自身的 poll，转而 poll FutureB
    只有当 FutureB 返回 Poll::Ready(val)，FutureA 才能恢复执行，继续向下推进

  在此期间，它会注册一个 Waker（唤醒器）
  子任务完成时调用 waker.wake()，把当前任务重新塞回执行队列
  执行器负责再次 poll 它
所以 .await 本质是：注册唤醒器 → 返回 Pending → 等待被 poll → 恢复状态

Rust 的 Future trait
#+begin_src rust
trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}
#+end_src
  poll 是协作推进的：必须显式调用
  返回 Poll::Pending 表示“暂停”
  返回 Poll::Ready(val) 表示“完成”
  执行器就是不断调用 .poll() 推进这些状态机。

任务切换和异步怎么联系？
  Rust 的 async 是：
    栈外协程（stackless coroutine）
    每个 async fn 都是一个状态机结构体
    不保存整个调用栈，只保存必要变量和状态号
    所以它能实现“零开销调度”：
      没有内核切换、没有栈拷贝、没有上下文切换

为什么说 Rust async 是“零成本抽象”？
  编译期展开 → 没有 runtime 调度器
  每个 async fn 是个 struct，没有堆分配
  所有状态和数据都存在栈上的 struct 字段里
  没有运行时黑魔法，都是静态确定的

*** Our First Async Program

=trpl crate=
  re-exports all the types, traits, and functions you’ll need,
  primarily from the =futures= and =tokio= (=async runtime=) crates.

#+begin_src shell
cargo new hello-async
cd hello-async
cargo add trpl
#+end_src

*** Defining the page_title Function

src/main.rs
#+begin_src rust
use trpl::Html;

async fn page_title(url: &str) -> Option<String> {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&response_text)
        .select_first("title")
        .map(|title_element| title_element.inner_html())
}
#+end_src

=futures= in Rust are =lazy=
  they don’t do anything until you ask them to with the =await= keyword.

~select_first~ a given CSS selector

=Rust’s await keyword goes after the expression you’re awaiting,=
  =it makes chains of methods much nicer to work with.=

As a result, we can change the body of page_url_for to chain the trpl::get and text function calls together with await between them
#+begin_src rust
let response_text = trpl::get(url).await.text().await;
#+end_src

When Rust sees =a function marked with async=, it compiles =it into a non-async function whose body is an async block.=
An =async function’s return type= is =the type of the anonymous data type the compiler creates for that async block.=

#+begin_src rust
use trpl::Html;

async fn page_title(url: &str) -> Option<String> {
    let response_text = trpl::get(url).await.text().await;
    Html::parse(&response_text)
        .select_first("title")
        .map(|title_element| title_element.inner_html())
}
#+end_src

to

#+begin_src rust
use std::future::Future;
use trpl::Html;

fn page_title(url: &str) -> impl Future<Output = Option<String>> + '_ {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
#+end_src

=writing async fn is equivalent to writing a function that returns a future of the return type.=

编译期做的这些工作类似cpp 编译器会把 对象的构造函数，析构函数 和 多态调用展开后调用虚表中函数一样！！！

[[*Traits as Parameters]]
=blocks are expressions.=
  [[*Statements and Expressions]]

The new version of the function has a kind of =lifetime= we haven’t seen before in the output type: ='_.=
Because the function returns a future that refers to a reference—in this case, the reference from the url parameter—we need to tell Rust that we want that reference to be included. 
  [[*Validating References with Lifetimes]]
  =第一次出现这个语法=
  =+ '_ 是在 impl Trait 或 dyn Trait 类型上指定生命周期。=
  [[*Specifying Multiple Trait Bounds with the + Syntax]]

  写法完整地展开其实是：
  // 返回一个 future，这个 future 至少活得和参数 `url` 一样久
  ~fn page_title<'a>(url: &'a str) -> impl Future<Output = Option<String>> + 'a~

*** Determining a Single Page’s Title

https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html

#+begin_src rust
async fn main() { // ERROR Rust won’t let us mark the special main function as async.
    let args: Vec<String> = std::env::args().collect();
    let url = &args[1];
    match page_title(url).await {
        Some(title) => println!("The title for {url} was {title}"),
        None => println!("{url} had no title"),
    }
}
#+end_src

=The only place we can use the await keyword is in async functions or blocks=
=Rust won’t let us mark the special main function as async.=

=async code needs a runtime=
  a Rust crate that manages the details of executing asynchronous code.
A program’s =main= function can =initialize a runtime=, but it’s not a runtime itself.

Most languages that support async bundle a runtime, but Rust does not.
Instead, there are many different async runtimes available, each of which makes different tradeoffs suitable to the use case it targets.
=The crates that provide those runtimes also often supply async versions of common functionality such as file or network I/O.=

use the run function from the trpl crate
  takes a future as an argument and runs it to completion.
  calling run =sets up a runtime= that’s used to run the future passed in.
  Once the future completes, =run returns whatever value the future produced.=

#+begin_src rust
use trpl::Html;

async fn page_title(url: &str) -> Option<String> {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&response_text)
        .select_first("title")
        .map(|title_element| title_element.inner_html())
}

fn main() {
    let args: Vec<String> = std::env::args().collect();

    trpl::run(async {
        let url = &args[1];
        match page_title(url).await {
            Some(title) => println!("The title for {url} was {title}"),
            None => println!("{url} had no title"),
        }
    })
}
#+end_src

~cargo run -- https://www.rust-lang.org~

*** how futures work?

=Rust 的 async fn 本质是编译器生成的 状态机结构体 + Future 实现，=
=每个 .await 对应一个“暂停点”，整个函数会被转化为一个 poll() 推进的状态机。=

eg:
#+begin_src rust
async fn say_hello() -> u32 {
    println!("hello");
    42
}
#+end_src

编译器会把上面的 async fn 变成一个结构体 + impl Future 实现：

#+begin_src rust
struct SayHello {
    state: u8, // 状态机当前状态
    // 局部变量，比如 println! 等等
}

impl Future for SayHello {
    type Output = u32;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<u32> {
        match self.state {
            0 => {
                println!("hello");
                self.state = 1;
                Poll::Ready(42)
            }
            _ => Poll::Pending,
        }
    }
}
#+end_src

每一个 .await 语句，都会让编译器：
  插入一个状态编号（state = n）
  保存当前所有的局部变量到结构体字段中（防止中断后丢失）
  在下次 poll() 时跳回这个状态
  如果子 Future 还没准备好 → 返回 Poll::Pending
  准备好 → 执行下一段逻辑

#+begin_src rust
async fn run() {
    let a = get_a().await;
    let b = get_b().await;
    println!("{a}, {b}");
}
#+end_src

译器生成的状态机会有：
  状态 0：调用 get_a() → await → 返回 Pending
  状态 1：获取 a，调用 get_b() → await → 返回 Pending
  状态 2：获取 b → 打印输出 → Ready

.await = 调用子 Future 的 .poll() 方法，直到它返回 Poll::Ready(val)。
  实际上就是：把一个子任务（即另一个 Future）传给当前任务的状态机，调用它的 .poll() 方法，等待它完成。
    当前 async fn 是一个 Future（比如我们叫它 FutureA）
    它内部调用了另一个 async fn（我们叫它 FutureB）
    当 FutureA 遇到 future_b.await，它就会暂停自身的 poll，转而 poll FutureB
    只有当 FutureB 返回 Poll::Ready(val)，FutureA 才能恢复执行，继续向下推进

  在此期间，它会注册一个 Waker（唤醒器）
  子任务完成时调用 waker.wake()，把当前任务重新塞回执行队列
  执行器负责再次 poll 它
所以 .await 本质是：注册唤醒器 → 返回 Pending → 等待被 poll → 恢复状态

Rust 的 Future trait
#+begin_src rust
trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}
#+end_src
  poll 是协作推进的：必须显式调用
  返回 Poll::Pending 表示“暂停”
  返回 Poll::Ready(val) 表示“完成”
  执行器就是不断调用 .poll() 推进这些状态机。

任务切换和异步怎么联系？
  Rust 的 async 是：
    栈外协程（stackless coroutine）
    每个 async fn 都是一个状态机结构体
    不保存整个调用栈，只保存必要变量和状态号
    所以它能实现“零开销调度”：
      没有内核切换、没有栈拷贝、没有上下文切换

为什么说 Rust async 是“零成本抽象”？
  编译期展开 → 没有 runtime 调度器
  每个 async fn 是个 struct，没有堆分配
  所有状态和数据都存在栈上的 struct 字段里
  没有运行时黑魔法，都是静态确定的

Each =await= point (code uses the =await= keyword) represents a place =where control is handed back to the runtime.=
=an invisible state machine,=
  as if you’d written an enum like this to save the current state at each await point
#+begin_src rust
enum PageTitleFuture<'a> {
    Initial { url: &'a str },
    GetAwaitPoint { url: &'a str },
    TextAwaitPoint { response: trpl::Response },
}
#+end_src

Writing the code to transition between each state by hand would be tedious and error-prone,
   especially when you need to add more functionality and more states to the code later.

=the Rust compiler creates and manages the state machine data structures for async code automatically=

=. The normal borrowing and ownership rules around data structures all still apply=

=runtime execute this state machine=
  This is why you may come across references to executors when looking into runtimes
  an executor is the part of a runtime responsible for executing the async code

=main is the starting point for the program!=

Some runtimes provide macros so you can write an async main function.
  Those macros rewrite async fn main() { ... } to be a normal fn main

*** Racing Our Two URLs Against Each Other

#+begin_src rust
use trpl::{Either, Html};

fn main() {
    let args: Vec<String> = std::env::args().collect();

    trpl::run(async {
        let title_fut_1 = page_title(&args[1]);
        let title_fut_2 = page_title(&args[2]);

        let (url, maybe_title) =
            match trpl::race(title_fut_1, title_fut_2).await {
                Either::Left(left) => left,
                Either::Right(right) => right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) => println!("Its page title is: '{title}'"),
            None => println!("Its title could not be parsed."),
        }
    })
}

async fn page_title(url: &str) -> (&str, Option<String>) {
    let text = trpl::get(url).await.text().await;
    let title = Html::parse(&text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}
#+end_src

futures are lazy
~trpl::race~
  returns a value to indicate which of the futures passed to it finishes first.

~race~ is built on a more general function, ~select~

#+begin_src rust
enum Either<A, B> {
    Left(A),
    Right(B),
}
#+end_src

** Applying Concurrency with Async

what’s different between threads and futures.
  they end up being quite different.
  they nearly always have different performance characteristics.

*** Creating a New Task with spawn_task

[[*Creating a New Thread with spaw]] was counting up on two separate threads.

#+begin_src rust
use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}
#+end_src

=the task spawned by spawn_task is shut down when the main function ends=

want it to run all the way to the task’s completion
  =use a join handle to wait for the first task to complete.=
  [[*Waiting for All Threads to Finish Using join Handles]]
    With threads, we used the join method to “block” until the thread was done running.
  =we can use await to do the same thing, because the task handle itself is a future.=

#+begin_src rust
use std::time::Duration;

fn main() {
    trpl::run(async {
        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
    })
}
#+end_src

using =await= instead of calling =join= on the join handle, and =awaiting the sleep calls.=
=The bigger difference is that we didn’t need to spawn another operating system thread to do this.=
=Because async blocks compile to anonymous futures, we can put each loop in an async block and have the runtime run them both to completion using the trpl::join function.=
[[*how futures work?]]

#+begin_src rust
use std::time::Duration;

fn main() {
    trpl::run(async {
        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
    })
}
  
#+end_src

~trpl::join~
  it produces a single new future whose output is a tuple containing the output of each future you passed in once they both complete.

trpl::join function is =fair=, meaning it checks each future equally often, never lets one race ahead if the other is ready.

With =threads, the operating system decides which thread to check and how long to let it run.=
With =async Rust, the runtime decides which task to check.=

*** Counting Up on Two Tasks Using Message Passing

[[*Using Message Passing to Transfer Data Between Threads]]

#+begin_src rust
fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("Got: {received}");
    })
}
#+end_src

~trpl::channel~
  an async version of the multiple-producer, single-consumer channel API we used with threads back in Chapter 16.
  difference with ~mpsc::channel~ :
    =it uses a mutable rather than an immutable receiver rx=
    =recv method produces a future we need to await rather than producing the value directly.=

all of this async code runs in an async block in a trpl::run call
  =everything within it can avoid blocking.=

=awit 是对 future 使用的，因为future是一个“保证”  对其await，收到结果都 runtime再将控制权给当前匿名结构体状态机=
[[*how futures work?]]

当前代码还是顺序执行

#+begin_src rust
use std::time::Duration;

fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
    })
}
#+end_src

~while let~ conditional loop:
  [[*Concise Control Flow with if let and let else]]

~rx.recv~ call produces a future, 所以能await
=awit 是对 future 使用的，因为future是一个“保证”  对其await，收到结果都 runtime再将控制权给当前匿名结构体状态机=
[[*how futures work?]]

1.the messages do not arrive at half-second intervals. They arrive all at once, 2 (2,000 milliseconds) after we start the program.
2.his program also never exits! Instead, it waits forever for new messages. CTRL-C to shutdown

#+begin_src rust
fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();
        let tx_fut = async {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
    })
}
#+end_src

The program still never exits, though, because of the way while let loop interacts with trpl::join
  The future returned from trpl::join completes only once both futures passed to it have completed.
  The tx future completes once it finishes sleeping after sending the last message in vals.
  The rx future won’t complete until the while let loop ends.
  The while let loop won’t end until awaiting rx.recv produces None.
  Awaiting rx.recv will return None only once the other end of the channel is closed.
  The channel will close only if we call rx.close or when the sender side, tx, is dropped.
  We don’t call rx.close anywhere, and tx won’t be dropped until the outermost async block passed to trpl::run ends.
  The block can’t end because it is blocked on trpl::join completing, which takes us back to the top of this list.

=We need some other way to make sure that tx gets dropped before the end of the function.=
  =Right now, the async block where we send the messages only borrows tx because sending a message doesn’t require ownership,=
  =but if we could move tx into that async block,=
  =it would be dropped once that block ends.=
  [[*Capturing References or Moving Ownership]]
  [[*Using move Closures with Threads]]
  The same basic dynamics apply to async blocks

#+begin_src rust
use std::time::Duration;

fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();
        let tx_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
    })
}
#+end_src

=This async channel is also a multiple-producer channel,=
=so we can call clone on tx if we want to send messages from multiple futures=
[[*Creating Multiple Producers by Cloning the Transmitter]]

#+begin_src rust
use std::time::Duration;

fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
    })
}
#+end_src

*** Working with Any Number of Futures

~join!~ a macro form of join to which we can pass an arbitrary number of arguments.
  ~trpl::join!(tx1_fut, tx_fut, rx_fut);~

In real-world Rust, though, pushing futures into a collection and then waiting on some or all the futures of them to complete is a common pattern.

~trpl::join_all~ function accepts any type that ~implements the Iterator trait~

#+begin_src rust
let futures = vec![tx1_fut, rx_fut, tx_fut];
trpl::join_all(futures).await; // ERROR 
#+end_src

=none of the async blocks returns anything, so each one produces a Future<Output = ()>.=
[[*The Tuple Type]]
=在 Rust 中，如果一个函数不返回任何有用的值，它其实返回的是 ()，也就是单元类型。=
compiler creates a unique enum for each async block.
  [[*how futures work?]]
=You can’t put two different hand-written structs in a Vec,=
=and the same rule applies to the different enums generated by the compiler.=
  [[*Using an Enum to Store Multiple Types]]
    We can’t do that here, though.
    we have no way to name the different types, because they are anonymous.
     the reason we reached for a vector and join_all in the first place was to be able to work with a dynamic collection of futures where we only care that they have the same output type.
=Using trait objects lets us treat each of the anonymous futures produced by these types as the same type, because all of them implement the Future trait.=
  [[*Returning Types That Implement Traits]]

#+begin_src rust
let futures =
    vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

trpl::join_all(futures).await; // ERROR type errors on the Box::new calls and Unpin errors
#+end_src

fix the type errors on the Box::new calls by explicitly annotating the type of the futures variable

#+begin_src rust
let futures: Vec<Box<dyn Future<Output = ()>>> =
    vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

trpl::join_all(futures).await; // ERROR Unpin errors
#+end_src

#+begin_src rust
let futures: Vec<Pin<Box<dyn Future<Output = ()>>>> =
    vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];

trpl::join_all(futures).await;
#+end_src

using Pin<Box<T>> adds a small amount of overhead from putting these futures on the heap with Box
=we’re only doing that to get the types to line up=
=We don’t actually need the heap allocation, after all: these futures are local to this particular function.=
=Pin is itself a wrapper type=
=use Pin directly with each future, using the std::pin::pin macro.=

#+begin_src rust
use std::{
    pin::{pin, Pin},
    time::Duration,
};

fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = pin!(async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        let rx_fut = pin!(async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        });

        let tx_fut = pin!(async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        });

        let futures: Vec<Pin<&mut dyn Future<Output = ()>>> = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
    })
}
#+end_src

=We got this far by ignoring the fact that we might have different Output types.=

#+begin_src rust
let a = async { 1u32 };
let b = async { "Hello!" };
let c = async { true };

let (a_result, b_result, c_result) = trpl::join!(a, b, c);
println!("{a_result}, {b_result}, {c_result}");
#+end_src

~trpl::join!~ it allows us to =pass in multiple future types= and =produces a tuple of those types.=

~trpl::join_all~ it requires all of the futures passed in to =have the same type.=

*** Racing Futures

~trpl::race~ to run two futures

#+begin_src rust
use std::time::Duration;

fn main() {
    trpl::run(async {
        let slow = async {
            println!("'slow' started.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' finished.");
        };

        let fast = async {
            println!("'fast' started.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' finished.");
        };

        trpl::race(slow, fast).await;
    })
}
#+end_src

=wait for one of them to finish.=
  not fair
  =runs the futures passed in as arguments in the order in which they’re passed.=

=Rust only pauses async blocks and hands control back to a runtime at an await point.=
  Everything between await points is synchronous.

*** Yielding Control to the Runtime

#+begin_src rust
fn slow(name: &str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}
#+end_src

will block the current thread

~yield_now~

#+begin_src rust
use std::{thread, time::Duration};

fn slow(name: &str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}

fn main() {
    trpl::run(async {
        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 35);
            trpl::yield_now().await;
            println!("'b' finished.");
        };

        trpl::race(a, b).await;
    })
}
#+end_src

=cooperative multitasking=
  where each future has the power to determine when it hands over control via await points
  =In some Rust-based embedded operating systems, this is the only kind of multitasking!=

*** Building Our Own Async Abstractions

build a =timeout= function with async building blocks we already have.

#+begin_src rust
use std::time::Duration;
use trpl::Either;

async fn timeout<F: Future>(future_to_try: F, max_time: Duration) -> Result<F::Output, Duration> {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) => Ok(output),
        Either::Right(_) => Err(max_time),
    }
}

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finally finished"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) => println!("Succeeded with '{message}'"),
            Err(duration) => {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
    });
}
#+end_src

=. For example, you can use this same approach to combine timeouts with retries, and in turn use those with operations such as network calls=

** Streams: Futures in Sequence

 The async recv method produces a sequence of items over time.
   [[*Counting Up on Two Tasks Using Message Passing]]

differences between iterators and the async channel receiver:
  1.iterators are synchronous, while the channel receiver is asynchronous.
  2.synchronous next method and asynchronous recv method

=. A stream is like an asynchronous form of iteration.=

in Rust means we can actually create a stream from any iterator.
#+begin_src rust
let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let iter = values.iter().map(|n| n * 2);
let mut stream = trpl::stream_from_iter(iter);

while let Some(value) = stream.next().await { // ERROR there’s no next method available
    println!("The value was: {value}");
}
#+end_src

=Stream trait= defines a low-level interface that effectively combines the Iterator and Future traits.
=StreamExt= supplies a higher-level set of APIs on top of Stream, including the next method as well as other utility methods similar to those provided by the Iterator trait.

#+begin_src rust
use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = 1..101;
        let iter = values.map(|n| n * 2);
        let stream = trpl::stream_from_iter(iter);

        let mut filtered =
            stream.filter(|value| value % 3 == 0 || value % 5 == 0);

        while let Some(value) = filtered.next().await {
            println!("The value was: {value}");
        }
    });
}
#+end_src

*** Composing Streams

Many concepts are naturally represented as streams:
  items becoming available in a queue, chunks of data being pulled incrementally from the filesystem
  data arriving over the network over time

=streams are futures=

For example,
  we can batch up events to avoid triggering too many network calls,
  set timeouts on sequences of long-running operations, or
  throttle user interface events to avoid doing needless work.

#+begin_src rust
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages = get_messages();

        while let Some(message) = messages.next().await {
            println!("{message}");
        }
    });
}

fn get_messages() -> impl Stream<Item = String> {
    let (tx, rx) = trpl::channel();

    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for message in messages {
        tx.send(format!("Message: '{message}'")).unwrap();
    }

    ReceiverStream::new(rx)
}
#+end_src

let’s add a feature that requires streams:
  =adding a timeout that applies to every item in the stream, and a delay on the items we emit=

#+begin_src rust
use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn get_messages() -> impl Stream<Item = String> {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            tx.send(format!("Message: '{message}'")).unwrap();
        }
    });

    ReceiverStream::new(rx)
}

fn main() {
    trpl::run(async {
        let mut messages =
            pin!(get_messages().timeout(Duration::from_millis(200)));

        while let Some(result) = messages.next().await {
            match result {
                Ok(message) => println!("{message}"),
                Err(reason) => eprintln!("Problem: {reason:?}"),
            }
        }
    })
}
#+end_src

=timeout method comes from the StreamExt trait.=

=pin! because the timeout helper produces a stream that needs to be pinned to be polled.=

=everything in a given future happens linearly;=
=awit 是对 future 使用的，因为future是一个“保证”  对其await，收到结果都 runtime再将控制权给当前匿名结构体状态机=
[[*how futures work?]]
=concurrency happens between futures.=

spawn a task to handle the async sleep calls.
[[*Applying Concurrency with Async]]

*** Merging Streams

#+begin_src rust
use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn get_intervals() -> impl Stream<Item = u32> {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;
            tx.send(count).unwrap();
        }
    });

    ReceiverStream::new(rx)
}

fn get_messages() -> impl Stream<Item = String> {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];

        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            if let Err(send_error) = tx.send(format!("Message: '{message}'")) {
                eprintln!("Cannot send message '{message}': {send_error}");
                break;
            }
        }
    });

    ReceiverStream::new(rx)
}

fn main() {
    trpl::run(async {
        let messages = get_messages().timeout(Duration::from_millis(200)); // type Timeout<impl Stream<Item = String>>
                                                                           // let intervals = get_intervals();
                                                                           // let merged = messages.merge(intervals); // ERROR because the two streams have different types.
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}")) //  transform to String
            .throttle(Duration::from_millis(100)) //  limiting the rate
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals).take(20);
        let mut stream = pin!(merged);

        while let Some(result) = stream.next().await {
            match result {
                Ok(message) => println!("{message}"),
                Err(reason) => eprintln!("Problem: {reason:?}"),
            }
        }
    })
}
#+end_src

=throttle call produces a new stream that wraps the original stream so that the original stream gets polled only at the throttle rate, not its own “native” rate.=

With both of these =channel-based streams=,
  =the send calls could fail when the other side of the channel closes=
  and that’s just a matter of how the runtime executes the futures that make up the stream.

[[*Concise Control Flow with if let and let else]]

** A Closer Look at the Traits for Async

*** The Future Trait

=awit 是对 future 使用的，因为future是一个“保证”  对其await，收到结果都 runtime再将控制权给当前匿名结构体状态机=
[[*how futures work?]]

#+begin_src rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
#+end_src

associated =type Output=
  analogous to the =Item= associated type for the =Iterator trait.=

takes a special =Pin reference for its self parameter=

=a mutable reference to a Context type=,

and returns a =Poll<Self::Output>.=

#+begin_src rust
enum Poll<T> {
    Ready(T),
    Pending,
}
#+end_src

The Pending variant indicates that the future still has work to do, so the caller will need to check again later.
The Ready variant indicates that the future has finished its work and the T value is available.

=When you see code that uses await, Rust compiles it under the hood to code that calls poll.=

#+begin_src rust
fn main() {
    let args: Vec<String> = std::env::args().collect();

    trpl::run(async {
        let url = &args[1];
        match page_title(url).await {
            Some(title) => println!("The title for {url} was {title}"),
            None => println!("{url} had no title"),
        }
    })
}
#+end_src

Rust compiles it into something kind of (although not exactly) like this:

#+begin_src rust
match page_title(url).poll() {
    Ready(page_title) => match page_title {
        Some(title) => println!("The title for {url} was {title}"),
        None => println!("{url} had no title"),
    }
    Pending => {
        // But what goes here?
    }
}
#+end_src

=What should we do when the future is still Pending? We need some way to try again, and again, and again, until the future is finally ready.=

#+begin_src rust
let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) => match page_title {
            Some(title) => println!("The title for {url} was {title}"),
            None => println!("{url} had no title"),
        }
        Pending => {
            // continue
        }
    }
}
#+end_src

Instead, Rust makes sure that the loop can hand off control to something that can pause work on this future to work on other futures
         and then check this one again later
         =that something is an async runtime=

=The runtime knows the future isn’t ready when it returns Poll::Pending.=
=the runtime knows the future is ready and advances it when poll returns Poll::Ready(Some(message)) or Poll::Ready(None).=
=a runtime polls each future it is responsible for, putting the future back to sleep when it is not yet ready.=

*** The Pin and Unpin Traits

Pin<T>：防止类型在内存中被移动
Rust 通常允许你随时移动数据（let a = b;）
但如果一个类型内部有对自己字段的引用（self-reference），一旦它被移动，内部的引用就会悬空，造成 未定义行为（UB）
Pin<T> 的意思就是：“我保证这个值在内存中不会再移动！”
Unpin：告诉编译器“我可以随意移动我自己”
大多数类型 自动实现了 Unpin
如果一个类型包含对自己字段的引用，那它是 !Unpin，也就是“不安全移动”的类型

=为何 Future 需要 Pin？=
Rust 的 Future 是一个状态机结构体，编译器会把 async 代码编译成带多个状态的 enum/struct：
#+begin_src rust
async fn foo() {
    let a = do_something().await;
    let b = do_something_else().await;
}

// to

enum FooFuture {
    State0,
    State1 { a },
    State2 { a, b },
}
#+end_src
如果 a 或 b 是 &mut T 或者引用了 self，那这些字段其实是指向自身结构体内某个字段的指针。
=一旦你把这个 Future 移动（比如 .push() 进 Vec），就有可能造成悬垂引用！=
所以：Rust 要求：你必须把 Future 固定住（pin），才能 .poll() 它。
poll(self: Pin<&mut Self>, ...)
→ 意思是：只有“被固定的” Future 才能被推进执行

类比理解：
Pin<T>	固定内存位置，类似 C++ 中 new 后禁止移动的对象
!Unpin	表示“不能用 memcpy 移动我”
poll()	类似推进状态机的 tick()

~trpl::join_all(futures).await;~

=Directly awaiting a future with await pins the future implicitly.=

Instead, we construct a new future, JoinAll, by passing a collection of futures to the join_all function.
The signature for join_all requires =that the types of the items in the collection all implement the Future trait=
                                    =and Box<T> implements Future only if the T it wraps is a future that implements the Unpin trait.=

#+begin_src rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // Required method
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
#+end_src

The cx parameter and its Context type are the key to =how a runtime actually knows when to check any given future while still being lazy.=

=Pin is a wrapper for pointer-like types such as &, &mut, Box, and Rc.=
Pin is not a pointer itself and doesn’t have any behavior of its own like Rc and Arc do with reference counting;
=it’s purely a tool the compiler can use to enforce constraints on pointer usage.=

=a series of await points in a future get compiled into a state machine=
=awit 是对 future 使用的，因为future是一个“保证”  对其await，收到结果都 runtime再将控制权给当前匿名结构体状态机=
[[*how futures work?]]
the compiler makes sure that state machine follows all of Rust’s normal rules around safety, including borrowing and ownership.
  Rust looks at what data is needed between one await point
  and either the next await point or the end of the async block.
  It then creates a corresponding variant in the compiled state machine.

When we want to =move around the future that corresponds to that block—like moving it into a Vec to pass to join_all= —things get trickier.
When we move a future
  whether by pushing it into a data structure to use as an iterator with join_all
  or by returning it from a function
  that =actually means moving the state machine Rust creates for us.=

=the futures Rust creates for async blocks can end up with references to themselves in the fields of any given variant=
[[./pictures/rust/11.png]]

=By default, though, any object that has a reference to itself is unsafe to move,=
=because references always point to the actual memory address of whatever they refer to=
  If you move the data structure itself,
   those internal references will be left pointing to the old location.
   However, that memory location is now invalid. 
[[./pictures/rust/12.png]]

=Theoretically, the Rust compiler could try to update every reference to an object whenever it gets moved, but that could add a lot of performance overhead=
编译器会自动加入对应的代码 类似cpp加上对象构造和析构的代码

=pin=
   it can no longer move.
   ~Pin<Box<SomeType>>~
   actually pin the SomeType value, not the Box pointer.
   [[./pictures/rust/13.png]]
   =In fact, the Box pointer can still move around freely.=
   [[./pictures/rust/14.png]]
   The key is that the self-referential type itself cannot move, because it is still pinned.

=only need to think about pinning when items have internal references.=

=Unpin is a marker trait,=
  similar to the Send and Sync traits we saw in Chapter 16,
  [[*Extensible Concurrency with the Sync and Send Traits]]
  thus has no functionality of its own.
  Unpin informs the compiler that a given type does not need to uphold any guarantees about whether the value in question can be safely moved.
  Just as with Send and Sync, =the compiler implements Unpin automatically for all types where it can prove it is safe.=
  ~impl !Unpin for SomeType~
  =Unpin 是一个标记 trait，意思是：“我这个类型，即使放在 Pin<T> 里，也可以安全地被移动。”=
  =async block 生成的匿名 Future 是 !Unpin，也就是不能移动的，因为它可能包含自引用！=
  =whether a type implements Unpin or !Unpin only matters when you’re using a pinned pointer to that type like Pin<&mut SomeType>.=

Future
.poll() 为啥必须 Pin<&mut Self>？
  .poll() 推进一个状态机（必须是可变的）
  如果 Future 是自引用类型，我们不能移动这个 self
  所以 poll() 明确要求：你要把 Future 用 Pin<&mut> 固定住再调用我

*** The Stream Trait

=streams are similar to asynchronous iterators=

=From Future, we have the idea of readiness over time: its poll method provides a Poll<Self::Output>.=
To represent a sequence of items that become ready over time, we define a Stream trait that puts those features together:

#+begin_src rust
use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>
    ) -> Poll<Option<Self::Item>>;
}
#+end_src

defines an associated type called Item for the type of the items produced by the stream.
The outer type is Poll, because it has to be checked for readiness, just as a future does.

#+begin_src rust
trait StreamExt: Stream {
    async fn next(&mut self) -> Option<Self::Item>
    where
        Self: Unpin;

    // other methods...
}
#+end_src

它通过 trait 默认实现，把 poll_next() 包装成一个 future，用户只需 await 即可。

~fn next(&mut self) -> Next<'_, Self> where Self: Unpin;~
  That Next type is a struct that implements Future and allows us to name the lifetime of the reference to self with Next<'_, Self>

** Putting It All Together: Futures, Tasks, and Threads

=threads provide one approach to concurrency.=

=In the async model, concurrent operations don’t require their own threads.=
  A task is managed by library-level code: the runtime.

#+begin_src rust
fn get_intervals() -> impl Stream<Item = u32> {
    let (tx, rx) = trpl::channel();

    // This is *not* `trpl::spawn` but `std::thread::spawn`!
    thread::spawn(move || {
        let mut count = 0;
        loop {
            // Likewise, this is *not* `trpl::sleep` but `std::thread::sleep`!
            thread::sleep(Duration::from_millis(1));
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}
#+end_src

Threads act as a boundary for sets of synchronous operations;
  concurrency is possible between threads.
Tasks act as a boundary for sets of asynchronous operations;
  concurrency is possible both between and within tasks, because a task can switch between futures in its body.
  =The runtime—specifically, its executor—manages tasks, and tasks manage futures.=
  =tasks can (at least in some runtimes) be moved around between threads.=

=If the work is very parallelizable, such as processing a bunch of data where each part can be processed separately, threads are a better choice.=
=If the work is very concurrent, such as handling messages from a bunch of different sources that may come in at different intervals or different rates, async is a better choice.=

#+begin_src rust
use std::{thread, time::Duration};

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::run(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}
#+end_src

To return to the scenario we opened the chapter with, imagine running a set of video encoding tasks using a dedicated thread (because video encoding is compute-bound) but notifying the UI that those operations are done with an async channel.

* Chapter 18 how Rust idioms compare to object-oriented programming principles you might be familiar with.

** Characteristics of Object-Oriented Languages

Rust is influenced by many programming paradigms, including OOP;

namely objects, encapsulation, and inheritance.

*** Objects Contain Data and Behavior

Object-oriented programs are made up of objects.

An object packages both data and the procedures that operate on that data.

The procedures are typically called methods or operations.

Using this definition, Rust is object-oriented: structs and enums have data, and impl blocks provide methods on structs and enums.

*** Encapsulation that Hides Implementation Details

we can use the pub keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private.
[[*Bringing Paths into Scope with the use Keyword]]

#+begin_src rust
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
#+end_src

=The struct is marked pub so that other code can use it, but the fields within the struct remain private.=

#+begin_src rust
impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            }
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
#+end_src

*** Inheritance as a Type System and as Code Sharing

Inheritance is a mechanism whereby an object can inherit elements from another object’s definition, thus gaining the parent object’s data and behavior without you having to define them again.

Rust中没有继承关键字

There is no way to define a struct that inherits the parent struct’s fields and method implementations =without using a macro.=

You would choose inheritance for two main reasons.
  One is for reuse of code
    =You can do this in a limited way in Rust code using default trait method implementations=
    [[*Default Implementations]]
    We can also override the default implementation of the summarize method when we implement the Summary trait, which is similar to a child class overriding the implementation of a method inherited from a parent class.
  The other reason to use inheritance relates to the type system
    =to enable a child type to be used in the same places as the parent type.=
    =polymorphism=

Rust instead uses generics to abstract over different possible types and trait bounds to impose constraints on what those types must provide.
This is sometimes called bounded parametric polymorphism.

=Rust takes the different approach of using trait objects instead of inheritance.=

** Using Trait Objects That Allow for Values of Different Types

one limitation of vectors is that they can store elements of only one type.
[[*Using an Enum to Store Multiple Types]]

*** Defining a Trait for Common Behavior

define a trait named Draw,  will have one method named draw.

define a vector that takes a =trait object.=

=A trait object points to both an instance of a type implementing our specified trait and a table used to look up trait methods on that type at runtime.=
=虚表 看深入理解cpp对象模型 cpp中的多态只能是指针或者引用 维护虚表指向实际的地址=
=create a trait object by specifying some sort of pointer, such as a & reference or a Box<T> smart pointer, then the dyn keyword, and then specifying the relevant trait.=
这里可以看出Rust同理

=use trait objects in place of a generic or concrete type.=
  Rust’s type system will ensure at compile time that any value used in that context will implement the trait object’s trait.

=trait objects are more like objects in other languages in the sense that they combine data and behavior.=
=we can’t add data to a trait object.=

~cargo new --lib draw~
[[*Traits: Defining Shared Behavior]]

src/lib.rs
#+begin_src rust
pub trait Draw {
    fn draw(&self);
}

pub struct Screen {
    pub components: Vec<Box<dyn Draw>>, // Box<dyn Draw>, which is a trait object
                                        // it’s a stand-in for any type inside a Box that implements the Draw trait.
}

impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#+end_src

=This works differently from defining a struct that uses a generic type parameter with trait bounds.=
=A generic type parameter can only be substituted with one concrete type at a time,=
whereas =trait objects allow for multiple concrete types to fill in for the trait object at runtime.=

src/lib.rs
#+begin_src rust
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#+end_src

[[*Traits: Defining Shared Behavior]]

*** Implementing the Trait

#+begin_src rust
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // code to actually draw a button
    }
}

use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // code to actually draw a select box
    }
}
#+end_src

src/main.rs
#+begin_src rust
use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}
#+end_src

The advantage of using trait objects and Rust’s type system to write code similar to code using duck typing
Rust won’t compile our code if the values don’t implement the traits that the trait objects need.

*** Trait Objects Perform Dynamic Dispatch

https://doc.rust-lang.org/book/ch10-01-syntax.html#performance-of-code-using-generics
[[*Performance of Code Using Generics]]
cpp在编译时期生成对应代码
static dispatch

use trait objects, Rust must use dynamic dispatch. 
=Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call.=
深入理解cpp对象模型
https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility

** Implementing an Object-Oriented Design Pattern

Rust 中经典的 状态模式（State Pattern）
  在不使用枚举（enum）的情况下，通过 trait + Box + 多个结构体 表示一个状态机，并实现“状态间的转换”。

=The state pattern= is an object-oriented design pattern.
  The crux of the pattern is that we define a set of states a value can have internally.

The advantage of using the state pattern is that, when the business requirements of the program change, we won’t need to change the code of the value holding the state or the code that uses the value.
  We’ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects.

src/main.rs
#+begin_src rust
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}
#+end_src

*** Defining Post and Creating a New Instance in the Draft State

#+begin_src rust
pub struct Post {
    state: Option<Box<dyn State>>, // private field
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }

    pub fn add_text(&mut self, text: &str) { // Storing the Text of the Post Content
        self.content.push_str(text);
    }

    pub fn content(&self) -> &str {  // Ensuring the Content of a Draft Post Is Empty
        ""
    }
}

trait State {} //  make a private State trait

struct Draft {}

impl State for Draft {}
#+end_src

[[*Bringing Paths into Scope with the use Keyword]]

*** Requesting a Review of the Post Changes Its State

#+begin_src rust
impl Post {
    // --snip--
    pub fn request_review(&mut self) {
        // This is where the Option in the state field of Post comes in: we call the take method to take the Some value out of the state field and leave a None in its place, because Rust doesn’t let us have unpopulated fields in structs.
        if let Some(s) = self.state.take() {  
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> { // This syntax means the method is only valid when called on a Box holding the type. 
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
#+end_src

[[*Concise Control Flow with if let and let else]]

状态使用 Option<Box<dyn State>>，是为了在状态切换时临时把值移动出去（Rust 不允许部分移动结构体字段）。
.take() 把值从 Option 里拿出来，留下 None。
再把新状态塞回去。
这个设计符合“状态模式”的核心思想：状态转移逻辑由状态本身决定，而不是中心控制器（Post）硬编码决定。

*** Adding approve to Change the Behavior of content

#+begin_src rust
impl Post {
    // --snip--
    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    // --snip--
    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
#+end_src

Now we need to update the content method on Post.
We want the value returned from content to depend on the current state of the Post,
so we’re going to have the Post delegate to a content method defined on its state

#+begin_src rust
impl Post {
    // --snip--
    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self) // Because state is an Option<Box<dyn State>>, when we call as_ref, an Option<&Box<dyn State>> is returned.
    }
    // --snip--
}

trait State {
    // --snip--
    fn content<'a>(&self, post: &'a Post) -> &'a str { // default implementation
        ""
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}
#+end_src

[[*Validating References with Lifetimes]]
We’re taking a reference to a post as an argument and returning a reference to part of that post,
so the lifetime of the returned reference is related to the lifetime of the post argument.

=Why Not An Enum?=
=One disadvantage of using an enum is every place that checks the value of the enum will need a match expression or similar to handle every possible variant.=
=This could get more repetitive than this trait object solution.=

*** Trade-offs of the State Pattern

With the =state pattern,=
the Post methods and the places we use Post =don’t need match expressions,=
and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.

One downside of the state pattern is that,
  because the states implement the transitions between states,
  =some of the states are coupled to each other.=

Another downside is that we’ve =duplicated some logic.=
  To eliminate some of the duplication, we might try to make default implementations
  however, this would not be dyn compatible,

If we had a lot of methods on Post that followed this pattern, we might consider =defining a macro to eliminate the repetition= (see the “Macros” section in Chapter 20).

=By implementing the state pattern exactly as it’s defined for object-oriented languages, we’re not taking as full advantage of Rust’s strengths as we could.=

*** Encoding States and Behavior as Types

#+begin_src rust
fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
}
#+end_src

#+begin_src rust
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
#+end_src

We still have a Post::new function, but instead of returning an instance of Post, it returns an instance of DraftPost. 

That way, if we try to get a draft post’s content, we’ll get a compiler error telling us the method doesn’t exist.

*** Implementing Transitions as Transformations into Different Types

#+begin_src rust
impl DraftPost {
    // --snip--
    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}
#+end_src

#+begin_src rust
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}
#+end_src

好处总结：类型系统保证正确流程
特性 | 好处
类型即状态 | 编译器限制只能在特定状态下调用某些方法（如 content）
转换必须走流程 | 没有跳过“审核”的可能性，不能直接构造 Post
状态之间互相转换消耗所有权 | 不可能残留无效状态对象（如一个还在用的 DraftPost）
不依赖动态分发 / trait object | 更轻量、无需 Box<dyn State>，无需运行时开销

限制 | 描述
类型太多 | 每个状态都要一个独立的结构体、方法多
失去面向对象封装性 | 状态转换逻辑不是由 Post 自己内部处理，而是“类型外显”
状态之间的共享代码不方便 | 不能用 trait 来抽象所有状态的共同行为（除非引入更多泛型）

项目 | trait object 方式 | 类型编码方式（本节）
状态封装性 | ✅ 好，状态对象内部封装自己的行为 | ❌ 状态直接暴露为不同类型
编译期保障 | ❌ 运行时错误才可能暴露 | ✅ 编译期保障非法行为永远不能出现
方法调用 | 动态分发，支持统一调用 | 只能在特定类型上调用
可组合性/扩展性 | ✅ 更灵活 | ❌ 状态之间高度耦合
性能 | 有 dyn 和 vtable，可能稍慢 | ✅ 零成本抽象、静态分发

* Chapter 19 patterns and pattern matching
* Chapter 20 a smorgasbord of advanced topics of interest, including unsafe Rust, macros, and more about lifetimes, traits, types, functions, and closures.
** Macros

 declarative macros with =macro_rules!=

 three kinds of =procedural macros:=
   =1.Custom #[derive] macros that specify code added with the derive attribute used on structs and enums=
   =2.Attribute-like macros that define custom attributes usable on any item=
   =3.Function-like macros that look like function calls but operate on the tokens specified as their argument=
   
*** The Difference Between Macros and Functions

=metaprogramming= macros are a way of writing code that writes other code

=derive= attribute =generates an implementation of various traits for you.=

=macros expand to produce more code than the code you’ve written manually.=

=Macros can take a variable number of parameters=
  println!("hello")
  println!("hello {}", name)
  c语言的printf 解析格式字符串，逐个读取变长参数（用 C 的 <stdarg.h> 宏机制）；
  编译器内建的 __builtin_* 函数，glibc 封装
  理论可以，但要处理 ABI、对齐、寄存器/栈等底层细节，极其复杂

=macros are expanded before the compiler interprets the meaning of the code=

a macro can, for example, implement a trait on a given type.
A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.

must define macros or bring them into scope before you call them in a file
=opposed to functions you can define anywhere and call anywhere.=

*** Declarative Macros with macro_rules! for General Metaprogramming

=similar to a Rust match expression=
  =More complex macros will have more than one arm.=

=macro_rules!= define a macro

~let v: Vec<u32> = vec![1, 2, 3];~

#+begin_src rust
#[macro_export] // indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope.
macro_rules! vec {  
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
#+end_src

First, we use =a set of parentheses to encompass the whole pattern.= ~(...)~

=$= to declare a variable that will contain the Rust code matching the pattern. ~$(...)~

Next comes =a set of parentheses that captures values= that =match the pattern within the parentheses= for use in the replacement code.
~()~ captures values that match the pattern =有点像正则表达式()来捕获match=
~$x:expr~ =matches any Rust expression and gives the expression the name $x.=

~,~  indicates that a literal comma separator character must appear between each instance of the code that matches the code within $().

~*~ specifies that the pattern matches zero or more of whatever precedes the *.
正则表达式中*也是0至多次

=$()* is generated for each part that matches $() in the pattern zero or more times=

#+begin_src rust
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
#+end_src

*** Procedural Macros for Generating Code from Attributes

=procedural macro= acts more like a function

=rather than matching against patterns= and replacing the code with other code as declarative macros do.

three kinds:
  =1.custom derive=
  =2.attribute-like=
  =3.function-like=

When creating procedural macros,
  =the definitions must reside in their own crate with a special crate type.= ~use proc-macro;~

#+begin_src rust
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
#+end_src

=some_attribute= s a placeholder for using a specific macro variety.

=TokenStream 是 proc_macro crate 提供的一个类型；=
=它表示“一串 Rust 语法标记（token）”;=
=输入一段代码 → 处理 → 输出另一段代码。=

=在函数上方使用 #[some_attribute] 来标记这个函数是哪种过程宏类型（比如自定义派生宏、属性宏等）；=

*** How to Write a Custom derive Macro

create a crate named hello_macro that defines a trait named HelloMacro with one associated function named hello_macro.

=Rather than making our users implement the HelloMacro trait for each of their types=
=provide a procedural macro so users can annotate their type with #[derive(HelloMacro)] to get a default implementation of the hello_macro function.=

The default implementation will print Hello, Macro! My name is TypeName!

~cargo new hello_marco --lib~

src/lib.rs
#+begin_src rust
pub trait HelloMacro {
    fn hello_macro();
}  
#+end_src

[[*Traits: Defining Shared Behavior]]

src/main.rs
#+begin_src rust
use hello_marco::HelloMarco;

struct Pancakes;

impl HelloMarco for Pancakes {
    fn hello_marco() {
        println!("Hello, Marco! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_marco();
}
#+end_src

we can’t yet provide the hello_macro function with default implementation that will print the name of the type the trait is implemented on
=Rust doesn’t have reflection capabilities=
=it can’t look up the type’s name at runtime.=

define the procedural macro
=procedural macros need to be in their own crate.=
=Eventually, this restriction might be lifted.=

for a crate named foo, a custom derive procedural macro crate is called foo_derive.
start a new crate called =hello_macro_derive= inside our =hello_macro= project

~hello_marco git:(master) ✗ cargo new hello_macro_derive --lib~

截至目前（写作时），过程宏必须放在一个单独的 crate 中。
将来这个限制可能会被取消。
对于一个名为 foo 的库：
  它的派生宏（#[derive(...)]）部分，通常会建在一个叫做 foo_derive 的 crate 中；
  这是社区推荐的结构命名方式，方便识别和维护。
hello_macro 定义了 trait（比如 HelloMacro）；
hello_macro_derive 实现了 #[derive(HelloMacro)] 这个过程宏；
所以如果修改了 trait，就得同步修改宏的实现。
=这两个 crate（hello_macro 和 hello_macro_derive）需要分别发布；=
=使用者在项目中需要分别添加依赖，并引入这两个 crate 才能使用；=

=declare the hello_macro_derive crate as a procedural macro crate.=
=need functionality from the syn and quote crates=

hello_macro_derive/Cargo.toml
#+begin_src toml
[package]
name = "hello_macro_derive"
version = "0.1.0"
edition = "2024"

[lib]
proc-marco = true

[dependencies]
syn = "2.0"
quote = "1.0"
#+end_src

src/lib.rs
#+begin_src rust
use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
#+end_src

=hello_macro_derive= is responsible for parsing the TokenStream
=impl_hello_macro= is responsible for =transforming the syntax tree=

=proc_macro= crate comes with Rust, didn’t need to add that to the dependencies in Cargo.toml.
  =the compiler’s API that allows us to read and manipulate Rust code from our code.=

=syn= crate
  =parses Rust code from a string into a data structure that we can perform operations on.=

=quote= crate
  =turns syn data structures back into Rust code.=

=hello_macro_derive=  function will be called =when a user of our library specifies #[derive(HelloMacro)] on a type.=
because we’ve =annotated the hello_macro_derive function here with proc_macro_derive and specified the name HelloMacro=, which matches our trait name;

=first converts the input from a TokenStream to a data structure that we can then interpret and perform operations on.=
=parse= function in =syn= takes a TokenStream and returns a =DeriveInput struct= representing the parsed Rust code.
downside shows the =relevant parts of the DeriveInput struct we get from parsing the struct Pancakes; string:=
#+begin_src
DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}  
#+end_src
[[https://docs.rs/syn/2.0/syn/struct.DeriveInput.html][syn documentation for DeriveInput]]

=impl_hello_macro= build the new Rust code we want to include.
The returned TokenStream is added to the code that our crate users write, so when they compile their crate, they’ll get the extra functionality that we provide in the modified TokenStream.

=unwrap= to cause the =hello_macro_derive= function to =panic= if the call to the =syn::parse= function fails here.

=It’s necessary for our procedural macro to panic on errors=
[[*CHAPTER 9 Rust’s error-handling philosophy and techniques.]]
you should provide more specific error messages about what went wrong by using =panic! or expect.=

=quote!= macro lets us =define the Rust code that we want to return.=

=into= =convert it to a TokenStream.=

=quote!= macro also provides some very cool templating mechanics: =we can enter #name, and quote! will replace it with the value in the variable name.=
[[https://docs.rs/quote][the quote crate’s docs]]

=stringify!= macro used here is built into Rust.
=It takes a Rust expression, such as 1 + 2, and at compile time turns the expression into a string literal, such as "1 + 2".=
=#name input might be an expression to print literally, so we use stringify!.=
Using stringify! =also saves an allocation by converting #name to a string literal at compile time.=

~cargo build~

Create a new binary project
~cargo new pancakes~
add =hello_macro and hello_macro_derive= as dependencies in the pancakes crate’s =Cargo.toml.=
  If you’re publishing your versions of hello_macro and hello_macro_derive to [[https://crates.io/][crates.io]], they would be regular dependencies;
  if not, you can specify them as =path= dependencies as follows:

Cargo.toml
#+begin_src toml
[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
#+end_src

src/main.rs
#+begin_src rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
#+end_src

~cargo run~

*** Attribute-like macros

=similar to custom derive macros=

=derive attribute= generating code

=this allow you to create new attributes.=

=derive only works for structs and enums;=

=attributes can be applied to other items as well, such as functions.=

#+begin_src rust
#[route(GET, "/")]
fn index() {
#+end_src

the macro definition function would look like this:

#+begin_src rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
#+end_src

=attribute-like macros work the same way as custom derive macros:=
=you create a crate with the proc-macro crate type=
=跟Custom derive Macro 一样 需要一个单独的 crate=

*** Function-like macros

define macros that look like function calls.

=Rust code as the other two types of procedural macros do.=

#+begin_src rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
#+end_src

defined like this:

#+begin_src rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
#+end_src

* Chapter 21 complete a project in which we’ll implement a low-level multithreaded web server!
* Appendix A Rust’s keywords
* Appendix B Rust’s operators and symbols
* Appendix C derivable traits provided by the standard library
* Appendix D some useful development tools




