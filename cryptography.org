#+title: cryptography
#+author: JIE MAN

“单向散列函数”可以检测出消息是否被篡改过
“数字签名”可以确认消息是否来自合法的发送者

* 密码
** 概述

[[./pictures/cryptography/2.png]]

*** 对称密码与公钥密码

对称密码（symmetric cryprography）是指在加密和解密时使用同一密钥的方式。

而公钥密码（public-key cryptography）则是指在加密和解密时使用不同密钥的方式。又称为非对称密码（asymmetric cryptography）

[[./pictures/cryptography/1.png]]

现代计算机和互联网中的安全体系，很大程度上都依赖于公钥密码。
*** 混合密码系统

将对称密码和公钥密码结合起来的密码方式称为混合密码系统（hybrid cryptosystem）， 系统结合了对称密码和公钥密码两者的优势。

*** 单向散列函数--完整性（integrity）

为了防止软件被篡改，有安全意识的软件发布者会在发布软件的同时发布该软件的散列值”。

散列值就是用单向散列函数（one-way hash function）计算出来的数值。

可以检测出数据是否被篡改过。

*** 消息认证码 -- 消息是否来自所期望的通信对象（完整性、认证机制）

不但能够确认消息是否被篡改，而且能够确认消息是否来自所期待的通信对象

*** 数字签名

一种能够确保完整性、提供认证并防止否认的密码技术。

*** 伪随机数生成器

伪随机数生成器（Pseudo Random Number Generator,PRNG） 是一种能够模拟产生随机数列的算法。

随机数确实承担着密钥生成的重要职责。

例如在Web 中进行SSL/TLS 通信时，会生成一个仅用于当前通信的临时密钥（会话密钥），这个密钥就是基于伪随机数生成器生成的。

*** 隐写术与数字水印

我—我们先准备一段话，
很—很容易看懂的就可以， 
喜—喜闻乐见的当然更好。
欢—欢迎你尝试将另一句话嵌在这段话中， 
你—你会发现这其实就是一种隐写术。

隐写术的目的是隐藏消息本身，但如果搞清楚了嵌人消息的方法，也就可以搞清楚消息的内容。
因此，隐写术并不能代替密码。

=密码隐藏的是内容，隐写术隐藏的是消息本身。=

数字水印是一种将著作权拥有者及购买者的信息嵌人文件中的技术。

=通过将密码与隐写术相结合，就可以同时产生两者所各自具备的效果。=

** 历史上的密码

历史上几种著名的密码。

• 恺撒密码
• 简单替换密码
• Enigma

两种破译密码的方法

• 暴力攻击
• 频率分析

*** 恺撒密码

将明文中所使用的字母表按照一定的字数“平移”来进行加密的。

在日语 （例如平假名）或者汉语（例如汉语拼音）中也可以用同样的思路来实现恺撒密码。

[[./pictures/cryptography/3.png]]

[[./pictures/cryptography/4.png]]

[[./pictures/cryptography/5.png]]

*** 用暴力破解来破译密码 -- 穷举搜索 （exhaustive search ）。

在恺撒密码中，密钥就是字母表平移的字数。

由于字母表只有26个字母，因此加密用的密钥只有0到25共26种（平移0个字母实际上相当于没有加密，但在这里我们也将这种情况考虑进去）。

=按顺序将这26种密钥都尝试一遍。=

*** 简单替换密码

如果我们将字母表中的26个字母，分别与这26 个字母本身建立一对一的对应关系。

这种将明文中所使用的字母表替换另一套字母表的密码称为简单替换密码 ( simple substitution cipher ).

[[*恺撒密码]]也可以说是简单替换密码的一种。

[[./pictures/cryptography/6.png]]

*** 简单替换密码的密钥空间

=简单替换密码很难通过暴力破解来破译=
  简单替换密码中可以使用的密钥数量，比恺撒密码要多得多。

“所有密钥的集合” 称为密钥空间（keyspace）
  密钥空间越大，暴力破解就越困难。

简单替换密码的密钥总数为：$26 \times 25 \times 24 \times 23 \times \dots \times 1 = 403291461126605635584000000$

*** 用频率分析来破译密码

能够破译简单替换密码。

=利用了明文中的字母的出现频率与密文中的字母的出现频率一致这一特性。=
  一般的英语文章中出现频率最高的字母是e

+

=英语常用词(语义)=

来假设替换表

*** Enigma

[[./pictures/cryptography/7.png]]

Enigma 的构造

[[./pictures/cryptography/8.png]]

每当按下 Enigma上的一个键，就会点亮一个灯泡。

只要将键和灯泡的读法互换一下，在Enigma上就可以用完全相同的方法来完成加密和解密两种操作了。

接线板（plugboard）是一种通过改变接线方式来改变字母对应关系的部件。
  接线板上的接线方式是根据国防军密码本的每日密码来决定的，在一天之中不会改变。

转子是一个圆盘状的装置，其两侧的接触点之间通过电线相连。
  尽管每个转子内部的接线方式是无法改变的，但转子可以在每输入一个字母时自动旋转。
  当输入一个字母时，转子1就旋转1/4圈（当字母表中只有4个字母时）。
  转子1每旋转1圈，转子2就旋转1/4圈，而转子2每旋转1圈，转子3就旋转1/4 圈。
  这3个转子都是可以拆卸的，在对 Enigma进行设置时可以选择转子的顺序以及它们的初始位置。

[[./pictures/cryptography/9.png]]

=固定abcd点 轮盘内的线路 ABCD点=

Enigma 的加密

[[./pictures/cryptography/10.png]]

1.设置 Enigma
  发送者查阅国防军密码本，找到当天的每日密码，并按照该密码来设置 Enigma。
  就是在接线板上接线，并将3个转子进行排列。
2.加密通信密码
  想出3个字母，并将其加密。这3个字母称为通信密码。
  发送者选择的通信密码力psv，则发送者需要在 Enigma 的键盘上输人两次该通信密码。
  发送者每输入一个字母，转子就会旋转，同时灯泡亮起，发送者记下亮起的灯泡所对应的字母。输人全部6个字母之后，发送者就记下了它们所对应的密文。
3.重新设置 Enigma
  发送者根据通信密码重新设置 Enigma。
  通信密码中的3个字母实际上代表了3个转子的初始位置。每一个转子的上面都印有字母，可以根据字母来设置转子的初始位置。
  通信密码psv 就表示需要将转子1、2、3分别转到 p、s、v所对应的位置。
4.加密消息
  发送者将消息（明文）逐字从键盘输入，然后从灯泡中读取所对应的字母并记录下来。
5.拼接
  将“加密后的通信密码” + “加密后的消息”
  通过无线电发送出去。

  
=密钥：每日密码 和 通信密码=
  每日密码不是用来加密消息的，而是用来加密通信密码的。
    =加密密钥的密钥=
    =密钥加密密钥（Key Encrypting Key, KEK）。=

  通信密码来加密消息，用每日密码来加密通信密码

=避免通信错误=
  将通信密码 psv 连续输入两次
  无线电的质量很差，可能会发生通信错误。
  通过连续输人两次通信密码（psvpsv），接收者就可以对通信密码进行校验

Enigma 的解密

[[./pictures/cryptography/11.png]]

1.分解
  将接收到的电文分解成两个部分 : 加密后的通信密码 + 加密后的消息
2.设置Enigma
  接收者查阅国防军密码本中的每日密码，并按照该密码设置 Enigma，和发送者进行操作相同。
3.解密通信密码
  将加密后的通信密码 ATCDVT进行解密。
  在 Enigma的键盘上输人 ATCDVT这6个字母，然后将亮起的灯泡对应的字母 psvpsv记下来。
    看Enigma的构造图
  重复的通信密码还可以判断在通信过程中是否发生错误。
4.重新设置 Enigma
  接收者根据通信密码 psv 重新设置 Enigma。
5.解密消息
  接收者将电文的剩余部分 KXNWP逐一用键盘输入，然后从灯泡读取结果并记下来，这样接收者就得到了 nacht 这5个字母，也就是完成了对发送者发送的消息进行解密的过程。

  
Enigma 的弱点
  1.Enigma 可以在每次输入时，通过3个转子的旋转来改变电路。
    然而，在加密通信密码这一重要步骤（最开始的6次输入）中，实际上只有转子1会旋转，这就是 Enigma 的弱点之一。
  2.将通信密码连续输入两次并加密，因为密码破译者可以知道，密文开头的6 个字母被解密之后的明文一定是3个字母重复两次的形式。
  3.通信密码是人为选定的
    =密码系统中使用的密钥不能是人为选定的，而应该使用无法预测的随机数来生成。=
  4.必须派发国防军密码本

Enigma 的破译
  由于每日密码在一天之中是不会改变的，因此密码破译者一天内所截获的所有通信，都是用同一个密码进行加密的。
  而且，这些密文都有一个共同的特点，那就是通信密码都会重复两次。
  =在第1个字母和第4个字母的加密过程中，转子1旋转了3/26圈。(26个英文字母转一圈)=
  3个转子的顺序共有3×2×1=6种可能，3个转子的旋转位置共有26×26×26=17576种组合。
    雷耶夫斯基制作了6台机器，分别对这17576种组合进行检查。通过使用这些机器，他在大约两小时内通过大量的密文找到了每日密码。

*** 为什么要将密码算法和密钥分开呢

恺撒密码
  密码算法：将明文中的各个字母按照指定的字母数平移
  密钥：平移的字母数量

简单替换密码
  密码算法：按照替换表对字母表进行替换
  密钥：替换表

Enigma（通信密码的加密）
  密码算法：使用Enigma 密码机，通过接线板的接线方式、3个转子的顺序、每个转子的旋转位置对字母进行替换
  密钥（每日密码）：接线板的接线方式、3个转子的顺序、每个转子的旋转位置

Enigma（通信电文的加密）
  密码算法：使用接线板的接线方式和3个转子的顺序固定的Enigma 密码机，按照每个转子的旋转位置对字母进行替换
  密钥（通信密码）：每个转子的旋转位置

  
=在密码算法中必然存在可变部分， 而这些可变部分就相当于密钥。=

=将密码算法和密钥分开考虑，就解决了希望重复使用，但重复使用会增加风险这个难题。=

** 对称密码（共享密钥密码） — 用相同的密钥进行加密和解密
*** 从文字密码到比特序列密码

编码（encoding）- 将现实世界中的东西映射为比特序列

XOR - $\oplus$ exclusive or, 异或 =相同为0，相反为1=

=XOR 中不需要进位=

~A XOR B XOR B = A!!!~

异或的基本性质：
  =A XOR B = B XOR A=
  =(A XOR B) XOR C = A XOR (B XOR C)=
  =A XOR 0 = A!!!=
  =A XOR A = 0!!!=

~A XOR B XOR B = A!!!~

和加密、解密的步骤非常相似。

=将明文A用密钥B进行加密，得到密文A XOR B=
=将密文A XOR B用密钥B进行解密，得到明文A=

=实际上，只要选择一个合适的B，仅仅使用 XOR 就可以实现一个高强度的密码。=

对于图像也适用，只要是010101...01比特序列就行

=能够产生不可预测的比特序列，对于密码技术的贡献是巨大的。这种不可预测的比特序列就称为随机数。=
*** 一次性密码本 -- 绝对不会被破译的密码

它的原理是“将明文与一串随机的比特序列进行XOR运算”。

=明文和密钥的长度相同=

即便我们能够解密出来，也 =无法判断它是否是正确的明文=

由于明文中所有可能的排列组合都会出现，因此我们无法判断其中哪一个才是正确的明文（也就是用哪个密钥才能够正确解密）。

又称为 =维纳密码（Vernam cipher）=

一次性密码本为什么没有被使用
  =最大的问题在于密钥的配送。=
  产生了一个矛盾
    如果能够有一种方法将密钥安全地发送出去，那么岂不是也可以用同样的方法来安全地发送明文了吗？
  =密钥的保存=
    不过，如果能够有办法安全保存与明文一样长的密钥，那不也就有办法安全保存明文本身了吗？
  =密钥的重用=
    在一次性密码本中绝对不能重用过去用过的随机比特序列
  =密钥的同步=
    一次性密码本中还会产生发送者与接收者之间密钥同步的问题。
    =明文和密钥的长度相同=
    而且在通信过程中，发送者和接收者的密钥的比特序列不允许有任何错位
  =密码的生成=
    不是通过计算机程序生成的伪随机数，而必须是无重现性的真正随机数。
    
综上所述，一次性密码本是一种几乎没有实用性的密码。
但是，一次性密码本的思路却孕育出了 =流密码（stream cipher）。=
流密码使用的不是真正的随机比特序列，而是 =伪随机数生成器产生的比特序列。=
流密码虽然不是无法破译的，但只要使用高性能的伪随机数生成器，就能够构建出强度较高的密码系统。
*** DES

DES ( Data Encryption Standard )

1977年美国联邦信息处理标准（FIPS）中所采用的一种对称密码（FIPS46-3）。

DES 是种将64比特的明文加密成64比特的密文的对称密码算法，它的密钥长度是56比特。

=尽管从规格上来说，DES 的密钥长度是64比特，但由于每隔7比特会设置一个用于错误检查的比特，因此实质上其密钥长度是56 比特。=

DES 是以64比特的明文（比特序列）为一个单位来进行加密的
=这个64比特的单位称为分组=

=以分组单位进行处理的密码算法称分组密码（block cipher）=
=DES就是一种分组密码=


DES 每次只能加密64比特的数据，如果要加密的明文比较长，就需要对 DES加密进行迭代（反复）。
=模式（mode）= 迭代的具体方式

[[./pictures/cryptography/12.png]]


[[*为什么要将密码算法和密钥分开呢]]
*** DES 的结构（Feistel 网络）

DES 的基本结构是由 Horst Feistel 设计的，因此也称为 Feistel 网络（Feistel network）、 Feistel 结构（Feistel structure）或者 Feistel 密码（Feistel cipher）。

=在 Feistel 网络中，加密的各个步骤称为轮（round），整个加密过程就是进行若干次轮的循环。=
=DES 是一种 16 轮循环的 Feistel 网络。=

=一轮的计算流程=
[[./pictures/cryptography/13.png]]

在 Feistel 网络中， =每一轮都需要使用一个不同的子密钥。=
由于子密钥只在一轮中使用，它只是一个局部密钥，因此才称为子密钥 ( subkey )。

=轮函数的作用是根据“右侧”和子密钥生成对“左侧”进行加密的比特序列，它是密码系统的核心=

总结一下，一轮的具体计算步骤如下。
（1）将输入的数据等分为左右两部分。
（2）将输人的右侧直接发送到输出的右侧。
（3） 将输入的右侧发送到轮函数。
（4） 轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列。
（5）将上一步得到的比特序列与左侧数据进行 XOR运算，并将结果作为加密后的左侧。

但是， =这样一来“右侧”根本就没有被加密，=
=因此我们需要用不同的子密钥对一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧的数据对调。=

=一个3轮的 Feistel 网络=
[[./pictures/cryptography/14.png]]

=那么，Feistel 网络应该如何解密呢？=

例如，我们尝试一下将一轮加密的输出结果用相同的子密钥重新运行一次，这时 Feistel 网络会怎么样呢？
结果可能非常令人意外，无论轮函数的具体算法是什么，通过上述操作都能够将密文正确地还原为明文。

=关于这一点，大家可以从XOR的性质（两个相同的数进行 XOR的结果一定为0）进行思考。=
  ~A XOR B XOR B = A~

[[./pictures/cryptography/15.png]]

=有多个轮的情况下也是一样的。=
也就是说，Feistel 网络的 =解密操作只要按照相反的顺序来使用子密钥就可以完成了= ，而 =Feistel 网络本身的结构，在加密和解密时都是完全相同的。=

[[./pictures/cryptography/16.png]]


=Feistel 网络的轮数可以任意增加。=
  无论运行多少轮的加密计算，都不会发生无法解密的情况。
=加密时无论使用任何函数作为轮函数都可以正确解密。=
  即便用轮函数的输出结果无法逆向计算出输入的值（即该函数不存在反函数）也没有问题。
=Feistel 网络实际上就是从加密算法中抽取出“密码的本质部分”并将其封装成一个轮函数。=
  只要使用Feistel 网络，就能够保证一定可以解密。因此，设计密码算法的人只要努力设计出足够复杂的就可以了。
=加密和解密可以用完全相同的结构来实现=
  右半部分实际上没有进行任何处理，这在加密算法中看起来是一种浪费，
  但却保证了可解密性，因为完全没有进行任何处理的右半部分，是解密过程中所必需的信息。
  由于加密和解密可以用完全相同的结构来实现，因此用于实现 DES算法的硬件设备的设计也变得容易了。
  
=综上所述，无论是任何轮数、任何轮函数，Feistel 网络都可以用相同的结构实现加密和解密，且加密的结果必定能够正确解密。=

被许多分组密码算法使用。

在后面即将介绍的AES 最终候选算法的5个算法之中，有3个算法（MARS、RC6、Twofish） 都是使用了Feistel 网络。

Rijndael 所使用的结构称为SPN结构。
*** 差分分析与线性分析

差分分析是一种针对分组密码的分析方法， =其思路是 “改变一部分明文并分析密文如何随之改变”。=

线性分析， =其思路是“将明文和密文的一些对应比特进行XOR并计算其结果为零的概率”。=

如果密文具备足够的随机性， 则任选一些明文和密文的对应比特进行XOR结果为零的概率应该为 $\frac{1}{2}$ 。

如果能够找到大幅偏离 $\frac{1}{2}$ 的部分，则可以借此获得一些与密钥有关的信息。

使用线性分析法，对于 DES 只需要 $2^{47}$ 组明文和密文就能够完成破解，相比需要尝试 $2^{56}$ 个密钥的暴力破解来说，所需的计算量得到了大幅减少。

=差分分析和线性分析都有一个前提，那就是假设密码破译者可以选择任意明文并得到其加密的结果，这种攻击方式称为选择明文攻击（Chosen Plaintext Attack, CPA）。=

=以 AES 为代表的现代分组密码算法，在设计上已经考虑了针对差分分析和线性分析的安全性。=

现在DES已经可以在现实的时间内被暴力破解，因此我们需要一种用来替代DES的分组密码， =三重 DES 就是出于这个目的被开发出来的。=
*** 三重 DES

现在DES已经可以在现实的时间内被暴力破解，因此我们需要一种用来替代DES的分组密码， =三重 DES 就是出于这个目的被开发出来的。=

三重 DES （triple-DES）是为了增加 DES 的强度， =将DES 重复3次所得到的一种密码算法， 也称为 TDEA （ Triple Date Encryption Algorithm），通常缩写为 3DES。=

三重 DES 的加密

[[./pictures/cryptography/17.png]]

三重 DES的密钥长度就是56x3=168比特。

三重DES并不是进行三次 DES 加密（加密一加密一加密），而是 =加密 —— 解密 —— 加密= 的过程。

=目的是为了让三重 DES能够兼容普通的 DES。=

=当三重 DES 中所有的密钥都相同时，三重 DES 也就等同于普通的DES了。=

=这是因为在前两步加密一解密之后，得到的就是最初的明文。=
[[*为什么要将密码算法和密钥分开呢]]
[[*DES]]
[[*DES 的结构（Feistel 网络）]]

因此，以前用 DES加密的密文，就可以通过这种方式用三重 DES 来进行解密。也就是说，三重 DES 对 DES 具备向下兼容性。

[[./pictures/cryptography/18.png]]

=DES 的加密和解密过程只是改变了子密钥的顺序，而实际进行的处理是相同的。=

=如果所有密钥都使用相同的比特序列，则其结果与普通的 DES 是等价的。= 这里估计说的三重DES

=如果密钥1和密钥3使用相同的密钥，而密钥2使用不同的密钥（也就是只使用两个 DES密钥）= ，这种三重 DES 就称 =DES-EDE2。=
EDE 表示的是加密（Encryption）一解密 （Decryption）一加密（Encryption）这个流程。

[[./pictures/cryptography/19.png]]

密钥1、密钥2、密钥3全部使用不同的比特序列的三重 DES 称为 =DES-EDE3。=

三重 DES 的解密

三重 DES的解密过程和加密正好相反，是以密钥3、密钥2、密钥1的顺序执行解密一加密一解密的操作。

[[./pictures/cryptography/20.png]]

三重 DES 的现状

尽管三重DES 目前还被银行等机构使用，但其处理速度不高，除了特别重视向下兼容性的情况以外，很少被用于新的用途。
*** AES (Advanced Encryption Standard) -- 取代其前任标准（DES）而成新标准的一种对称密码算法

从这些候选算法中选出了一种名为 =Rijndael= 的对称密码算法，并将其确定为了 AES。

AES 的选拔过程
  通过竟争来实现标准化（standardization by competition）

AES最终候选算法的确定与AES 的最终确定
  15个（CAST-256、Crypton、DEAL、DFC、E2、Frog、HPC、LOK197、 Magenta、MARS、RC6、Rijndael、SAFER+、Serpent、Twofish）

  有5个算法入围了AES 最终候选算法名单 MARs、RC6、Rijndael、Serpent、 Twofish

  Rijndael 力压群雄，被 NIST选定为AES标准。
*** Rijndael

一种分组密码算法
=以分组单位进行处理的密码算法称分组密码（block cipher）=

Rijndael 的分组长度和密钥长度可以分别 =以32比特为单位在128比特到256比特的范围内进行选择。=

不过在 AES 的规格中， =分组长度固定为128比特，密钥长度只有 128、192 和256 比特三种。=

Rijndael 的加密和解密

  也是由多个轮构成的，
  =其中每一轮分为 SubBytes、ShiftRows、 MixColumns 和AddRoundKey 共4个步骤。=

DES 使用 Feistel 网络作为其基本结构，而 Rijndael 没有使用Feistel 网络，而是 =使用了 SPN结构。=
[[*DES 的结构（Feistel 网络）]]

Rijndael 的输人分组为128比特，也就是16字节。

=1.首先，需要逐个字节地对16字节的输人数据进行 SubBytes 处理。=
  =SubBytes=
    就是以每个字节的值（0~255的任意值）为索引， 从一张拥有256个值的替换表（S-Box）中查找出对应值的处理。
    
    图示为4x4=16字节的数据中通过S-Box替换1字节的情形。
    [[./pictures/cryptography/21.png]]


























=2.SubBytes 之后需要进行 ShiftRows 处理。=
  这一步是将以4字节为单位的行（row）按照一定的规则向左平移，且每一行平移的字节数是不同的。
  图示为 ShiftRows 中对其中一行进行处理的情形。
  [[./pictures/cryptography/22.png]]

=3.ShiftRows 之后需要进行 MixColumns 处理。=
  这一步是对一个4字节的值进行比特运算，将其变另外一个4字节值。
  图示为 MixColumns 中对其中一列（column）进行处理的情形。
  [[./pictures/cryptography/23.png]]

=4.需要将 MixColumns 的输出与轮密钥进行XOR，即进行 AddRoundKey 处理。=
  图示为AddRoundKey 中对其中1个字节进行处理的情形。
  [[./pictures/cryptography/24.png]]

到这里，Rijndael 的一轮就结束了。
=实际上，在Rijndael 中需要重复进行10~14轮计算。=

输入的所有比特在一轮中都会被加密。
=和每一轮都只加密一半输入的比特的 Feistel 网络相比，这种方式的优势在于加密所需要的轮数更少。=
[[*DES 的结构（Feistel 网络）]]

=还有一个优势，即 SubBytes、ShiftRows和 MixColumns 可以分别以字节、行和列单位进行并行计算。=

在 Rijndael 的加密过程中，每一轮所进行的处理为：

SubBytes → ShiftRows → MixColumns → AddRoundKey

=而在解密时，则是按照相反的顺序来进行的，即：=

AddRoundKey → InvMixColumns → InvShiftRows → InvSubBytes

  XOR - $\oplus$ exclusive or, 异或 =相同为0，相反为1=
    =XOR 中不需要进位=
    ~A XOR B XOR B = A!!!~
    异或的基本性质：
    =A XOR B = B XOR A=
    =(A XOR B) XOR C = A XOR (B XOR C)=
    =A XOR 0 = A!!!=
    =A XOR A = 0!!!=
    ~A XOR B XOR B = A!!!~

[[./pictures/cryptography/25.png]]

Rijndael 的破译
  尽管本书中没有涉及，但 Rijndael 的算法背后有着严谨的数学结构，也就是说从明文到密文的计算过程可以全部用公式来表达，这是以前任何密码算法都不具备的性质。
  如果 Rijndael 的公式能够通过数学运算来求解，那也就意味着 Rijndael能够通过数学方法进行破译，而这也就为新的攻击方式的产生提供了可能。
  不过，这也只是一种假设而已，实际上到现在为止还没有出现针对 Rijndael
  
应该使用哪种对称密码呢
  DES 不应再用于任何新的用途
    用暴力破解法已经能够在现实的时间内完成对 DES 的破译。
    在某些情况下也需要保持与旧版本软件的兼容性。

  我们也没有理由将三重 DES 用于任何新的用途，
    尽管在一些重视兼容性的环境中还会继续使用，
    但它会逐渐被 AES 所取代。

  应该使用的算法是 AES（Rijndael），
    因为它安全、快速，而且能够在各种平台上工作。

  AES 最终候选算法应该可以作为AES 的备份。
    和Rijndael一样，这些密码算法也都经过了严格的测试，且没有发现任何弱点。
    但 NIST 最终选择的标准只有Rijndael，并没有官方认可将其他最终候选算法作力备份来使用。

=一般来说，我们不应该使用任何自制的密码算法，而是应该使用 AES。=
*** 本章小结
用对称密码进行通信时，还会出现密钥的配送问题

=为了解决密钥配送问题，我们需要公钥密码技术。=

此外，尽管使用对称密码可以确保机密性，但仅凭这一点还并不能完全放心。
例如，当接收到的密文无法正确解密时，如果仅仅向发送者返回一个“出错了”的消息， 在某些情况下是非常危险的。
因为发送者有可能发送伪造的密文，并利用解密时返回的错误来盗取信息。

本章所介绍的几乎所有的密码算法，都只能将一个固定长度的分组进行加密。
=当需要加密的明文长度超过分组长度时，就需要对密码算法进行迭代。=
=下一章我们将探讨对分组密码进行迭代的方法。=
** 分组密码的模式 — 分组密码是如何迭代的

介绍的 DES 和AES 都属于分组密码，它们只能加密固定长度的明文。
=以分组单位进行处理的密码算法称分组密码（block cipher）=

=如果需要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码的迭代方法就称为分组密码的“模式”。=

*** 分组密码与流密码

=分组密码（block cipher）是每次只能处理特定长度的一块数据的一类密码算法=
  分组长度 一个分组的比特数
  DES 和三重 DES的分组长度都是64比特。
  这些密码算法一次只能加密64比特的明文，并生成64 比特的密文。
  AES 的分组长度为128比特，因此 AES一次可加密128比特的明文，并生成128比特的密文。

=流密码（stream cipher）是对数据流进行连续处理的一类密码算法。=
  流密码中一般以1比特、 8比特或32 比特等为单位进行加密和解密。
  
分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；
流密码是对一串数据流进行连续处理， =因此需要保持内部状态。=

在 [[*对称密码（共享密钥密码） — 用相同的密钥进行加密和解密]] 中所介绍的算法中，
  只有一次性密码本属于流密码，而DES、三重 DES、AES（Rijndael） 等大多数对称密码算法都属于分组密码。
  
*** 什么是模式

分组密码算法只能加密固定长度的分组， =但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代= ，以便将一段很长的明文全部加密。
而 =迭代的方法= 就称为分组密码的 =模式（mode）。=

主要模式有以下5种:
  ECB 模式：Electronic CodeBook mode（电子密码本模式）
    将明文分割成多个分组并逐个加密的方法称力 ECB模式，这种模式具有很大的弱点（稍后讲解）。
  CBC模式：Cipher Block Chaining mode（密码分组链接模式）
  CFB 模式：Cipher FeedBack mode（密文反馈模式）
  OFB 模式：Output FeedBack mode（输出反馈模式）
  CTR 模式：CounTeR mode（计数器模式）
  
*** 明文分组与密文分组

明文分组是指分组密码算法中作为加密对象的明文。
  明文分组的长度与分组密码算法的分组长度是相等的。

密文分组是指使用分组密码算法将明文分组加密之后所生成的密文。

[[./pictures/cryptography/26.png]]

*** ECB 模式

Electronic CodeBook

将明文分组直接加密的方式就是ECB 模式，这种模式非常简单，但由于存在弱点因此通常不会被使用。

[[./pictures/cryptography/27.png]]

使用ECB 模式加密时，相同的明文分组会被转换为相同的密文分组，也就是说， =我们可以将其理解为是一个巨大的“明文分组一密文分组”的对应表= ，因此ECB 模式也称为电子密码本模式。

=当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充（padding）。=

ECB 模式中，明文分组与密文分组是一一对应的关系。
  这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此ECB 模式是存在一定风险的。

=ECB 模式中，每个明文分组都各自独立地进行加密和解密，但这其实是一个很大的弱点。=
  假如存在主动攻击者 Mallory，他能够改变密文分组的顺序。
  当接收者对密文进行解密时， 由于密文分组的顺序被改变了，因此相应的明文分组的顺序也会被改变。
  攻击者 Mallory 无需破译密码就能够操纵明文。

=此外，Mallory 所能做的还不仅限于替换，例如，如果将密文分组删除，则相应的明文分组也会被删除，如果对密文分组进行复制，则相应的明文分组也会被复制。=

=Mallory 对密文所进行的篡改，可以通过第8章介绍的消息认证码检测出来。=

=不过，如果使用除 ECB 之外的其他模式，那么上述攻击从一开始就是不可能实现的。=

*** CBC 模式

Cipher Block Chaining 模式（密文分组链接模式）， 因为密文分组是像链条一样相互连接在一起的。

CBC模式是将前一个密文分组与当前明文分组的内容混合起来进行加密的，这样就可以避免ECB 模式的弱点。

=在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。=

[[./pictures/cryptography/28.png]]


~A XOR B XOR B = A!!!~

异或的基本性质：
  =A XOR B = B XOR A=
  =(A XOR B) XOR C = A XOR (B XOR C)=
  =A XOR 0 = A!!!=
  =A XOR A = 0!!!=

~A XOR B XOR B = A!!!~

ECB 模式只进行了加密，而CBC模式则在加密之前进行了一次 XOR。

[[./pictures/cryptography/29.png]]

=初始化向量=
  当加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为初始化向量（Initialization Vector），通常缩写为IV。
  一般来说，每次加密时都会随机产生一个不同的比特序列来作初始化向量。

明文分组在加密之前一定会与“前一个密文分组”进行XOR运算，因此即便明文分组1和 2的值是相等的，密文分组1和2的值也不一定是相等的。
  =这样一来，ECB 模式的缺陷在CBC 模式中就不存在了。=
  =在CBC模式中，我们无法单独对一个中间的明文分组进行加密。=

=在这种情况下，只要密文分组的长度没有发生变化，则解密时最多只会有2个分组受到数据损坏的影响。=
[[./pictures/cryptography/30.png]]
想想异或的性质！！！

~A XOR B XOR B = A!!!~
  =A XOR 0 = A!!!=
  =A XOR A = 0!!!=

假设 CBC模式的密文分组中有一些比特缺失了（例如由于通信错误导致没有收到某些比特等），那么此时即便只缺失了1比特，也会导致密文分组的长度发生变化，此后的分组发生错位，这样一来，缺失比特的位置之后的密文分组也就全部无法解密了。
[[./pictures/cryptography/31.png]]

**** 对 CBC 模式的攻击
假设主动攻击者 Mallory 的目的是通过修改密文来操纵解密后的明文。
  如果 Mallory 能够对初始化向量中的任意比特进行反转（即将1变为0，将。变 1），则明文分组（解密后得到的明文分组）中相应的比特也会被反转。这是因为在CBC模式的解密过程中，第一个明文分组会和初始化向量进行 XOR运算。
  [[./pictures/cryptography/32.png]]
  异或的基本性质：
    =A XOR 0 = A!!!=
    =A XOR A = 0!!!=

=另外，通过使用第8章中介绍的消息认证码，还能够判断出数据有没有被篡改。=

**** 填充提示攻击

填充提示攻击（Padding Oracle Attack）是一种利用分组密码中的填充部分来进行攻击的方法。

在分组密码中，当明文长度不为分组长度的整数倍时，需要在最后一个分组中填充一些数据使其凑满一个分组长度。
=在填充提示攻击中，攻击者会反复发送一段密文，每次发送时都对填充的数据进行少许改变。=
=由于接收者（服务器）在无法正确解密时会返回一个错误消息，攻击者通过这一错误消息就可以获得一部分与明文相关的信息。=

这一攻击方式并不仅限于CBC模式，而是适用于所有需要进行分组填充的模式。

014年对SSL 3.0造成重大影响的POODLE 攻击实际上就是一种填充提示攻击。
=要防御这种攻击，需要对密文进行认证，确保这段密文的确是由合法的发送者在知道明文内容的前提下生成的。=

**** 对初始化向量（IV）进行攻击

初始化向量（IV）必须使用不可预测的随机数。

=然而在SSL/TLS 的TLS 1.0版本协议中， IV 并没有使用不可预测的随机数，而是使用了上一次CBC模式加密时的最后一个分组。=

为了防御攻击者对此进行攻击，TLS 1.1 以上的版本中改为了必须显式地传送 IV （RFC5246 6.2.3.2）。

**** CBC 模式的应用实例

确保互联网安全的通信协议之一SSL/TLS，

=就是使用CBC模式来确保通信的机密性的，如使用 CBC模式三重 DES 的3DES_EDE_CBC 以及 CBC模式256比特 AES 的AES_256_CBC等。=

*** CTS 模式

在分组密码中，当明文长度不能被分组长度整除时，最后一个分组就需要进行填充。

=CTS模式是使用最后一个分组的前一个密文分组数据来进行填充的，它通常和 ECB 模式以及CBC模式配合使用。=

根据最后一个分组的发送顺序不同，CTS 模式有几种不同的变体（CBC-CS1、CBC-CS2、CBC-CS3）， 下图表示的都是 CBC-CS3。

[[./pictures/cryptography/33.png]]

左图表示CTS模式的加密过程。
  其中，最后两个密文分组被调换了一下位置，这是因为我们需要将“明文分组 N-1” 加密后的一部分（左图中的X部分）用作“明文分组N”的填充内容，但×部分并不出现在最终的密文中。

*** CFB 模式

CFB 模式的全称是 Cipher FeedBack 模式（密文反馈模式）。

=在CFB 模式中，前一个密文分组会被送回到密码算法的输入端。所谓反馈，这里指的就是返回输入端的意思。=

[[./pictures/cryptography/34.png]]

=在ECB 模式和CBC模式中，明文分组都是通过密码算法进行加密的，然而，在CFB 模式中，明文分组并没有通过密码算法来直接进行加密。=

在CFB 模式中，明文分组和密文分组之间只有一个 XOR。

=在CBC模式中，明文分组和密文分组之间有XOR 和密码算法两个步骤，而在CFB模式中，明文分组和密文分组之间则只有 XOR。=

[[./pictures/cryptography/35.png]]

**** 初始化向量
  在生成第一个密文分组时，由于不存在前一个输出的数据，因此需要使用初始化向量（IV） 来代替，这一点和CBC模式是相同的。
  一般来说，我们需要在每次加密时生成一个不同的随机比特序列用作初始化向量。
**** CFB 模式与流密码
其实CFB 模式的结构与一次性密码本是非常相似的。
[[*一次性密码本 -- 绝对不会被破译的密码]]
  一次性密码本是通过将“明文”与“随机比特序列”进行XOR运算来生成 “密文”的。
  而CFB模式则是通过将“明文分组”与“密码算法的输出”进行XOR运算来生成 “密文分组”的。
  在通过XOR来进行加密这一点上，两者是非常相似的。
  在CFB模式中，密码算法的输出相当于一次性密码本中的随机比特序列。
  由于密码算法的输出是通过计算得到的，并不是真正的随机数（详见第12章），因此 CFB 模式不可能像一次性密码本那样具备理论上不可破译的性质。

=CFB 模式中由密码算法所生成的比特序列称为密钥流（key stream）。=
  在CFB 模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量就相当于伪随机数生成器的 “种子”。
  
=在CFB模式中，明文数据可以被逐比特加密，因此我们可以将CFB 模式看作是一种使用分组密码来实现流密码的方式。=
**** CFB 模式的解密
[[./pictures/cryptography/34.png]]
=需要注意的是分组密码算法依然执行加密操作，因为密钥流是通过加密操作来生成的。=
**** 对 CFB 模式的攻击
对 CFB 模式可以实施 =重放攻击（replay attack）。=

[[./pictures/cryptography/36.png]]
Mallory 没有破解密码，就成功地将以前的电文混入了新电文中。
而第2个分组出错到底是通信错误呢，还是被人攻击所造成的呢？Bob 是无法做出判断的。
=要做出这样的判断，需要使用第8章将要介绍的消息认证码。=
*** OFB模式

OFB 模式的全称是 Output-Feedback 模式（输出反馈模式）。
在OFB模式中，密码算法的输出会反馈到密码算法的输入中。

[[./pictures/cryptography/37.png]]
[[./pictures/cryptography/38.png]]

异或的基本性质：
  =A XOR 0 = A!!!=
  =A XOR A = 0!!!=

=OFB 模式并不是通过密码算法对明文直接进行加密的，而是通过将“明文分组”和“密码算法的输出”进行 xOR来产生“密文分组”的，在这一点上OFB 模式和 CFB 模式非常相似。=
**** 初始化向量
和CBC模式、CFB 模式一样，OFB 模式中也需要使用初始化向量（IV）。
一般来说，我们需要在每次加密时生成一个不同的随机比特序列用作初始化向量。
**** CFB 模式与 OFB 模式的对比
=OFB模式和CFB 模式的区别仅仅在于密码算法的输人。=

CFB 模式中，密码算法的输入是前一个密文分组，也就是将密文分组反馈到密码算法中， 因此就有了“密文反馈模式”这个名字。
相对地，OFB 模式中，密码算法的输入则是密码算法的前一个输出，也就是将输出反馈给密码算法，因此就有了“输出反馈模式”这个名字。

[[./pictures/cryptography/39.png]]

=由于CFB 模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组1而先对明文分组2进行加密。=
=相对地，在OFB 模式中，XOR所需要的比特序列（密钥流）可以事先通过密码算法生成， 和明文分组无关。=
  只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了，只要将明文与密钥流进行XOR就可以了。

=和AES 等密码算法相比， XOR运算的速度是非常快的。=
=这就意味着只要提前准备好密钥流就可以快速完成加密。=
=换个角度来看，生成密钥流的操作和进行XOR运算的操作是可以并行的。=
*** CTR模式
CTR 模式的全称是 CounTeR 模式（计数器模式）。
=CTR 模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。=

[[./pictures/cryptography/40.png]]

CTR 模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。
也就是说，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的。
**** 计数器的生成方法
=每次加密时都会生成一个不同的值（nonce）来作计数器的初始值。=
当分组长度为128比特（16字节）时，计数器的初始值可能是像下面这样的形式。

[[./pictures/cryptography/41.png]]

其中前8个字节为 nonce，这个值在每次加密时必须都是不同的。
后8个字节为分组序号， 这个部分是会逐次累加的。
在加密的过程中，计数器的值会产生如下变化。

[[./pictures/cryptography/42.png]]

由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的。
=也就是说，这种方法就是用分组密码来模拟生成随机的比特序列。=
**** OFB 模式与CTR 模式的对比
=CTR 模式和 OFB 模式一样，都属于流密码。=

[[./pictures/cryptography/43.png]]

=OFB 模式是将加密的输出反馈到输入，而 CTR 模式则是将计数器的值用作输人。=
**** CTR模式的特点
=CTR 模式的加密和解密使用了完全相同的结构，因此在程序实现上比较容易。=
=这一特点和同为流密码的 OFB 模式是一样的。=

[[./pictures/cryptography/43.png]]

=此外，CTR 模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由 nonce 和分组序号直接计算出来。=
=这一性质是OFB 模式所不具备的。=

=能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR 模式的速度是非常快的。=
**** 错误与机密性
错误与机密性方面，CTR 模式也具备和 OFB 模式差不多的性质。
=假设CTR 模式的密文分组中有一个比特被反转了，则解密后明文分组中仅有与之对应的比特会被反转，这一错误不会放大。=

异或的基本性质：
  =A XOR 0 = A!!!=
  =A XOR A = 0!!!=

=换言之，在CTR 模式中，主动攻击者 Mallory 可以通过反转密文分组中的某些比特，引起解密后明文中的相应比特也发生反转。=
这一弱点和 OFB 模式是相同的。

=不过CTR 模式具备一个比 OFB 模式要好的性质。=
=在OFB模式中，如果对密钥流的一个分组进行加密后其结果碰巧和加密前是相同的，那么这一分组之后的密钥流就会变成同一值的不断反复。=
=在CTR模式中就不存在这一问题。=
*** GCM 模式
=在 CTR 模式的基础上增加“认证”功能的模式称为GCM 模式（Galois/Counter Mode ）。=

=这一模式能够在CTR 模式生成密文的同时生成用于认证的信息，从而判断“密文是否通过合法的加密过程生成”。=
通过这一机制，即便主动攻击者发送伪造的密文，我们也能够识别出“这段密文是伪造的”。
*** 应该使用哪种模式呢
[[./pictures/cryptography/44.png]]

首先，希望大家搞清楚每种模式的3个字母到底是什么的缩写。
如果能够记住每个模式的名称，就能够在头脑中想象出相应的结构图，也就能够搞清楚每个模式的特点了。

《实用密码学》（ Practical Cryptography）［Schneier, 2003］一书中推荐使用CBC模式和 CTR 模式，
而《CRYPTREC密码清单》［CRYPTREC］ 中则推荐使用CBC、CFB、OFB 和 CTR模式。

*** 本章小结
同样一个分组密码算法，根据用途的不同可以以多种模式来工作。各种模式都有自己的长处和短处，因此需要大家在理解这些特点的基础上进行运用。
** 公钥密码 — 用公钥加密，用私钥解密
=在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。=
=密钥配送问题=
  用于解密的密钥必须被配送给接收者
  解决密钥配送问题的方法有以下几种。
  • 通过事先共享密钥来解决
      会有数量问题
  • 通过密钥分配中心来解决
      =密钥分配中心（Key Distribution Center, KDC）=
      当需要进行加密通信时，密钥分配中心会生成一个通信密钥，每个人只要和密钥分配中心事先共享密钥就可以了。
  • 通过 Diffie-Hellman密钥交换来解决
      在Diffie-Hellman 密钥交换中，进行加密通信的双方需要交换一些信息，而这些信息即便被窃听者Eve 窃听到也没有问题。
      根据所交换的信息，双方可以各自生成相同的密钥，而窃听者Eve 却无法生成相同的密钥。
  • 通过公钥密码来解决
      =加密密钥和解密密钥却是不同的。只要拥有加密密钥，任何人都可以进行加密，但没有解密密钥是无法解密的。=
      =接收者事先将加密密钥发送给发送者，这个加密密钥即便被窃听者获取也没有问题。=
      =发送者使用加密密钥对通信内容进行加密并发送给接收者，而只有拥有解密密钥的人（即接收者本人）才能够进行解密。=

如果使用公钥密码，则无需向接受者配送用于解密的密钥。
*** 什么是公钥密码
公钥密码（public-key cryptography）中， =密钥分为加密密钥和解密密钥两种。发送者用加密密钥对消息进行加密，接收者用解密密钥对密文进行解密。=

=加密密钥被窃听者获取也没问题=

=公钥密码中，加密密钥一般是公开的。正是由于加密密钥可以任意公开，因此该密钥被称为公钥（public key ）。=

=相对地，解密密钥是绝对不能公开的，这个密钥只能由你自己来使用，因此称私钥 （private key ）。=

=公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对（key pair）。=
*** 公钥密码的历史
1976年，Whitfield Diffie 和 Martin Hellman 发表了关于公钥密码的设计思想。

1977年，Ralph Merkle 和 Martin Hellman 共同设计了一种具体的公钥密码算法— Knapsack。

1978年，Ron Rivest、Adi Shamir 和 Reonard Adleman 共同发表了一种公钥密码算法 — RSA。RSA 可以说是现在公钥密码的事实标准。
*** 公钥通信的流程
（1） Bob 生成一个包含公钥和私钥的密钥对。
     私钥由 Bob 自行妥善保管。
（2） Bob 将自己的公钥发送给 Alice。
     Bob 的公钥被窃听者 Eve 截获也没关系。
     将公钥发送给 Alice，表示 Bob 请 Alice 用这个公钥对消息进行加密并发送给他。
（3） Alice 用 Bob 的公钥对消息进行加密。
     加密后的消息只有用Bob 的私钥才能够解密。
     虽然 Alice拥有Bob 的公钥，但用Bob 的公钥是无法对密文进行解密的。
（4） Alice 将密文发送给 Bob。
     密文被窃听者 Eve 截获也没关系。Eve 可能拥有Bob 的公钥，但是用Bob 的公钥是无法进行解密的。
（5） Bob 用自己的私钥对密文进行解密。
*** 各种术语
非对称密码（asymmetric cryptography）和公钥密码就表示用一个含义

此外，私钥（private key） 这个术语也有很多同义的别名，例如个人密钥、私有密钥、非公开密钥等，也有人将其称为秘密密钥（secret key ）。

也有人将对称密码的密钥称为共享秘密密钥， 将公钥密码的私钥称为私有秘密密钥以示区别。
*** 公钥密码无法解决的问题
=公钥认证问题=
  需要判断所得到的公钥是否正确合法
=此外，公钥密码还有一个问题就是，它的处理速度只有对称密码的几百分之一。=
*** 时钟运算
**** mod 运算
27 mod 12 == 3
=27与3以12模同余=
时钟的指针向右旋转相当于做加法
不过，我们做的不是单纯的加法，而是“除法求余数”（mod）
**** 减法
“将指针向左转动X个刻度”与“将指针向右转动Y个刻度”这两个操作是等价的。
**** 乘法
时钟运算中的思路也是一样的，将时钟运算中的加法进行反复就可以完成乘法运算了。
**** 除法
既然减法是加法的逆运算，那么除法也就可以看成是乘法的逆运算。
~7 x ? mod 12 = 1~
这个问题我们一下子算不出答案，那么我们将O,1,2,...按顺序代入?来计算一下7×? mod 12 的结果。
~7 x 7 mod 12 = 1~

<=>

“在mod12的世界中，1 / 7 == 7”

~a x b mod 12 = 1~
=a和b是互为倒数关系,在mod12的世界中=

=实际上，时钟运算中“某个数是否存在倒数”这个问题，=
=与公钥算法 RSA中“一个公钥是否存在相对应的私钥”这个问题是直接相关的。=
=0 有没有倒数呢？将指针转动0个刻度（也就是不转动），无论重复多少次，都不可能让指针前进到1 的位置=
=其实，（在mod 12 的世界中）存在倒数的数，它们和12之间的公约数都只有1。=
=也就是说，某个数是否存在倒数，可以通过这个数和12的最大公约数是否为1这个条件来进行判断。=
=和12的最大公约数为1的数（5、7、11），在数学上称为“和12互质的数”。=
**** 乘方
乘方也称为指数运算，正如乘法是加法的多次重复一样，乘方是乘法的多次重复。
$7^{4} = 7 \times 7 \times 7 \times 7$
“将“将“将“向右转动7个刻度”重复7次”重复7次”重复7次”
$7^4 \  mod \  12 = 7 \times 7 \times 7 \times 7 \  mod \  12$
$= ((7 \times 7 \  mod \  12) \times (7 \times 7 \  mod \  12)) mod \  12$
$=(1 \times 1) \ mod \  12$
$=1$

=在中间步骤求 mod，可以避免计算大整数的乘积。=
=这种在计算过程中求 mod来计算乘方的方法，也是RSA 的加密和解密算法中所使用的方法。=
**** 对数
=乘方的逆运算称为对数。=
=时钟运算中的对数称为离散对数。= 例如：
$7^{?} \  mod \  13 = 8$
还是?从0开始试，一直找到 $7^{4} \  mod \  13 = 8$

=当数字很大时，求离散对数非常困难，也非常耗时。=
=能快速求出离散对数的算法到现在还没有被发现。=
=Diffie-Hellman 密钥交换协议以及 EIGamal公钥算法中就运用了离散对数。=
*** 从时钟指针到 RSA
**** 什么是 RSA
RSA 是一种公钥密码算法，它的名字是由它的三位开发者，即 Ron Rivest、Adi Shamir 和 Leonard Adleman 的姓氏的首字母组成的（Rivest-Shamir-Adleman）。

=RSA 可以被用于公钥密码和数字签名，关于数字签名我们将在第9章进行讲解。=
**** RSA 加密
=在RSA 中，明文、密钥和密文都是数字。=

~密文 = 明文^{E} mod N~

=RSA 的密文是对代表明文的数字的E次方求 mod N的结果。=
=就是明文和自己做E次乘法，然后将其结果除以 N求余数，这个余数就是密文。=
=E和 N是RSA 加密的密钥，也就是说，E和 N的组合就是公钥。=
  不过，E和N并不是随便什么数都可以的，它们是经过严密计算得出的。
=E 和N两个数才组成了一个公钥=
**** RSA 解密
~明文 = 密文^{D} mod N~
=对表示密文的数字的D次方求 mod N就可以得到明文。=
=将密文和自已做D次乘法，再对其结果除以 N求余数，就可以得到明文。=

这里所使用的数字 N和加密时使用的数字N是相同的。

=D和N的组合就是私钥。=
  当然，D也并不是随便什么数都可以的，作为解密密钥的D，和数字E有着相当紧密的联系。

[[./pictures/cryptography/45.png]]
**** 生成密钥对
RSA 的加密是求“E次方的mod N”，解密是求“D次方的 mod N”

RSA密钥对的生成步骤如下。
（1）求N
    首先准备两个很大的质数 p 和 q。
      p 和 q 太小的话，密码会变得容易破译，但太大的话计算时间又会变得很长。
      =判断一个数是不是质数并不是看它能不能分解质因数，而是通过数学上的判断方法来完成。=
        =费马测试= 和 =米勒·拉宾测试=
      ~N = p x q~ （p, q为质数）
（2）求L（L是仅在生成密钥对的过程中使用的数）
    =L是p-1和q-1的最小公倍数（least common multiple，lcm）。=
    ~L = lcm(p - 1, q - 1)~
（3）求E
    ~1 < E < L~
    ~gcd(E,L) = 1~ E和L的最大公约数为1 （E和L互质）
    =通过伪随机生成器在1 < E < L的范围内生成E的候选数，然后再判断其是否满足gcd(E,L)=1这个条件。=
      =求最大公约数可以使用欧几里得的辗转相除法。=
    =之所以要加上E和L的最大公约数为1这个条件，是为了保证一定存在解密时需要使用的数D。=
（4）求D
    ~1 < D < L~
    ~E x D mod L = 1~

    =只要数D满足上述条件，则通过E和N进行加密的密文，就可以通过D和 N进行解密。=

    [[*除法]]
    =要保证存在满足条件的D，就需要保证E和L的最大公约数为1=
    =简单来说，E × D mod L =1保证了对密文进行解密时能够得到原来的明文。=

    =现在我们已经求出了D和 N，也就是说我们也生成了密钥对中的私钥。=

    [[./pictures/cryptography/46.png]]
**** 具体实践一下吧

用较小的数来模拟一下。

=密钥对生成=
(1)求N
~p = 17~ 17是质数
~q = 19~ 19是质数

~N = 17 x 19 = 323~
(2)求L
~L = lcm(p-1, q-1)~ 最小公倍数
  ~= lcm(16, 18)~
  ~= 144~
(3)求E
~gcd(E, L)=1~
满足条件的E有很多，例如下面这些数都可以。
  5, 7, 11, 13, 17, 19, 23, 25,29, 31，...
乍一看这些数好像都是质数，但其实并不是这样的，比如25就不是质数。
=这些数称为和 L“互质的数”，也就是相对于L是质数的意思。=
这里我们选择5来作为E。

=E = 5, N = 323, 这就是公钥=
(4)求D
~E x D mod L = 1~
我们来找一找，E乘以几 modL等于1呢？D=29可以满足上面的条件。

公钥：
  E = 5
  N = 323
私钥：
  D = 29
  N = 323
公钥（E, M）=（5, 323） 是可以任意公开的，但是私钥（D, M）=（29,323）必须妥善保管，不能告诉任何人。

=加密=
=要加密的明文必须是小于N的数，也就是小于323的数，这是因为在加密运算中需要求 mod N。=
=由于解密运算时也需要求 mod N，而mod N的结果必定小于N，因此如果明文本身大于N，则解密后无法得到正确的明文。=
这里我们假设要加密的明文是 123，加密时使用的是公钥E=5、N=323。

~密文 = 明文^{E} mod N~
$= 123^{5} \  mod \  323 = 225$

=解密=
对密文225进行解密。解密时使用的是私钥D=29、N=323。
~明文 = 密文^{D} mod N~
$225^{29} \ mod \  323 = 123$

=n1 mod n2 = (((n3) mod n2) x ((n4) mod n2) x ...) mod n2=
=在实际的 RSA 运算中，可以将29转化为二进制来进行，从而提高运算效率。=
*** 对RSA 的攻击
=RSA 的加密是求“E次方的 mod N”，解密是求“D次方的mod N”，原理非常简单。=
【密码破译者知道的信息】
• 密文：可以通过窃听来获取
• 数E和N：公钥是公开的信息，因此密码破译者知道E和N

【密码破译者不知道的信息】
• 明文：需要破译的内容
• 数D：私钥中至少D是不知道的信息
• 其他：密码破译者不知道生成密钥对时所使用的p、q和L
**** 通过密文来求得明文
~密文 = 明文^{E} mod N~ （RSA加密）

由于密码破译者知道密文、E和N，那么有没有一种方法能够用E次方 mod N之后的密文求出原来的明文呢？

=如果没有 modN的话，即：=
  ~密文 = 明文^{E}~

=通过密文求明文的难度不大，因为这可以被看作是一个求对数的问题。=

=但是，加上mod N之后，求明文就变成了求离散对数的问题，这是非常困难的，因为人类还没有发现求离散对数的高效算法。=
**** 通过暴力破解来找出 D
现在，RSA 中所使用的p和q的长度都是1024比特以上，N的长度为2048比特以上。
由于E和D的长度可以和 N差不多，因此要找出D，就需要进行 2048比特以上的暴力破解。
要在这样的长度下用暴力破解找出 D是极其困难的。
**** 通过E和N求出D
~E x D mod L = 1~
~L = lcm(p-1, q-1)~ 最小公倍数
因此由E计算D需要使用p和q。
  =但是密码破译者并不知道p和q，因此不可能通过和生成密钥对时相同的计算方法来求出 D。=
对于 RSA来说，有一点非常重要，那就是质数p和q不能被密码破译者知道。
=把p和q交给密码破译者与把私钥交给密码破译者是等价的。=
***** 对N进行质因数分解攻击
~N = p x q~
N是公开的，那么能不能由N求出p和q 呢？
=p和q都是质数，因此由N求p和q只能通过将N 进行质因数分解来完成。=
我们可以说：
=一旦发现了对大整数进行质因数分解的高效算法，RSA 就能够被破译=
如果能够快速地对大整数进行质因数分解，就能够将 N分解成质因数p和q，然后就可以求出 D，这是事实。
然而，现在我们还没有发现对大整数进行质因数分解的高效算法，而且也尚未证明质因数分解是否真的是非常困难的问题，甚至也不知道是否存在一种分解质因数的简单方法。
***** 通过推测p和q进行攻击
由于p和q是通过伪随机数生成器产生的，如果伪随机数生成器的算法很差，密码破译者就有可能推测出来p和q，因此使用能够被推测出来的随机数是非常危险的。
***** 其他攻击
=只要对N进行质因数分解并求出p和q，就能够求出D。=
但是至于“求D”与“对N进行质因数分解”是否是等价的，这个问题需要通过数学方法证明。
2004年 Alexander May 证明了“求D”与“对N进行质因数分解”在确定性多项式时间内是等价的“。
这样的方法目前还没有出现，而且我们也不知道是否真的存在这样的方法。
**** 中间人攻击
所谓中间人攻击，就是主动攻击者Mallory 混入发送者和接收者的中间，对发送者伪装成接收者，对接收者伪装成发送者的攻击方式，在这里，Mallory就是“中间人”。

[[./pictures/cryptography/47.png]]

=要防御中间人攻击，还需要一种手段来确认所收到的公钥是否真的属于Bob，这种手段称为认证。=
**** 选择密文攻击
=在研究密码算法的强度时，我们会假设攻击者有能力获得一些关键信息。=
=比如，一般我们都会假设攻击者已经知道我们所使用的密码算法，只是不知道密钥而已。=

=解密提示（Decryption Oracle）=
  在选择密文攻击（Chosen Ciphertext Attack）中，我们假设攻击者可以使用这样一种服务， 即“发送任意数据，服务器都会将其当作密文来解密并返回解密的结果”。

=如果一种密码算法能够抵御选择密文攻击，则我们就可以认为这种算法的强度很高。=

=通过选择密文攻击，攻击者能够获得关于密文所对应的明文的少量信息。=

=那么我们来思考一下，如何改进 RSA 才能抵御选择密文攻击呢？=
  只要我们在解密时能够判断“密文是否是由知道明文的人通过合法的方式生成的”就可以了。
  换句话说，也就是对密文进行“认证”。
  =RSA-OAEP （ Optimal Asymmetric Encryption Padding，最优非对称加密填充）正是基于上述思路设计的一种 RSA 改良算法（RFC2437）。=

  =RSA-OAEP 在加密时会在明文前面填充一些认证信息，包括明文的散列值以及一定数量的 0，然后再对填充后的明文用RSA 进行加密。=
  在RSA-OAEP的解密过程中，如果在 RSA 解密后的数据的开头没有找到正确的认证信息，则可以断定“这段密文不是由知道明文的人生成的”，并返回一条固定的错误消息 “decryption eror”（这里的重点是，不能将具体的错误内容告知发送者）。
=这样一来，攻击者就无法通过 RSA-OAEP 的解密提示获得有用的信息，因此这一算法能够抵御选择密文攻击。=
=在 RSA-OAEP 的实际运用中，还会通过随机数使得每次生成的密文呈现不同的排列方式，从而进一步提高安全性。=
*** 其他公钥密码
**** EIGamal 方式
EIGamal 方式是由 Taher EIGamal 设计的公钥算法。
RSA 利用了质因数分解的困难度，而 EIGamal 方式则利用了 mod N下求离散对数的困难度。
EIGamal 方式有一个缺点，就是经过加密的密文长度会变为明文的两倍。
密码软件 GnuPG 中就支持这种方式。
**** Rabin 方式
Rabin 方式是由 M.O.Rabin 设计的公钥算法。
Rabin 方式利用了 mod N 下求平方根的困难度。
上文中我们提到了破解 RSA 有可能不需要通过对大整数 N 进行质因数分解，而破译 Rabin 方式公钥密码的困难度与质因数分解则是相当的，这一点已经得到了证明。
**** 椭圆曲线密码
椭圆曲线密码（Elliptic Curve Cryptography,ECC）是最近备受关注的一种公钥密码算法。
它的特点是所需的密钥长度比RSA短。
=椭圆曲线密码是通过将椭圆曲线上的特定点进行特殊的乘法运算来实现的，它利用了这种乘法运算的逆运算非常困难这一特性。=
关于椭圆曲线密码的详细内容，请参考附录。
*** 关于公钥密码的 Q&A
**** 公钥密码比对称密码的机密性更高吗？
这个问题无法回答，因为机密性的高低是根据密钥长度而变化的。
**** 密钥长度为256比特的对称密码 AES，与密钥长度力1024比特的公钥密码 RSA 相比， RSA 的安全性更高吗？
不是。
公钥密码的密钥长度不能直接与对称密码的密钥长度进行比较，而且对不同密码算法的强度进行比较本来就不是一件容易的事。
=很多密码系统中都会给出一些密码算法的理想组合方式，并打包成密码套件 ( cipher suite )。=

在强度相对均衡的前提下，AES 的密钥长度和 RSA 的密钥长度的对比
数据基于NIST的密码强度比较表
NIST Special Publication 800-57, Recommendation for Key Management
| 对称密码AES | 公钥密码RSA |
|------------+------------|
|        128 |       3072 |
|        192 |      76800 |
|        256 |      15300 |
**** 因为已经有了公钥密码，今后对称密码会消失吗？
不会。
=一般来说，在采用具备同等机密性的密钥长度的情况下，公钥密码的处理速度只有对称密码的几百分之一。=
=因此，公钥密码并不适合用来对很长的消息内容进行加密。=
=根据目的的不同， 还可能会配合使用对称密码和公钥密码，例如，我们将在第6 章中介绍的混合密码系统就是将这两种密码组合而成的。=
**** 随着越来越多的人在不断地生成 RSA 的密钥对，质数会不会被用光呢？
不需要担心。
512 比特能够容纳的质数的数量大约为10的150次方，这个数量比整个宇宙中原子的数量还要多。
**** RSA 加密的过程中，需要对大整数进行质因数分解吗？
不需要。
RSA 在加密、解密、密钥对生成的过程中都不需要对大整数进行质因数分解。
=只有在需要由数N求p和q的密码破译过程中才需要对大整数进行质因数分解，因此 RSA 的设计是将质因数分解这种困难的问题留给了密码破译者。=
**** RSA 的破译与大整数的质因数分解是等价的吗？
2004年 Alexander May 证明了求 RSA 的私钥和对 N进行质因数分解是等价的。
**** 要抵御质因数分解，N的长度需要达到多少比特呢？
N无论有多长，总有一天都能够被质因数分解，因此现在的问题是，在现实的时间内N是否能够被质因数分解。
随着计算机性能的提高，对一定长度的整数进行质因数分解所需要的时间会逐步缩短，如果大型组织或者国家投入其计算资源，则时间还会进一步缩短。

=密码劣化=
随着计算机技术的进步等，以前被认为是安全的密码会被破译。
针对这一点，NISTSP800-57 中给出了如下方针。
• 1024比特的RSA 不应被用于新的用途
• 2048比特的RSA 可在2030年之前被用于新的用途
• 4096比特的 RSA 在2031年之后仍可被用于新的用途
在第13章中将要介绍的GnuPG2.1.4中，默认的RSA 密钥长度就是2048比特。
** 混合密码系统 — 用对称密码提高速度，用公钥密码保护会话密钥
=混合密码系统用对称密码来加密明文，用公钥密码来加密对称密码中所使用的密钥。=

通过使用混合密码系统，就能够在通信中将对称密码和公钥密码的优势结合起来。
*** 对称密码与公钥密码
通过使用对称密码，我们就能够在通信中确保机密性。
=然而要在实际中运用对称密码，就必须解决密钥配送问题。=
=而通过使用公钥密码，就可以避免解密密钥的配送，从而也就解决了对称密码所具有的密钥配送问题。=

但是，公钥密码还有两个很大的问题。
（1）公钥密码的处理速度远远低于对称密码。
    =混合密码系统解决=
（2）公钥密码难以抵御中间人攻击。
    =对公钥认证解决=
*** 混合密码系统
=将对称密码和公钥密码的优势相结合的方法。=

=混合密码系统中会先用快速的对称密码来对消息进行加密，这样消息就被转换为了密文， 从而也就保证了消息的机密性。=

=然后我们只要保证对称密码的密钥的机密性就可以了。我们可以用公钥密码对加密消息时使用的对称密码的密钥进行加密。=

•用对称密码加密消息
•通过伪随机数生成器生成对称密码加密中使用的会话密钥
  对称加密用的密钥（也叫会话密钥）不能随意写死，必须是每次通信动态生成的随机值，而这个随机值是通过伪随机数生成器（PRNG）产生的。
•用公钥密码加密会话密钥
  所以使用接收方的公钥对这个会话密钥进行加密，只有对应的私钥能解密。
•从混合密码系统外部赋予公钥密码加密时使用的密钥
  发送者一开始就知道接收者的公钥，并从外部渠道拿到（比如公钥基础设施 PKI 系统、证书等）。

[[./pictures/cryptography/48.png]]
**** 加密
[[./pictures/cryptography/49.png]]

=会话密钥（session key）是指为本次通信而生成的临时密钥，它一般是通过伪随机数生成器产生的。=
=伪随机数生成器所产生的会话密钥同时也会被传递给右半部分，作为对称密码的密钥使用。=

总结：
=会话密钥是对称密码的密钥，同时也是公钥密码的明文=
**** 解密
[[./pictures/cryptography/50.png]]
**** 混合密码系统的具体例子
=混合密码系统解决了公钥密码速度慢的问题，并通过公钥密码解决了对称密码的密钥配送问题。=

著名的密码软件PGP、以及网络上的密码通信所使用的SSL/TLS 都运用了混合密码系统。

=PGP 的处理除了这里介绍的混合密码系统之外，还包括数字签名、数字签名认证以及私钥管理等处理。=
*** 怎样才是高强度的混合密码系统

=伪随机数生成器=
  =混合密码系统中，伪随机数生成器被用于产生会话密钥。=

=对称密码=
  混合密码系统中，对称密码被用于加密消息。
  =1.需要使用高强度的对称密码算法， 并确保密钥具有足够的长度。=
  =2.还需要选择使用合适的分组密码模式。=

=公钥密码=
  公钥密码被用于加密会话密钥。
  我们 =需要使用高强度的公钥密码算法， 并确保密钥具有足够的长度。=

=密钥长度的平衡=
  混合密码系统中运用了对称密码和公钥密码两种密码方式，
  =无论其中任何一方的密钥过短， 都可能遭到集中攻击，因此对称密码和公钥密码的密钥长度必须具备同等的强度。=

  =然而，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，=
  因为对称密码的会话密钥被破译只会影响本次通信的内容，而公钥密码一旦被破译，从过去到未来的（用相同公钥加密的）所有通信内容就都能够被破译了。
*** 密码技术的组合
[[*分组密码的模式 — 分组密码是如何迭代的]]
分组密码模式，就是将只能加密固定长度的数据的分组密码进行组合，从而使其能够对更长的明文进行加密的方法。
通过采用不同的分组密码组合方式，我们就可以构建出各种具有不同特点的分组密码模式。

[[*三重 DES]]
三重DES是将3个DES组合在一起，从而形成的一种密钥比 DES 更长的对称密码。
  通过加密-解密-加密这样的连接方式，不但可以维持和DES 的兼容性，同时还能够选择性地使用 DES-EDE2 这种密钥长度较短的密码。

对称密码的内部也存在一些有趣的结构。  
[[*DES 的结构（Feistel 网络）]]
例如介绍的 Feistel 网络，不管轮函数的性质如何，它都能够保证密码被解密。

在本书剩下的章节中，还会出现一些由多种技术组合而成的技术，我们来做个简单的介绍。

=数字签名，是由单向散列函数和公钥密码组合而成的。=
=证书，是由公钥和数字签名组合而成的。=
=消息认证码，是由单向散列函数和密钥组合而成的，也可以通过对称密码来生成。=
=伪随机数生成器，可以使用对称密码、单向散列函数或者公钥密码来构建。=
=还有一些很神奇的系统，=
  =例如电子投票、能够在不知道内容的情况下签名的盲签名（blind signature）=
  =在不将信息发送给对方的前提下证明自己拥有该信息的零知识证明（zero-knowledge proof）等，它们都是以密码技术为基础进行组合而成的。作其中的一个例子，我们将在第15 章介绍虚拟货币比特币的相关内容。=
* 认证
** 单向散列函数 - 获取消息的“指纹”
直接比较安全的“副本”？
  1.不过，这种确认完整性的方法其实是毫无意义的。因为如果可以事先把文件保存在一个安全的地方，那根本就不需要确认完整性，直接用事先保存的文件来工作不就行了吗？
  2.效率问题

就像刑事侦查中获取指纹一样，我们能不能获取到Alice所生成的文件的“指纹”呢？如果我们不需要对整个巨大的文件进行对比，只需要对比一个较小的指纹就能够检查完整性的话，那该多方便啊。
[[./pictures/cryptography/51.png]]

=单向散列函数所生成的散列值，就相当于消息的“指纹”。=
*** 什么是单向散列函数
[[./pictures/cryptography/52.png]]

输入为消息（message）
输出为散列值（hash value）

=单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。=

=无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。=

=散列值的长度和消息的长度无关。=
  无论消息是1比特，还是100MB，甚至是100GB，单向散列函数都会计算出固定长度的散列值。
  =以 SHA-256 单向散列函数为例，它所计算出的散列值的长度永远是256比特（32字节）。=
  [[./pictures/cryptography/53.png]]

=其中的关键点在于，要确认完整性，我们不需要对比消息本身，而只要对比单向散列函数计算出的散列值就可以了。=
*** 单向散列函数的性质
**** 根据任意长度的消息计算出固定长度的散列值
**** 能够快速计算出散列值
**** 消息不同散列值也不同
两个不同的消息产生同一个散列值的情况称为 =碰撞（collision）。=
如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被人为地发现碰撞。

[[./pictures/cryptography/54.png]]

难以发现碰撞的性质称 =抗碰撞性（collision resistance）。=
  指的是难以找到另外一条具备特定散列值的消息。
  当给定某条消息的散列值时，单向散列函数必须确保要找到和该条消息具有相同散列值的另外一条消息是非常困难的。
密码技术中所使用的单向散列函数，都需要具备抗碰撞性。
**** 具备单向性
单向散列函数必须具备单向性（one-way）。
=单向性指的是无法通过散列值反算出消息的性质。=
根据消息计算散列值可以很容易，但这条单行路是无法反过来走的。

[[./pictures/cryptography/55.png]]

=单向性在单向散列函数的应用中是非常重要的。=
例如，我们后面要讲到的基于口令的加密和伪随机数生成器等技术中，就运用了单向散列函数的单向性。

=单向散列函数并不是一种加密=
因此无法通过解密将散列值还原为原来的消息。
*** 关于术语
=单向散列函数=
 也称
 =消息摘要函数（message digest function）=、
 =哈希函数=
 =杂凑函数=

输入单向散列函数的消息
  =原像（pre-image）=

单向散列函数输出的散列值
  =消息摘要（message digest ）=
  =指纹（fingerprint）=

完整性也称力一致性。

“散列”的英文 “hash”
  原意是古法语中的“斧子”，后来被引申“剁碎的肉末”，也许是用斧子一通乱剁再搅在一起的那种感觉吧。

=单向散列函数的作用，实际上就是将很长的消息剁碎，然后再混合成固定长度的散列值。=
*** 单向散列函数的实际应用
检测软件是否被篡改

=基于口令的加密=
  Password Based Encryption, PBE
  =PBE 的原理是将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算其散列值，然后将这个散列值用作加密的密钥。=
  =通过这样的方法能够防御针对口令的字典攻击=

=消息认证码=
  =消息认证码是将“发送者和接收者之间的共享密钥”和“消息”进行混合后计算出的散列值。=
  =使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。=
  消息认证码在 SSL/TLS 中也得到了运用。

=数字签名=
  =数字签名是现实社会中的签名和盖章这样的行为在数字世界中的实现。=
  数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，
  =而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。=

=伪随机数生成器=
  =密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。=
  =为了保证不可预测性，可以利用单向散列函数的单向性。=

=一次性口令=
  一次性口令经常被用于服务器对客户端的合法性认证。
  =在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time）=
  因此即使窃听者窃取了口令，也无法使用。
*** 单向散列函数的具体例子
**** MD4, MD5
MD4 是由 Rivest 于1990年设计的单向散列函数，能够产生128 比特的散列值（RFC1186， 修订版 RFC1320）。
  不过，随着 Dobbertin 提出寻找MD4散列碰撞的方法，
  =现在它已经不安全了。=
MD5 是由 Rivest 于 1991年设计的单项散列函数，能够产生128 比特的散列值（RFC1321）。
  MD5 的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息，
  =因此它也已经不安全了。=
MD4 和 MDS 中的MD 是消息摘要（Message Digest）的缩写。
**** SHA-1, SHA-256, SHA-384, SHA-512
SHA-1 是由 NIST （National Institute of Standards and Technology，美国国家标准技术研究所）设计的一种能够产生160比特的散列值的单向散列函数。

SHA-256、SHA-384和 SHA512都是由 NIST设计的单向散列函数，它们的散列值长度分别为256 比特、384 比特和512比特。
这些单向散列函数合起来统称 SHA-2，
=它们的消息长度也存在上限（SHA-256 的上限接近于 $2^{64}$ 比特，SHA-384 和 SHA-512 的上限接近于 $2^{128}$ 比特。=

=SHA-1 的强抗碰撞性已于2005年被攻破 ，也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2 还尚未被攻破。=

6 种版本的 SHA-2
| 名称        | 输出长度 | 内部状态长度 | 备注                        |
|-------------+---------+------------+-----------------------------|
| SHA-224     |     224 | 32 × 8=256 | 将 SHA-256 的结果截掉32比特   |
| SHA-256     |     256 | 32 × 8=256 |                             |
| SHA-512/224 |     224 | 64x8=512   | 将 SHA-512 的结果截掉288比特  |
| SHA-512/256 |     256 | 64×8=512   | 将 SHA-512 的结果截掉 256比特 |
| SHA-384     |     384 | 64×8=512   | 将 SHA-512 的结果截掉 128比特 |
| SHA-512     |     512 | 64 × 8=512 |                             |
**** RIPEMD-160
RIPEMD-160 是于1996年由 Hans Dobbertin、Antoon Bosselaers 和 Bart Preneel 设计的一种能够产生160比特的散列值的单向散列函数。

RIPEMD 的强抗碰撞性已经于2004年被攻破，但 RIPEMD-160还尚未被攻破。

=顺便一提， 比特币中使用的就是 RIPEMD-160。=
**** SHA-3
SHA-3 和AES一样采用公开竞争的方式进行标准化。

SHA-3 的选拔于5年后的2012年尘埃落定，一个名叫 =Keccak= 的算法胜出，最终成为了 SHA-3。
*** SHA-3 的选拔过程
SHA-3（Secure Hash Algorithm-3） 是一种作为新标准发布的单向散列函数算法，用来替代在理论上已被找出攻击方法的SHA-1算法。

最终于 2012年正式确定将 Keccak 算法作为 SHA-3标准。

和AES一样，举办 SHA-3公开选拔活动的依然是美国国家标准与技术研究院 NIST。

Keccak 最终被选为 SHA-3 的理由如下。
• 采用了与SHA-2完全不同的结构
• 结构清晰，易于分析
• 能够适用于各种设备，也适用于嵌入式应用
• 在硬件上的实现显示出了很高的性能
• 比其他最终候选算法安全性边际更大
*** Keccak
Keccak 是一种被选定 SHA-3 标准的单向散列函数算法。

=Keccak 可以生成任意长度的散列值，但为了配合SHA-2 的散列值长度，SHA-3标准中共规定了 SHA3-224、SHA-3-256、SHA3-384、SHA3-512这4种版本。=

=在输入数据的长度上限方面， SHA-1 为 $2^{64} - 1$ 比特，SHA-2为 $2^{128} - 1$ 比特，而SHA-3则没有长度限制。=
[[*SHA-1, SHA-256, SHA-384, SHA-512]]

此外，FIPS 202 中还规定了两个可输出任意长度散列值的函数（extendable-output function， XOF），分别为SHAKE128 和 SHAKE256。
  =据说 SHAKE 这个名字取自 Secure Hash Algorithm 与 Keccak这几个单词。=
**** 海绵结构

Keccak 采用了与SHA-1、SHA-2完全不同的海绵结构 ( sponge construction) 。

[[./pictures/cryptography/56.png]]

输入的数据在进行填充之后，要经过吸收阶段（absorbing phase）和挤出阶段（squeezing phase），最终生成输出的散列值。

Keccak 的海绵结构是先将输入的消息吸收到内部状态中，然后再 =根据内部状态= 挤出相应的散列值。

吸收阶段的流程如下。
  =将经过填充的输入消息按照每r个比特一组分割成若干个输入分组=
  =首先，将“内部状态的r个比特”与“输入分组1”进行 XOR，将其结果作为“函数f的输入值”=
  =然后，将“函数f的输出值r个比特”与“输入分组2”进行XOR，将其结果再次作为“函数f的输入值”=
  =反复执行上述步骤，直到到达最后一个输入分组=
  =待所有输入分组处理完成后，结束吸收阶段，进入挤出阶段=

函数f的作用是将输入的数据进行复杂的搅拌操作并输出结果（输入和输出的长度均力 b=r+c个比特），其操作对象是长度为b=r+c个比特的内部状态，内部状态的初始值为0。
=通过反复将输入分组的内容搅拌进来，整个消息就会被一点一点地“吸收”到海绵结构的内部状态中，就好像水分被一点一点地吸进海绵内部一样。=
=每次被吸收的输入分组长度为r个比特，因此，r被称为比特率（bit rate）。=
=内部状态中有c个比特是不受输入分组内容的直接影响的（但会通过函数f受到间接影响）。=
=这里的c被称为容量（capacity）。=

挤出阶段，流程如下。
  =首先，将“函数f的输出值中的r个比特”保存为“输出分组1”，并将整个输出值（r+c 个比特）再次输入到函数f中=
  =将“函数f的输出值中的个比特”保存为“输出分组2”，并将整个输出值（r+c个比特）再次输入到函数f中=
  =反复执行上述步骤，直到获得所需长度的输出数据=

=函数f的逻辑本身是完全相同的，每执行一次函数f，海绵结构的内部状态都会被搅拌一次。=

挤出阶段中实际上执行的是“对内部状态进行搅拌并产生输出分组（r个比特）”的操作，
=也就是以比特率（r个比特）为单位，将海绵结构的内部状态中的数据一点一点地“挤”出来， 就像从海绵里面把水分挤出来一样。=
在挤出阶段中，内部状态 r+c 个比特中的容量（c个比特）部分是不会直接进入输出分组的，这部分数据只会通过函数f间接影响输出的内容。
=因此，容量c的意义在于防止将输入消息中的一些特征泄漏出去。=
**** 双工结构
作为海绵结构的变形，Keccak 中还提出了一种双工结构

[[./pictures/cryptography/57.png]]

=在海绵结构中，只有将输入的消息全部吸收完毕之后才能开始输出，=
=但在双工结构中，输入和输出是以相同的速率进行的。=

=在双向通信中，发送和接收同时进行的方式称为全双工（full duplex ）=
  Keccak 的双工结构也代表同样的含义。

=通过采用双工结构，=
=Keccak 不仅可用于计算散列值，=
=还可以覆盖密码学家的工具箱中的其他多种用途，如伪随机数生成器、流密码、认证加密、消息认证码等。=
**** Keccak 的内部状态
刚才我们介绍了 Keccak 中b= r+c个比特的内部状态是如何通过函数f进行变化的

=Keccak 的内部状态是一个三维的比特数组=

[[./pictures/cryptography/58.png]]

=图中的每个小方块代表1个比特，b个小方块按照5x5xz 的方式组合起来，就成为一个沿z轴延伸的立方体。=
=我们将具备x、y、z三个维度的内部状态整体称 state，state 共有b个比特。=
=将xz 平面称为 plane，将xy平面称为 slice， 将yz平面称为 sheet=
=如果我们只关注其中一个维度，可以将x轴称为rOw，将y轴称为 column，将z 轴称为lane。=

[[./pictures/cryptography/59.png]]

=可以将 state 看成是由5x5=25条lane构成的，也可以看成是由与lane 的长度相同数量的 slice 堆叠而成的。=

=Keccak 的本质就是实现一个能够将上述结构的 state 进行有效搅拌的函数，这与分组密码设计中的搅拌过程非常相似。=
=此外，由于内部状态可以代表整个处理过程中的全部中间状态， 因此有利于节约内存。=
=Keccak用到了很多比特单位的运算，因此被认为可以有效抵御针对字节单位的攻击。=
**** 函数 Keccak-f[b]
b = r + c
Keccak 的函数实际上应该叫作 Keccak-f[b]，从这个名称可以看出，这个函数带有一个参数b， =即内部状态的比特长度。=
=这里的参数b称为宽度（width）。=

宽度b可以取25、50、100、200、400、800、1600共7种值， SHA-3采用的是其中的最大宽度，即b=1600。
  都是25的整数倍

一片slice 的大小为5x5=25个比特，因此 $\frac{b}{25}$ 就相当于 slice 的片数（即lane 的长度）。
SHA-3 的内部状态大小为 =5x5x64=1600 个比特。
无论如何改变宽度b，slice 的大小依然是5x5，改变的只是lane 的长度而已，因此 Keccak 宽度的变化并不会影响其基本结构。

=Keccak-f[b] 中的每一轮包含5个步骤：$\theta$, $\rho$, $\pi$, $X$, $t$, 总共缓缓12 + 2 $log_{2}^{\frac{b}{25}}$ 轮。=
具体到 SHA-3中所使用的 Keccak-f［1600］ 函数，其循环轮数为24轮。
***** 步骤 $\theta$
对其中1个比特应用步骤 $\theta$ 时的情形，这一步的操作是将位置不同的两个 column 中各自5个比特通过XOR运算加起来（图中的 $\sum$ 标记），然后再与置换目标比特求 XOR 并覆盖掉目标比特。
[[./pictures/cryptography/60.png]]
***** 步骤$\rho$
这一步的操作是沿z轴（lane 方向）进行比特平移。
[[./pictures/cryptography/61.png]]
***** 步骤$\pi$
对其中1片 slice 应用步骤时的情形，实际上整条lane 上的所有 slice 都会被执行同样的比特移动操作。
[[./pictures/cryptography/62.png]]
***** 步骤$X$
对其中1个row 应用步骤x时的情形。
[[./pictures/cryptography/63.png]]
***** 步骤$t$
用一个固定的轮常数对整个 state 的所有比特进行 XOR运算， =目的是让内部状态具备非对称性。=

根据《散列函数 SHA-224、SHA-512/224、SHA-512/256 和 SHA-3（Keccak）的实现评估》 ［Sakiyama］，
=除了步骤 $\theta$ 中的奇偶性处理（ $\sum$ 标记）以及步骤 $X$ 中的 NOT 和AND以外，其余的操作仅通过硬件电路就都可以实现。=
**** 对 Keccak 的攻击
=Keccak之前的单向散列函数都是通过循环执行压缩函数的方式来生成散列值的= ，
这种方式称为 =MD结构 ( Merkle-Damgard construction)。=
  MD4, MDS, RIPEMD, RIPEMD-160, SHA-1, SHA-2等几乎所有的传统单向散列函数算法都是基于 MD 结构的。

当初之所以开始征集SHA-3算法，就是因为针对当时广泛使用的SHA-1算法已经出现了理论上可行的攻击方法。
为了规避SHA-1 的风险，SHA-2应运而生，但SHA-2依然是基于和 SHA-1 相同的MD结构，针对 SHA-1 的攻击方式很有可能也会适用于SHA-2，问题没有得到根本解决。
Keccak 则采用了和 MD 结构完全不同的海绵结构，因此针对SHA-1 的攻击方法对 Keccak 是无效的。
**** 对缩水版 Keccak 的攻击竞赛
Keccak 的设计者还举办了名叫 Keccak Crunchy Crypto Collision and Pre-image Contest 的相关“竞赛”，内容就是对缩水版的 Keccak 进行攻击。
在竞赛中使用的缩水版 Keccak 比标准版减少了迭代轮数，参赛者可以通过改变宽度b等各种方法来进行攻击。
*** 应该使用哪种单向散列函数呢
首先，MD5 是不安全的，因此不应该使用。

SHA-1 除了用于对过去生成的散列值进行校验之外，不应该被用于新的用途，而是应该迁移到 SHA-2。

SHA-2 有效应对了针对 SHA-1 的攻击方法，因此是安全的，可以使用。

SHA-3 是安全的，可以使用。

2013年发布的《CRYPTREC 密码清单》中，SHA-2（SHA-256、SHA-384、SHA-512）被列入了“电子政府推荐使用的密码清单”中。

=和对称密码算法一样，我们不应该使用任何自制算法。=
*** 对单向散列函数的攻击
**** 暴力破解（攻击故事1）
在不改变散列值的前提下，修改内容。
根据内容冗余性，找到相同的散列值。

=暴力破解需要尝试的次数可以根据散列值的长度计算出来。=
 以 SHA3-512 为例，由于它的散列值长度为512比特，因此最多只要尝试 $2^{512}$ 次就能够找到目标消息了，如此多的尝试次数在现实中是不可能完成的。

找出具有指定散列值的消息的攻击分为两种，即“原像攻击”和“第二原像攻击”。
=原像攻击（Pre-Image Attack） 是指给定一个散列值，找出具有该散列值的任意消息；=
=第二原像攻击 （Second Pre-Image Altack）是指给定一条消息1，找出另外一条消息2，消息2的散列值和消息 1相同。=
**** 生日攻击（攻击故事2）
找到散列值相同的两条消息，而散列值则可以是任意值。

这样的攻击，一般称为 =生日攻击（birthday attack）= 或者 =冲突攻击（collision attack）= ，
这是一种试图破解单向散列函数的“强抗碰撞性”的攻击。

=生日悖论 (birthday paradox)=
在这 N个人中，如果要保证至少有两个人生日一样的概率大于二分之一，那么N至少是多少？（排除2月29日的情况）
$P = 1 - \frac{365 \times 364 \times \dots \times (365 - N + 1)}{365^{N}}$
当N取23时，这个值约等于 0.507297，大于二分之一。

=生日攻击的原理就是来自生日悖论，也就是利用了“任意散列值一致的概率比想象中要高”这样的特性。=

下面我们将生日问题一般化，即：“假设一年的天数为Y天，那么N人的集合中至少有两个人生日一样的概率大于二分之一时，N至少是多少？”
$N = \sqrt{Y}$
假设Alice 所使用的单向散列函数的散列值长度为M比特，则M比特所能产生的全部散列值的个数为 $2^M$ 个（这相当于“一年的天数Y“）。
$N = \sqrt{Y} = \sqrt{2^{M}} = 2^{\frac{M}{2}}$
我们以 512 比特的散列值为例，对单向散列函数进行暴力破解所需要的尝试次数为 $2^{512}$ 次， 而对同一单向散列函数进行生日攻击所需的尝试次数为 $2^{256}$ 次，因此和暴力破解相比，生日攻击所需的尝试次数要少多。
*** 单向散列函数无法解决的问题
=单向散列函数能够辨别出“篡改”，但无法辨别出“伪装”。=

我们还需要进行 =认证。=

用于认证的技术包括 =消息验证码和数字签名。=
=消息认证码能够向通信对象保证消息没有被篡改，=
=而数字签名不仅能够向通信对象保证消息没有被篡改，还能够向所有第三方做出这样的保证。=

=认证需要使用密钥，也就是通过对消息附加 Alice 的密钥（只有 Alice 才知道的秘密信息） 来确保消息真的属于 Alice。=
** 消息认证码 — 消息被正确传送了吗
=使用消息认证码可以判断消息是否被篡改，以及是否有人伪装成发送者发送了该消息。=

密码学家工具箱中6个重要的工具 : =对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器。=


消息的完整性（integrity）/ 一致性
  =消息没有被篡改=

消息的认证（authentication）
  =“消息来自正确的发送者”这一性质。=

=消息认证码（Message Authentication Code）是一种确认完整性并进行认证的技术=

=消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥=
=输出固定长度的数据，这个数据称为MAC值。=

=消息认证码中则需要使用发送者与接收者之间共享的密钥。=
  消息认证码正是利用这一性质来完成认证的。

此外，和单向散列函数的散列值一样，哪怕消息中发生1比特的变化，MAC值也会产生变化，
  消息认证码正是利用这一性质来确认完整性的。

暂且这样理解： =消息认证码是一种与密钥相关联的单向散列函数=

[[./pictures/cryptography/64.png]]
*** 消息认证码的使用步骤
[[./pictures/cryptography/65.png]]
*** 消息认证码的密钥配送问题
发送者和接收者需要共享密钥，这一点和我们在第3章中介绍的对称密码很相似。

对称密码的密钥配送问题在消息认证码中也同样会发生。

=要解决密钥配送问题，我们需要像对称密码一样使用一些共享密钥的方法，=
=例如公钥密码、Diffie-Hellman 密钥交换、密钥分配中心，或者使用其他安全的方式发送密钥等。=
至于使用哪种配送方法，则需要根据具体的目的来进行选择。
[[*公钥密码 — 用公钥加密，用私钥解密]]
*** 消息认证码的应用实例
**** SWIFT
SWIFT 的全称是 Society for Worldwide Interbank Financial Telecommunication（环球银行金融电信协会），是于1973年成立的一个组织，其目的是为国际银行间的交易保驾护航。
银行和银行之间是通过 SWIFT 来传递交易消息的。
=而为了确认消息的完整性以及对消息进行验证，SWIFT 中使用了消息认证码。=
=在使用公钥密码进行密钥交换之前，消息认证码所使用的共享密钥都是由人来进行配送的。=
**** IPsec
IPsec 是对互联网基本通信协议——IP 协议（Internet Protocol）增加安全性的一种方式。

=在 IPsec 中，对通信内容的认证和完整性校验都是采用消息认证码来完成的。=
**** SSL/TLS
SSL/TLS 是我们在网上购物等场景中所使用的通信协议。

=SSL/TLS 中对通信内容的认证和完整性校验也使用了消息认证码。=
*** 消息认证码的实现方法
**** 使用单向散列函数实现
=使用 SHA-2 之类的单向散列函数可以实现消息认证码，其中一种实现方法称为HMAC，具体步骤我们将在下节介绍。=
**** 使用分组密码实现
=使用 AES 之类的分组密码可以实现消息认证码。=
[[*AES (Advanced Encryption Standard) -- 取代其前任标准（DES）而成新标准的一种对称密码算法]]

=将分组密码的密钥作为消息认证码的共享密钥来使用，并用CBC模式（第4章）将消息全部加密。=
[[*分组密码的模式 — 分组密码是如何迭代的]]
  此时，初始化向量（IV）是固定的。
  由于消息认证码中不需要解密，因此将除最后一个分组以外的密文部分全部丢弃，而将最后一个分组用作MAC值。
  由于 CBC模式的最后一个分组会受到整个消息以及密钥的双重影响，因此可以将它用作消息认证码。
  例如，AES-CMAC （RFC4493） 就是一种基于 AES 来实现的消息认证码。
**** 其他实现方法
=使用流密码和公钥密码等也可以实现消息认证码。=
*** 认证加密
2000年以后，关于认证加密（缩写 AE或AEAD）的研究逐步展开。

=认证加密是一种将对称密码与消息认证码相结合，同时满足机密性、完整性和认证三大功能的机制。=

有一种认证加密方式叫作 Encrypt-then-MAC，
=这种方式是先用对称密码将明文加密，然后计算密文的MAC值。=
在 Encrypt-then-MAC方式中，消息认证码的输入消息是密文，通过MAC 值就可以判断“这段密文的确是由知道明文和密钥的人生成的”。
使用这一机制，我们可以防止攻击者 Mallory 通过发送任意伪造的密文，并让服务器解密来套取信息的攻击。

除了 Encrypt-then-MAC之外，还有其他一些认证加密方式，
如 =Encrypt-and-MAC（将明文用对称密码加密，并对明文计算 MAC值）=
和 =MAC-then-Encrypt（先计算明文的MAC值，然后将明文和 MAC值同时用对称密码加密）。=
**** GCM 与 GMAC
GCM（ Galois/Counter Mode）是一种认证加密方式。

=GCM 中使用AES 等128比特分组密码的CTR模式，=
[[*AES (Advanced Encryption Standard) -- 取代其前任标准（DES）而成新标准的一种对称密码算法]]
[[*CTR模式]]
=并使用一个反复进行加法和乘法运算的散列函数来计算 MAC值 。=

=由于 CTR 模式的本质是对递增的计数器值进行加密，因此可通过对若干分组进行并行处理来提高运行速度。=
[[*CTR模式的特点]]
此外，由于CTR 模式加密与 MAC值的计算使用的是相同的密钥，因此在密钥管理方面也更加容易。

专门用于消息认证码的GCM称为GMAC。

在《CRYPTREC 密码清单》[CRVPTRECI]中，GCM和CCM（CRC Counter Mode）都被列头了推荐使用的认证加密方式。
*** HMAC的详细介绍
HMAC 是一种 =使用单向散列函数来构造消息认证码的方法（RFC2104）= ，其中HMAC的H 就是 Hash的意思。

HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于HMAC
  使用SHA-1、SHA-224、SHA-256、SHA-384、SHA-512所构造的HIMAC，分别称为HMAC-SHA1, HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, HMAC-SHA-512.

[[./pictures/cryptography/66.png]]


（1）密钥填充
    如果密钥比单向散列函数的分组长度要短，就需要在末尾填充0，直到其长度达到单向散列函数的分组长度为止。
    如果密钥比分组长度要长，则要用单向散列函数求出密钥的散列值，然后将这个散列值用作 HMAC的密钥。
（2）填充后的密钥与 ipad 的 XOR
    将填充后的密钥与被称为 ipad 的比特序列进行XOR运算。
      ipad 是将00110110这一比特序列（即16进制的36）不断循环反复直到达到分组长度所形成的比特序列，其中ipad的i是 inner（内部）的意思。
    XOR运算所得到的值，就是一个和单向散列函数的分组长度相同，且和密钥相关的比特序列。
    这里我们将这个比特序列称为ipadkey。
（3）与消息组合
    =将和密钥相关的比特序列（ipadkey）附加在消息的开头。=
（4）计算散列值
    将（3）的结果输入单向散列函数，并计算出散列值。
（5）填充后的密钥与 opad 的XOR
    将填充后的密钥与被称为 opad 的比特序列进行XOR运算。
      opad 是将01011100这一比特序列（即16进制的5c）不断循环反复直到达到分组长度所形成的比特序列，其中opad的。是 outer（外部）的意思。
    XOR运算所得到的结果也是一个和单向散列函数的分组长度相同，且和密钥相关的比特序列。
    这里我们将这个比特序列称为 opadkey。
（6） 与散列值组合
    =将（4）的散列值拼在 opadkey 后面。=
（7） 计算散列值
    将（6）的结果输入单向散列函数，并计算出散列值。这个散列值就是最终的MAC值。

=最后得到的MAC值，一定是一个和输入的消息以及密钥都相关的长度固定的比特序列。=
*** 对消息认证码的攻击
**** 重放攻击
[[*对 CFB 模式的攻击]]

狡猾的主动攻击者 Mallory 想到可以通过将事先保存的正确 MAC值不断重放来发动攻击

有几种方法可以防御重放攻击。
***** 序号
约定每次都对发送的消息赋予一个递增的编号（序号），并且在计算 MAC值时将序号也包含在消息中。
这样一来，由于 Mallory无法计算序号递增之后的MAC值，因此就可以防御重放攻击。
=这种方法虽然有效，但是对每个通信对象都需要记录最后一个消息的序号。=
***** 时间戳
约定在发送消息时包含当前的时间，如果收到以前的消息，即便MAC值正确也将其当做错误的消息来处理，这样就能够防御重放攻击。
=这种方法虽然有效，但是发送者和接收者的时钟必须一致，而且考虑到通信的延迟，必须在时间的判断上留下缓冲，于是多多少少还是会存在可以进行重放攻击的空间。=
[[./pictures/cryptography/67.png]]
***** nonce
=在通信之前，接收者先向发送者发送一个一次性的随机数，这个随机数一般称为 nonce。=

发送者在消息中包含这个 nonce并计算 MAC值。
=由于每次通信时 nonce 的值都会发生变化，因此无法进行重放攻击。=
=这种方法虽然有效，但通信的数据量会有所增加。=
**** 密钥推测攻击
和对单向散列函数的攻击一样，对消息认证码也可以进行 =暴力破解以及生日攻击。=
[[*对单向散列函数的攻击]]

=对于消息认证码来说，应保证不能根据MAC值推测出通信双方所使用的密钥。=
如果主动攻击者 Mallory 能够从 MAC值反算出密钥，就可以进行篡改、伪装等攻击。
  例如HMAC中就是利用单向散列函数的单向性和抗碰撞性来保证无法根据 MAC值推测出密钥的。

此外， =在生成消息认证码所使用的密钥时，必须使用密码学安全的、高强度的伪随机数生成器。=
    如果密钥是人为选定的，则会增加密钥被推测的风险。
*** 消息认证码无法解决的问题
=使用消息认证码可以判断消息是否被篡改，以及是否有人伪装成发送者发送了该消息。=

=1.对第三方证明=
=2.防止否认=
** 数字签名 — 消息到底是谁写的
=使用数字签名可以识别篡改和伪装，还可以防止否认。=
*** 消息认证码的局限性
=消息认证码可以校验消息的完整性，还可以对消息进行认证。=
=消息认证码无法防止否认。=
  因为消息认证码需要在发送者 Alice 和接收者 Bob两者之间共享同一个密钥。
  =正是因为密钥是共享的，所以能够使用消息认证码计算出正确 MAC 值的并不只有发送者 Alice，接收者 Bob 也可以计算出正确的MAC值。=
  由于 Alice 和 Bob 双方都能够计算出正确的 MAC值，
  =因此对于第三方来说，我们无法证明这条消息的确是由 Alice 生成的。=
*** 通过数字签名解决问题
=Alice 和 Bob 各自使用不同的密钥。=

=数字签名（digital signature）=
  当Alice 发送消息时，她用私钥生成一个“签名”。
  相对地，接收者Bob 则使用一个和 Alice 不同的密钥对签名进行验证。
    =使用Bob 的密钥无法根据消息生成签名，但是用Bob的密钥却可以对 Alice 所计算的签名进行验证，也就是说可以知道这个签名是否是通过 Alice 的密钥计算出来的。=
*** 签名的生成和验证
=1.生成消息签名=
 发送者 “对消息签名”
 实际上根据消息内容计算数字签名的值，这个行为意味着“我认可该消息的内容”。
=2.验证数字签名=
 由消息的接收者来完成的，但也可以由需要验证消息的第三方来完成
 验证签名就是检查该消息的签名是否真的属于 Alice

=在数字签名中，生成签名和验证签名这两个行为需要使用各自专用的密钥来完成。=

Alice使用“签名密钥”来生成消息的签名，而Bob 和Victor则使用“验证密钥”来验证消息的签名。
数字签名对签名密钥和验证密钥进行了区分， =使用验证密钥是无法生成签名的。=
=此外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。=

公钥密码和上面讲的数字签名的结构非常相似。

=在公钥密码中，密钥分为加密密钥和解密密钥，用加密密钥无法进行解密。=
=此外，解密密钥只能由需要解密的人持有，而加密密钥则是任何需要加密的人都可以持有。=
=简而言之，数字签名就是通过将公钥密码“反过来用”而实现的。=

|            | 私钥              | 公钥                   |
|------------+-------------------+------------------------|
| 公钥密码    | 接收者解密时使用    | 发送者加密时使用         |
| 数字签名    | 签名者生成签名时使用 | 验证者验证签名时使用      |
| 谁持有密钥？ | 个人持有           | 只要需要，任何人都可以持有 |
*** 公钥密码与数字签名

=公钥密码机制。=
  =公钥密码包括一个由公钥和私钥组成的密钥对，其中公钥用于加密，私钥用于解密。=
  
[[./pictures/cryptography/68.png]]

数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和公钥密码是相反的，
=即用私钥加密相当于生成签名，而用公钥解密则相当于验证签名。=

[[./pictures/cryptography/69.png]]

用公钥加密所得到的密文，只能用与该公钥配对的私钥才能解密；
同样地，用私钥加密所得到的密文，也只能用与该私钥配对的公钥才能解密。
也就是说，如果用某个公钥成功解密了密文，那么就能够证明这段密文是用与该公钥配对的私钥进行加密所得到的。

=用私钥进行加密这一行为只能由持有私钥的人完成，正是基于这一事实，我们才可以将用私钥加密的密文作为签名来对待。=

[[./pictures/cryptography/70.png]]

=由于公钥是对外公开的，因此任何人都能够用公钥进行解密，这就产生了一个很大的好处， 即任何人都能够对签名进行验证。=

[[./pictures/cryptography/71.png]]
*** 数字签名的方法
**** 直接对消息签名的方法
[[./pictures/cryptography/72.png]]
**** 对消息的散列值签名的方法
一般都使用这种方法。

直接对消息签名的方法，但这种方法需要对整个消息进行加密， =非常耗时= ，这是因为公钥密码算法本来就非常慢。
[[*公钥密码无法解决的问题]]

能不能生成一条很短的数据来代替消息本身呢？
从密码学家的工具箱里面找找看，果然找到了一个跟我们的目的十分契合的工具，  =它就是第7章中介绍的单向散列函数。=

先用单向散列函数求出消息的散列值，然后再将散列值进行加密（对散列值签名）就可以了。
无论消息有多长，散列值永远都是这么短，因此对其进行加密（签名）是非常轻松的。

[[./pictures/cryptography/73.png]]

[[./pictures/cryptography/74.png]]
*** 对数字签名的疑问
**** 用私钥加密消息得到签名，然后再用公钥解密消息并验证签名，这个过程我理解了，但是密文为什么能够具备签名的意义呢？
数字签名是利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的。

这里所生成的密文并非被用于保证机密性，而是被用于代表一种只有持有该密钥的人才能够生成的信息。

这样的信息一般称为 =认证符号（authenticator）= ，消息认证码也是认证符号的一种，数字签名也是一样。

数字签名是通过使用私钥进行加密来产生认证符号的。
**** 上图，消息没有经过加密就发送了，这样不就无法保证消息的机密性了吗？
的确如此，数字签名的作用本来就不是保证机密性。

如果需要保证机密性，则可以不直接发送消息，而是将消息进行加密之后再发送。

=关于密码和签名的组合方法，我们会在第13章中详细介绍。=
**** 数字签名只不过是计算机上的一种数据，貌似很容易被复制。但如果可以轻易复制出相同的内容，那还能用作签名吗？
数字签名可以附加在消息的末尾，也可以和消息分离，单独作为文件来发送，但无论如何，我们都可以像复制普通的文件一样，很容易地复制出任意个内容相同的副本。

但是，签名可以被复制，并不意味着签名就没有意义，因为签名所表达的意义是特定的签名者对特定的消息进行了签名，即便签名被复制，也并不会改变签名者和消息的内容。

签名是不是原件并不重要，真正重要的是特定的签名者与特定的消息绑定在了一起这一事实。
**** 数字签名只不过是普通的数据，消息和签名两者都是可以任意修改的，这样的签名还有意义吗？
数字签名所要实现的并不是防止修改，而是识别修改。

修改没问题，但验证签名会失败。
**** 能不能同时修改消息和签名，使得验证签名能够成功呢？
事实上是做不到的。

以对散列值签名为例，只要消息被修改1比特，重新计算的散列值就会发生很大的变化， 要拼凑出合法的签名，必须在不知道私钥的前提下对新产生的散列值进行加密，事实上这是无法做到的，因为不知道私钥就无法生成用该私钥才能生成的密文。

这个问题相当于对数字签名的攻击，我们稍后会更加详细地讲解。
**** 如果得到了某人的数字签名，应该就可以把签名的部分提取出来附加在别的消息后面，这样的签名还有效吗？
的确，可以将签名部分提取出来并附加到别的消息后面，但是验证签名会失败。

数字签名中，签名和消息之间是具有对应关系的，消息不同签名内容也会不同，因此事实上是无法做到将签名提取出来重复使用的。
**** 带有数字签名的借据只是计算机文件，将其删除也无法保证确实已经作废，因为不知道其他地方是否还留有副本。无法作废的签名是不是非常不方便呢？
的确，带有数字签名的借据即便删除掉也无法作废，要作废带有数字签名的借据，可以重新创建一份相当于收据的文书，并让对方在这份文书上加上数字签名。

=也可以在消息中声明该消息的有效期并加上数字签名，例如公钥的证书就属于这种情况， 关于这一点，我们将在第10章中详细介绍。=
**** 消息认证码无法防止否认，为什么数字签名就能够防止否认呢？
在消息认证码中，能够计算 MAC值的密钥（共享密钥）是由发送者和接收者双方共同持有的，因此发送者和接收者中的任何一方都能够计算 MAC值，发送者也就可以声称“这个MAC 值不是我计算的，而是接收者计算的”。

相对地，在数字签名中，能够生成签名的密钥（私钥）是只有发送者才持有的，只有发送者才能够生成签名，因此发送者也就没办法说“这个签名不是我生成的”了。
*** 数字签名的应用实例
**** 安全信息公告
一些信息安全方面的组织会在其网站上发布一些关于安全漏洞的警告，那么这些警告信息是否真的是该组织所发布的呢？我们如何确认发布这些信息的网页没有被第三方篡改呢？

信息发布的目的是尽量让更多的人知道，因此我们没有必要对消息进行加密，但是必须排除有人恶意伪装成该组织来发布假消息的风险。

因此，我们不加密消息，而只是对消息加上数字签名， =这种对明文消息所施加的签名，一般称为明文签名（clearsign）。=
**** 软件下载
为了防止出现这样的问题，软件的作者可以对软件加上数字签名，而我们只要在下载之后验证数字签名，就可以识别出软件是否遭到了主动攻击者 Mallory 的篡改。

一种名为带签名的 Applet的软件就是一个具体的例子。
  这种软件是用Java 编写的（一种浏览器进行下载并执行的软件），并加上了作者的签名，而浏览器会在下载之后对签名进行验证。

此外，智能手机上广泛使用的 Android操作系统中是无法安装没有数字签名的应用软件的。
  =在签署数字签名时，为了识别应用开发者的身份，需要使用第10章中将要介绍的“证书”。=
  =不过这个证书只被用来识别应用开发者的身份等信息，并不是经过认证机构（Certificate Authority） 签名的。=
**** 公钥证书
=在验证数字签名时我们需要合法的公钥，那么怎么才能知道自己得到的公钥是否合法呢？=

=我们可以将公钥当作消息，对它加上数字签名。=
=像这样对公钥施加数字签名所得到的就是公钥证书，=
关于证书我们会在第10章详细介绍。
**** SSL/TLS
=SSL/TLS 在认证服务器身份是否合法时会使用服务器证书，它就是加上了数字签名的服务器公钥。=
=相对地，服务器为了对客户端（用户）进行认证也会使用客户端证书。=
关于SSL/TLS 我们会在第14 章详细介绍。
*** 通过 RSA 实现数字签名
[[*从时钟指针到 RSA]]

这里我们只讲解一下生成和验证签名的过程。

此外，为了简单起见，我们不使用单向散列函数，而是直接对消息进行签名。

=关于将 RSA 和单向散列函数相结合来进行数字签名的详细说明，请参见 RFC 3447(Public-Key Cryptography Standards(PKCS)#1)。=
**** 用RSA 生成签名
在RSA中，被签名的消息、密钥以及最终生成的签名都是以数字形式表示的。

=在对文本进行签名时，需要事先将文本编码成数字。=

~签名 = 消息^{D} mod N~ （用RSA生成签名）

=D和N就是签名者的私钥。=
[[*从时钟指针到 RSA]]

生成签名后， =发送者就可以将消息和签名发送给接收者了。=
**** 用RSA 验证签名

~由签名求得的消息 = 签名^{E} mod N~ （用RSA验证签名）

=E和N就是签名者的公钥=
[[*从时钟指针到 RSA]]

将其与发送者直接发送过来的“消息”内容进行对比。
如果两者一致则签名验证成功，否则签名验证失败。

| 公钥    | 数E和数N                                                         |
| 私钥    | 数D和数N                                                         |
| 生成签名 | 签名 = 消息^{D} mod N                                            |
| 验证签名 | 由签名求得的消息 = 签名^{E} mod  N，将“由签名求得的消息”与“消息”进行对比 |
**** 具体实践一下吧
公钥: E = 5; N = 323
私钥: D = 29; N = 323
=由于N为323，因此消息需要力0~322这个范围内的整数。=
[[*具体实践一下吧]]
=要加密的明文必须是小于N的数，也就是小于323的数，这是因为在加密运算中需要求 mod N。=
=由于解密运算时也需要求 mod N，而mod N的结果必定小于N，因此如果明文本身大于N，则解密后无法得到正确的明文。=

生成签名
用私钥（D, N）=（29, 323）来生成消息 123的签名。

~消息^{D} mod N~
~= 123^{29} mod 323~
~= 157~

向接收者发送的内容为：（消息，签名）=（123,157）

验证签名

接受者收到的内容为：（消息，签名）=（123, 157）

用公钥（E, N） =（5, 323）来计算由签名求得的消息。
~签名^{E} mod N~
~= 157^{5} mod 323~
~= 123~

我们得到的消息 123与发送者直接发送过来的消息 123是一致的，因此签名验证成功。
*** 其他的数字签名
**** EIGamal 方式
EIGamal 方式是由 Taher EIGamal设计的公钥算法，利用了在 mod N 中求离散对数的困难度。
=EIGamal 方式可以被用于公钥密码和数字签名。=
**** DSA
DSA （Digital Signature Algorithm） 是一种数字签名算法，是由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所）于1991年制定的数字签名规范（DSS）。
=DSA 是 Schnorr 算法与 EIGammal方式的变体，只能被用于数字签名。=
**** ECDSA
ECDSA （Elliptic Curve Digital Signature Algorithm）是一种 =利用椭圆曲线密码来实现的数字签名算法（NIST FIPS 186-3）。=
**** Rabin方式
Rabin 方式是由M.O.Rabin 设计的公钥算法，利用了在 mod N中求平方根的困难度。
=Rabin 方式可以被用于公钥密码和数字签名。=
*** 对数字签名的攻击
**** 中间人攻击
对数字签名的中间人攻击，
具体来说就是主动攻击者 Mallory 介入发送者和接收者的中间，
=对发送者伪装成接收者，对接收者伪装成发送者=
从而能够在无需破解数字签名算法的前提下完成攻击。

=要防止中间人攻击，就需要确认自己所得到的公钥是否真的属于自己的通信对象。=

这里有一个简单的方法，
即 Alice 和Bob 分别用单向散列函数计算出散列值，然后在电话中相互确认散列值的内容即可。
=实际上，涉及公钥密码的软件都可以显示公钥的散列值，这个散列值称为指纹（fingerprint）。=

指纹（fingerprint） 是通过对公钥进行 单向哈希运算 得到的一个简短的唯一摘要，
  比如用 SHA-256 算出来一个 64 个字符的十六进制串。这个指纹很短，很容易口头确认，却能代表完整的公钥。
只要 Alice 和 Bob 各自用相同算法对公钥生成的指纹一致，就能确认这个公钥没有被篡改。

上面介绍的内容是关于人与人之间如何对公钥进行认证的，
实际上大多数情况下都是 =计算机程序之间来进行公钥的认证，这个时候就需要使用公钥的“证书”。=
**** 对单向散列函数的攻击
数字签名中所使用的单向散列函数必须具有 =抗碰撞性= ，
  否则攻击者就可以生成另外一条不同的消息，使其与签名所绑定的消息具有相同的散列值。
**** 利用数字签名攻击公钥密码

在RSA 中，生成签名的公式是： ~签名 = 消息^{D} mod N~
[[*通过 RSA 实现数字签名]]
这个公式和公钥密码中解密的操作是等同的，
[[*从时钟指针到 RSA]]
也就是说可以将“请对消息签名”这一请求理解为“请解密消息”。

=利用这一点，攻击者可以发动一种巧妙的攻击，即利用数字签名来破译密文。=

假设现在 Alice 和 Bob 正在进行通信，主动攻击者 Mallory 正在窃听。
Alice 用Bob 的公钥加密消息后发送给Bob，发送的密文是用下面的公式计算出来的。
  ~密文 = 消息^{E} mod N~
Mallory窃听到 Alice发送的密文并将其保存下来，由于 Mallory 想要破译这段消息，因此他给Bob 写了一封邮件。
  =将刚刚窃听到的密文作上述邮件的附件一起发送给Bob=
Bob 看到了 Mallory 的邮件，发现附件数据的确只是随机数据（但其实这是 Alice 用Bob 的公钥加密的密文）。
=于是 Bob 对附件数据进行签名=  
  ~签名 = 消息^{D} mod N~
[[./pictures/cryptography/75.png]]
Bob 的本意是对随机的附件数据施加数字签名，但结果却无意中解密了密文。

对于这样的攻击，我们应该采取怎样的对策呢？
=1.不要直接对消息进行签名，对散列值进行签名比较安全；=
=2.公钥密码和数字签名最好分别使用不同的密钥对。=
  实际上， GnuPG 和 PGP 都可以生成多个密钥对。
=3.绝对不要对意思不清楚的消息进行签名，尤其是不要对看起来只是随机数据的消息进行签名。=
**** 潜在伪造
=如果一个没有私钥的攻击者能够对有意义的消息生成合法的数字签名，那么这个数字签名算法一定是不安全的，因为这样的签名是可以被伪造的。=
即使攻击者无法对具体、有意义的消息（比如一封合同、一条交易）进行伪造签名，只要他能对任意随机消息（如一些随机比特串）生成看起来合法的签名，那么这个签名算法的安全性就存在问题。

=原始的 RSA 签名算法存在潜在伪造？=
  任何人都可以随便选一个 S，然后计算 S^e mod n 得到一个 M，这个 (M, S) 对就是一个“看起来合法”的签名消息对。
  虽然 M 很可能是毫无意义的随机比特串，但它确实能通过验签过程。因此就构成了潜在伪造。

为了应对潜在伪造，人们在改良 RSA 的基础上开发出了一种签名算法，叫作 =RSA-PSS （Probabilistic Signature Scheme）。=
=RSA-PSS 并不是对消息本身进行签名，而是对其散列值进行签名。=
=为了提高安全性，在计算散列值的时候还要对消息加盐（salt）。=
关于 RSA-PSS 的技术规范请参见2001年的 RFC3447（Public-Key Cryptography Standards（PKCS）#1:RSA Cryptography Specifications Version 2.1)
**** 其他攻击
=针对公钥密码的攻击方法大部分都能够被用于攻击数字签名，=
  例如用暴力破解来找出私钥， 或者尝试对RSA的N进行质因数分解等。
*** 各种密码技术的对比
**** 消息认证码与数字签名
消息认证码和本章介绍的数字签名很相似，都是用来校验完整性和进行认证的技术。

=通过对对称密码和公钥密码的对比来理解消息认证码与数字签名的区别。=

[[./pictures/cryptography/76.png]]
**** 混合密码系统与对散列值签名
=在混合密码系统中，消息本身是用对称密码加密的，而只有对称密码的密钥是用公钥密码加密的，=
即在这里对称密码的密钥就相当于消息。

=数字签名中也使用了同样的方法，即将消息本身输入单向散列函数求散列值， 然后再对散列值进行签名，=
在这里散列值就相当于消息。

=对称密码的密钥是机密性的精华，单向散列函数的散列值是完整性的精华。=
*** 数字签名无法解决的问题
=数字签名既可以识别出篡改和伪装，还可以防止否认。=

=但我们无法确定公钥属于真正的发送者=

=为了能够确认自己得到的公钥是否合法，我们需要使用证书。=
=所谓证书，就是将公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。=

签名 我的理解就是对这段“消息/内容”（原内容或散列值） 使用私钥 进行加密 
接受者解密后与传输的消息进行对比即可知道是否篡改、伪装和否认

=当然，这样的方法只是把问题转移了而已。=
=那么如何才能构筑一个可信的数字签名链条呢？又由谁来颁发可信的证书呢？=
=到这一步，我们就已经踏入了社会学的领域。=
=我们需要让公钥以及数字签名技术成为一种社会性的基础设施，即公钥基础设施（Public Key Infrastructure ），简称 PKI。=
** 证书 — 为公钥加上数字签名
如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。
本章要介绍的证书，就是用来对公钥合法性提供证明的技术。

公钥证书（Public-Key Certificate, PKC）里面记有姓名、组织、邮箱地址等个人信息
=，以及属于此人的公钥，并由认证机构（Certification Authority,Certifying Authority,CA）施加数字签名。=

=公钥证书也简称为证书（certificate）。=

=认证机构中有国际性组织和政府所设立的组织，也有通过提供认证服务来盈利的一般企业，此外个人也可以成立认证机构。=
  有名的认证机构包括 VeriSign 等， 稍后我们将使用赛门铁克的试用版 Classl Digital ID 服务来生成 Bob 的证书。

下图展示了 Alice 向Bob 发送密文的场景，
=在生成密文时所使用的Bob 的公钥是通过认证机构获取的。=
=认证机构必须是可信的=

[[./pictures/cryptography/77.png]]


=在这里，密钥对是由Bob 自己生成的，也可以由认证机构代为生成。=
=Trent 收到Bob 的公钥后，会确认所收到的公钥是否为 Bob 本人所有（参见专栏“身份确认和认证业务准则”）。=
  认证机构确认“本人”身份的方法和认证机构的认证业务准则（Certification Practice Statement, CPS）的内容有关。
  如果是政府部门运营的认证机构，可能就需要根据法律规定来进行身份确认。
  如果是企业面向内部设立的认证机构，那就可能会给部门负责人打电话直接确认。
  例如，赛门铁克的证书服务业务准则中将身份确认分为 Class1~3 共三个等级，如下所示。
    • Class 1：通过向邮箱发送邮件来确认本人身份
    • Class 2：通过第三方数据库来确认本人身份
    • Class 3：通过当面认证和身份证明来确认本人身份等级越高，身份确认越严格。

Trent 对Bob 的公钥加上数字签名。 =加数字签名是需要对部分“内容”进行签名，这里是Bob的公钥=
  为了生成数字签名，需要 Trent 自身的私钥，因此 Trent 需要事先生成好密钥对。
*** 实际生成一张证书
赛门铁克的 Digital ID 免费试用服务
赛门铁克提供了面向个人的证书（称为 Digital ID）服务，可供用户免费试用25天。
通过 Web 浏览器就可以马上颁发证书，身份确认是通过确认邮件来进行的（相当于 VeriSign Class 1 ）。

用密码软件 GnuPG中附带的 gpgsm 命令来显示一下生成的Bob 的证书的内容。
~gpgsm --import SelfService.action.p7s~ 导入证书文件
~gpgsm --dump-cert~ 显示证书内容
*** 证书标准规范

使用最广泛的是由 ITU （International Telecommunication Union， 国际电信联盟）和 ISO（ International Organization for Standardization， 国际标准化组织）制定的×.509_规范（RFC3280）。
很多应用程序都支持X.509 并将其作为证书生成和交换的标准规范。

| 证书序列号       |
| 证书颁发者       |
| 公钥所有者       |
| SHA-1 指纹      |
| MD5 指纹        |
| 证书 ID         |
| 有效期（起始时间） |
| 有效期（结束时间） |
| 散列算法         |
| 密钥类型         |
| 密钥 ID         |
| 密钥用途         |
*** 公钥基础设施（PKI）
仅制定证书的规范还不是以支持公钥的实际运用，我们还需要很多其他的规范，例如证书应该由谁来颁发，如何颁发，私钥泄露时应该如何作废证书，计算机之间的数据交换应采用怎样的格式等。

=公钥基础设施（Public-Key Infrastructure）是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。=
=公钥基础设施一般根据其英语缩写而简称为 PKI。=

PKI只是一个总称，而并非指某一个单独的规范或规格。
  例如，RSA公司所制定的PKCS（Public-Key Cryptography Standards，公钥密码标准）系列规范也是PKI的一种
  而互联网规格 RFC（Request for Comments）中也有很多与PKI相关的文档。
  上一节中我们提到的X.509这样的规范也是PKI 的一种。
  [[*证书标准规范]]
  =在开发 PKI 程序时所使用的由各个公司编写的API （Application Programming Interface，应用程序编程接口）和规格设计书也可以算是PKI 的相关规格。=

来简单总结一下 PKI的基本组成要素 =（用户、认证机构、 仓库）以及认证机构所负责的工作。=

关于 PKI 的详细内容，可以参考独立行政法人信息处理推进机构（IPA）关于 PKI 相关技术的说明页面（http://www.ipa.go.jp/security/pki/）。
**** PKI 的组成要素

用户 — 使用 PKI 的实体 人/计算机
认证机构 — 颁发证书的人
仓库 — 保存证书的数据库

[[./pictures/cryptography/78.png]]

用户包括两种：一种是希望使用 PKI注册自己的公钥的人，另一种是希望使用已注册的公钥的人。
【注册公钥的用户所进行的操作】
• 生成密钥对（也可以由认证机构生成）
• 在认证机构注册公钥
• 向认证机构申请证书
• 根据需要申请作废已注册的公钥
• 解密接收到的密文
• 对消息进行数字签名

【使用已注册公钥的用户所进行的操作】
• 将消息加密后发送给接收者
• 验证数字签名

=认证机构（Certification Authority,CA）是对证书进行管理的人。=
• 生成密钥对（也可以由用户生成）
    生成密钥对有两种方式：一种是由PKI用户自行生成，一种是由认证机构来生成。
    在认证机构生成用户密钥对的情况下，认证机构需要将私钥发送给用户，具体的方法在 RFC7292（PKCS#12:Personal Information Exchange Syntax V1.1）中进行了规定。
• 在注册公钥时对本人身份进行认证
• 生成并颁发证书
    在用户自行生成密钥对的情况下，用户会请求认证机构来生成证书。
    申请证书时所使用的规范是由 RFC2986（PKCS#10:Certification Request Syntax Specification Version 1.7）等定义的。
    认证机构根据其认证业务准则（Certification Practice Statement, CPS） 对用户的身份进行认证，并生成证书。
      =在生成证书时，需要使用认证机构的私钥来进行数字签名。=
      =生成的证书格式是由X.509定义的。=
      [[*证书 — 为公钥加上数字签名]]
• 作废证书
    =要作废证书，认证机构需要制作一张证书作废清单（Certificate Revocation List ），简称为CRL。=
    =CRL 是认证机构宣布作废的证书一览表，具体来说，是一张已作废的证书序列号的清单， 并由认证机构加上数字签名。=
    证书序列号是认证机构在颁发证书时所赋予的编号，在证书中都会记载。
    =PKI用户需要从认证机构获取最新的CRL，并查询自己要用于验证签名（或者是用于加密） 的公钥证书是否已经作废。=
      =这个步骤是非常重要的。=
    一般来说，这个检查不是由用户自身来完成的，而是应该由处理该证书的软件来完成，但有很多软件并没有及时更新CRL。

=公钥注册和本人身份认证这一部分可以由注册机构（Registration Authority,RA）来分担。=
这样一来，认证机构就可以将精力集中到颁发证书上，从而减轻了认证机构的负担。
=不过，引入注册机构也有弊端，比如说认证机构需要对注册机构本身进行认证， 而且随着组成要素的增加，沟通过程也会变得复杂，容易遭受攻击的点也会增加。=

=仓库=
仓库（repository）是一个保存证书的数据库，PKI 用户在需要的时候可以从中获取证书，它的作用有点像打电话时用的电话本。
=仓库也叫作证书目录。=
**** 证书的层级结构
到这里为止，认证机构已经对用户的公钥进行了数字签名，并生成了证书。
接下来用户需要使用认证机构的公钥，对证书上的数字签名进行验证。
=那么，对于用来验证数字签名的认证机构的公钥，怎样才能判断它是否合法呢？=
=对于认证机构的公钥，可以由其他的认证机构施加数字签名，从而对认证机构的公钥进行验证，即生成一张认证机构的公钥证书。=

一个认证机构来验证另一个认证机构的公钥，这样的关系可以迭代好几层。
这样一种认证机构之间的层级关系，我们可以用某公司的内部PKI来类比。

东京总公司（东京总公司认证机构）
  $\downarrow$
北海道分公司（北海道分公司认证机构）
  $\downarrow$
札幌办事处（札幌办事处认证机构）

假设Bob是札幌办事处的一名员工，札幌办事处员工的公钥都是由札幌办事处认证机构颁发的（因为这样更容易认证本人身份）。
对于札幌办事处认证机构的公钥，则由北海道分公司认证机构颁发证书，而对于北海道分公司认证机构的公钥，则由东京总公司认证机构颁发证书，以此类推⋯。

不过这个链条不能无限延伸，总要有一个终点，如果这个终点就是东京总公司认证机构（即不存在更高一层的认证机构） 的话，
=该认证机构一般就称为根CA（Root CA）。=
而对于东京总公司认证机构，则由东京总公司认证机构自己来颁发证书，
=这种对自己的公钥进行数字签名的行为称为自签名（self-signature）。=

东京总公司（东京总公司认证机构=根CA）
  $\downarrow$
北海道分公司（北海道分公司认证机构）
  $\downarrow$
札幌办事处（札幌办事处认证机构）
  $\downarrow$
札幌办事处员工Bob

=我的理解：证书 = 内容“下级的公钥” + 上级的私钥对内容进行的数字签名=

如此复杂的验证链条不会是由人来操作的，而是由电子邮件或者浏览器等软件自动完成的。
**** 各种各样的 PKI
=认证机构只要对公钥进行数字签名就可以了，因此任何人都可以成为认证机构，实际上世界上已经有无数个认证机构了。=

国家、地方政府、医院、图书馆等公共组织和团体可以成立认证机构来实现PKI，公司也可以出于业务需要在内部实现 PKI，甚至你和你的朋友也可以以实验为目的来构建 PKI。

日本所规定的PKI称为政府认证基础设施（GPKI）。在GPKI 中，规定了认证机构的层级、 业务规则、公钥注册及证书颁发等业务的具体办法。
  详细内容可参见 http://www.gpki.go.jp/。

[[./pictures/cryptography/79.png]]
*** 对证书的攻击
=由于证书实际上使用的就是数字签名技术，因此针对数字签名的所有攻击方法对证书都有效。=
下面我们主要来看一看 =针对 PKI 的攻击。=
[[*对数字签名的攻击]]
**** 在公钥注册之前进行攻击
假设 Bob生成了密钥对，并准备在认证机构注册自己的公钥。
在认证机构进行数字签名之前，主动攻击者Mallory 将公钥替换成了自己的。
这样一来，认证机构就会对“Bob 的个人信息”和 “Mallory的公钥”这个组合进行数字签名。

要防止这种攻击，我们可以采用下面的做法。
=例如 Bob 可以在将公钥发送给认证机构进行注册时，使用认证机构的公钥对 Bob 的公钥进行加密。=
[[*公钥密码 — 用公钥加密，用私钥解密]]
=此外，认证机构在确认 Bob 的身份时， 也可以将公钥的指纹一并发送给Bob 请他进行确认。=
[[*单向散列函数 - 获取消息的“指纹”]]
**** 注册相似人名进行攻击
证书是认证机构对公钥及其持有者的信息加上数字签名的产物，对于一些相似的身份信息， 计算机可以进行区别，
=但人类往往很容易认错= ，而这就可以被用来进行攻击。

要防止这种攻击，认证机构必须确认证书中所包含的信息是否真的是其持有者的个人信息， 当本人身份确认失败时则不向其颁发证书。
认证机构的 =认证业务规则= 中就规定了这样的方针。
[[*证书 — 为公钥加上数字签名]]
**** 窃取认证机构的私钥进行攻击
主动攻击者 Mallory 想出了一个大胆的攻击方法，那就是窃取认证机构的私钥。

=如果认证机构的私钥被窃取（泄露），认证机构就需要将私钥泄露一事通过CRL通知用户。=
**** 攻击者伪装成认证机构进行攻击
主动攻击者 Mallory 又想出了一个更加大胆的方法，那就是 Mallory 自己伪装成认证机构的攻击。

=如果认证机构本身不可信，即便证书合法，其中的公钥也不能使用。=
**** 钻 CRL 的空子进行攻击 （1）

Bob的私钥被 Mallory 盗用
Mallory 使用盗用的Bob私钥对邮件进行数字签名

从公钥失效到 Alice 收到证书作废清单（CRL）需要经过一段时间，主动攻击者 Mallory 可以 =利用 CRL发布的时间差来发动攻击。=

要防御上述这样利用 CRL 发布的时间差所发动的攻击是非常困难的。

因此，对于这种攻击的对策是：
• 当公钥失效时尽快通知认证机构（Bob）
• 尽快发布 CRL（Trent）
• 及时更新 CRL（Alice）
这些对策和信用卡的运营方法很相似。此外，我们还需要做到：
• 在使用公钥前，再次确认公钥是否已经失效（Alice）
**** 钻CRL 的空子进行攻击（2）
虽然数字签名能够防止否认，但通过钻CRL的空子，就有可能实现否认，这种方法实际上是“钻CRL 的空子进行攻击（1）”的另一种用法。

Bob 使用私钥告诉Alice给自己转账 然后向认证机构 Trent 发送了一封邮件告知自己的公钥已经失效
然后Bob告诉Alice：我的私钥被 Mallory 窃取了，因此我的数字签名已经失效了。现在钱估计已经被 Mallory 盗走了，真是抱歉。

=为了快速确认证书是否已经失效，人们设计了一种名为OCSP 的协议，详情请参见 RFC2560 (X.509 Internet Public Key Infrastructure Online Certificate Status Protocol ).=
**** Superfish
2015年，PC厂商联想（Lenovo）公司所销售的计算机发生了一起严重的事件，联想公司在其计算机中预装的广告软件 Superfish 可能会带来安全问题。

Superfish 是一款广告软件，它能够通过监听和收集用户通信中的个人信息来有针对性地展示广告。
=为了实现这一功能，Superfish会在系统中安装根证书，并劫持浏览器与服务器之间的通信，将网站的证书替换成自己的证书。=
=也就是说，这是一种典型的通过中间人攻击的方式来监听通信内容的行为。=

为了能够针对任意网站动态生成证书，Superfish 内置了用于生成数字签名的私钥。
也就是说，用户的计算机变成了一个不可信的认证机构 Trent，而且生成签名所需的口令只是一个简单的单词。
=这样一来，恶意软件就可以利用 Superfish 随意生成伪造的网站证书，使得钓鱼网站在用户的浏览器上看起来就像真正的网站一样，如果用户因此访问了假冒的银行网站，后果一定不堪设想。=

一般来说，我们都会注意新安装的软件是否可信，平时也会注意预防计算机病毒，但却基本上不会去怀疑我们所购买的计算机上预装的软件。
*** 基于 ID 的密码
=为了确保机密性我们需要密钥，为了解决密钥的配送问题我们又需要公钥密码，而为了防止公钥被伪造我们又需要证书…在这一信任的链条中，最后的终点是“对根CA 的信任”。=

这里的ID指的是“某种能够确定身份的信息”，一般指的是像邮箱地址、通信地址、姓名等能够确定某个具体的人的身份的信息。
=可以简单地理解为是一种直接用ID 来生成公钥的方法。=

举个例子，假设我们现在将邮箱地址作为ID 来使用。
=当 Alice 向 Bob 发送密文时，Alice 可以根据自己所知道的Bob的邮箱地址来生成Bob 的公钥，并使用这一公钥生成密文。=
在这一场景中，我们不需要使用证书来证明 Bob 的公钥的合法性， =因为 Alice 是使用自己已经认可的 Bob 的邮箱地址来生成公钥的。=
=也就是说，基于ID 的密码所依赖的是“对ID 本身的信任”，因此就不需要证书了。=

=基于ID 的密码虽然不需要认证机构，但却需要另一种机构，称为私钥生成机构（Private Key Generator,PKG）。=
=只有私钥生成机构才能够生成与ID 相对应的用于解密的私钥。=
由于ID 是公开信息，所有人都有可能知道，因此如果所有人都能根据ID 生成解密私钥的话，那就会出问题了。

总之，私钥生成机构负责根据ID 生成私钥，并将私钥安全发送给合法的接收者。
=另外，由于私钥生成机构拥有对所有密文的解密权限，因此自身的安全性需要特别注意。=

优点:
=例如发送者无需在加密之前取得接收者的公钥，=
=接收者在真正进行解密操作之前也无需管理自己的私钥。=
*** 关于证书的 Q&A
**** 我不理解证书的必要性。通过认证机构的证书来获取公钥，和直接获取公钥到底有什么不样呢？
=我的理解：证书 = 内容“下级的公钥” + 上级的私钥对内容进行的数字签名=

在通过不可信的途径（例如邮件）获取公钥时，可能会遭到中间人攻击。
  Alice 本来想要获取的是Bob 的公钥，但实际上得到的却可能是主动攻击者 Mallory 的公钥。
=如果从认证机构获取公钥，就可以降低遭到中间人攻击的风险。=
  因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法被篡改。

=但现在的问题是，我们又该如何获取认证机构本身的公钥呢？=

=相当于信任转移了...=
  Alice 将对 Bob 本人身份的确认这项工作委托给了认证机构。
  认证机构则将认可该公钥确实属于 Bob这一事实通过证书 （即对公钥进行的数字签名）传达给 Alice。

=如果能够取得可信的公钥，则不需要认证机构=
=当持有可信的认证机构公钥，并相信认证机构所进行的身份确认的情况下，则可以信任该认证机构颁发的证书以及通过该途径取得的公钥=
**** 无论是证书的格式还是PKI，使用公开的技术总觉得不放心。我觉得使用公开的技术就等于为攻击者提供了用于攻击的信息，相比之下，还是使用公司自己开发的保密的认证方法更安全吧？
不，这是错误的。

=自己开发保密的认证方法是犯了典型的隐蔽式安全（security by obscurity）错误。=
使用公开的技术的确会为攻击者提供用于攻击的信息，但与此同时，全世界的安全专家也在力这些公开的技术寻找漏洞。
=靠隐蔽来保证安全是错误的=
**** 我已经明白认证机构的作用了，但是我总觉得这件事说来说去还是一个死循环。为了相信公钥，就必须相信为该公钥颁发证书的认证机构，但是我为什么要相信这个认证机构呢？就算有另一个认证机构它做证明，那我为什么又要相信那个“另一个认证机构”呢？
在能够处理证书的电子邮件软件和 Web 浏览器中，已经包含了一些有名的认证机构的证书。

不管证书的链条是否具有层级结构，我们之所以信任某个认证机构，是因为那是我们基于多个可信的情报源所做出的判断。
* 密钥、随机数与应用技术
** 密钥 — 秘密的精华
*** 什么是密钥
=密钥就是一个巨大的数字=

在使用对称密码、公钥密码、消息认证码、数字签名等密码技术使用，都需要一个称为密钥（key）的巨大数字。

数字本身的大小并不重要，重要的是密钥空间的大小，也就是可能出现的密钥的总数量，因为密钥空间越大，进行暴力破解就越困难。
=密钥空间的大小是由密钥长度决定的。=

=DES的密钥=
[[*DES]]
对称密码 DES 的密钥的实质长度为56 比特（7字节）。

=三重DES的密钥=
[[*三重 DES]]
在对称密码三重 DES中，包括使用两个 DES密钥的 DES-EDE2 和使用三个 DES密钥的 DES-EDE3 两种方式。

DES-EDE2 的密钥的实质长度为112比特（14字节）
DES-EDE3 的密钥的实质长度为168比特（21字节）

=AES的密钥=
对称密码 AES 的密钥长度可以从128、192 和256比特中进行选择，当密钥长度为256比特时
[[*AES (Advanced Encryption Standard) -- 取代其前任标准（DES）而成新标准的一种对称密码算法]]
[[*Rijndael]]

密钥仅仅是一个比特序列（字节序列）

=密钥和明文的重要性是等价的=

=依靠隐藏密码算法本身的设计来确保信息的机密性是非常危险的。=


=如果需要一个高强度的密码算法，不应该自行开发，而是应该使用一个经过全世界密码学家共同验证的密码算法。=

=信息的机密性不应该依赖于密码算法本身，而是应该依赖于妥善保管的密钥。=

=这是密码世界的常识之一。=
*** 各种不同的密钥
**** 对称密码的密钥与公钥密码的密钥
在对称密码中，加密和解密使用同一个密钥。
由于发送者和接收者之间需要共享密钥，因此 =对称密码又称为共享密钥密码。=
对称密码中所使用的密钥必须对发送者和接收者以外的人保密，否则第三方就能够解密密文了。

[[./pictures/cryptography/80.png]]

在公钥密码中，加密和解密使用的是不同的密钥。
=用于加密的密钥称公钥= ，顾名思义它是可以被公开的；
=用于解密的密钥称为私钥= ，只有需要进行解密的接收者才持有私钥，私钥也称为秘密密钥。
相对应的公钥和私钥之间具有深刻的数学关系，因此也称为密钥对。

[[./pictures/cryptography/81.png]]
**** 消息认证码的密钥与数字签名的密钥
在消息认证码中，发送者和接收者使用共享的密钥来进行认证。

消息认证码只能由持有合法密钥的人计算出来。

将消息认证码附加在通信报文后面，就可以识别通信内容是否被篡改或伪装。

消息认证码的密钥必须对发送者和接收者以外的人保密，否则就会产生篡改和伪装的风险。

[[./pictures/cryptography/82.png]]

=在数字签名中，签名的生成和验证使用不同的密钥。只有持有私钥的本人才能够生成签名， 但由于验证签名使用的是公钥，因此任何人都能够验证签名。=

[[./pictures/cryptography/83.png]]
**** 用于确保机密性的密钥与用于认证的密钥
=对称密码和公钥密码的密钥都是用于确保机密性的密钥。=
  如果不知道用于解密的合法密钥， 就无法得知明文的内容。

=相对地，消息认证码和数字签名所使用的密钥，则是用于认证的密钥。=
  如果不知道合法的密钥，就无法篡改数据，也无法伪装本人的身份。
**** 会话密钥与主密钥
=会话密钥（session key ）=
  当我们访问以 https:// 开头的网页时，Web 服务器和浏览器之间会进行基于 SSL/TLS 的加密通信。
  在这样的通信中所使用的密钥是仅限于本次通信的一次性密钥，下次通信时就不能使用了。
  只能一次性使用的密钥有哪些好处呢？
    由于在下次通信中会使用新的密钥， 因此其他通信的机密性不会受到破坏。
=虽然每次通信都会更换会话密钥，但如果用来生成密钥的伪随机数生成器品质不好，窃听者就有可能预测出下次生成的会话密钥，这样就会产生通信内容被破译的风险。=

=主密钥（master key）=
  一直被重复使用的密钥
**** 用于加密内容的密钥与用于加密密钥的密钥
=CEK （Contents Encrypting Key，内容加密密钥）=
  加密的对象是用户直接使用的信息（内容）
=KEK （Key Encrypting Key，密钥加密密钥）=
  加密密钥的密钥

[[./pictures/cryptography/84.png]]

=在很多情况下，之前提到的会话密钥都是被作为CEK使用的，而主密钥则是被作为KEK 使用的。=
*** 密钥的管理
**** 生成密钥
***** 用随机数生成密钥
=生成密钥的最好方法就是使用随机数，因为密钥需要具备不易被他人推测的性质。=

最好使用能够生成密码学上的随机数的硬件设备，但一般我们都是使用伪随机数生成器

=密码学用途的伪随机数生成器必须是专门针对密码学用途而设计的。=
***** 用口令生成密钥
一般都是将口令输入单向散列函数，然后将得到的散列值作为密钥使用。

在使用口令生成密钥时，为了防止字典攻击，需要在口令上面附加一串称为 =盐（salt）的随机数= ，然后再将其输入单向散列函数。
这种方法称为“基于口令的密码” =（Password Based Encryption,PBE）= 。
**** 配送密钥
在使用对称密码时，如何在发送者和接收者之间共享密钥是一个重要的问题（即密钥配送问题）。

要解决密钥配送问题，可以采用 =事先共享密钥、使用密钥分配中心、使用公钥密码等方法。=
还有一种解决密钥配送问题的方法称为 =Diffie-Hellman 密钥交换=
[[*公钥密码 — 用公钥加密，用私钥解密]]
**** 更新密钥
=这种方法就是在使用共享密钥进行通信的过程中，定期（例如每发送1000个字）改变密钥。=

在更新密钥时，发送者和接收者使用单向散列函数计算当前密钥的散列值，并将这个散列值用作新的密钥。

窃听者却无法解密更新密钥这个时间点之前的通信内容，因为这需要用单向散列函数的输出（即当前密钥）反算出单向散列函数的输入（即上一个密钥）。
=由于单向散列函数具有单向性，因此就保证了这样的反算是非常困难的。=
[[*具备单向性]]
这种防止破译过去的通信内容的机制，称为 =后向安全（backward security ）。=
**** 保存密钥
当密钥需要重复使用时，就必须要考虑保存密钥的问题了。

人类无法记住密钥

=我们记不住密钥，但如果将密钥保存下来又可能会被窃取。=

1.将密钥保存成文件，并将这个文件保存在保险柜等安全的地方。
2.我们可以使用将密钥加密后保存的方法。当然，要将密钥加密，必然需要另一个密钥。（KEK）

对密钥进行加密的方法虽然没有完全解决机密性的问题，
但在现实中却是一个非常有效的方法，
=因为这样做可以减少需要保管的密钥数量。=

[[./pictures/cryptography/85.png]]

=用1个密钥来代替多个密钥进行保管的方法，和认证机构的层级化非常相似。=
在后者中， 我们不需要信任多个认证机构，而只需要信任一个根CA 就可以了。
**** 作废密钥
=密钥的作废和生成是同等重要的，这是因为密钥和明文是等价的。=

为什么要作废密钥？
如何作废密钥？
密钥丢了怎么办？
*** Diffie-Hellman 密钥交换
另一种解决密钥配送问题的方法

Diffie-Hellman 密钥交换( Diffie-Hellman key exchange) 是 1976 年由 Whitfield Diffie 和 Martin Hellman 共同发明的一种算法。

=使用这种算法，通信双方仅通过交换一些可以公开的信息就能够生成出共享的秘密数字，而这一秘密数字就可以被用作对称密码的密钥。=

IPsec 中就使用了经过改良的 Diffie-Hellman 密钥交换。

这种方法也称为 Diffie-Hellman 密钥协商（Diffie-Hellman key agreement )。

Diffie-Hellman 密钥交换的步骤
[[./pictures/cryptography/86.png]]

（1） Alice 向 Bob 发送两个质数P和G
     P必须是一个非常大的质数， =而G则是一个和P相关的数，称为生成元（generator）。=
     G可以是一个较小的数字。
     P和G不需要保密，被窃听者 Eve 获取也没关系。
     此外，P和G 可以由 Alice 和Bob 中的任意一方生成。
（2） Alice 生成一个随机数A
     A是一个1~P-2之间的整数。
     =这个数是一个只有 Alice知道的秘密数字，没有必要告诉 Bob，也不能让Eve 知道。=
（3） Bob 生成一个随机数 B
     B是一个1~P-2之间的整数。
     =这个数是一个只有Bob知道的秘密数字，没有必要告诉Alice，也不能让Eve 知道。=
（4） Alice 将 $G^{A} \  mod \  P$ 这个数发送给Bob
     =这个数让Eve 知道也没关系。=
（5） Bob 将 $G^{B} \ mod \  P$ 这个数发送给 Alice
     =这个数让Eve 知道也没关系。=
（6） Alice 用Bob发过来的数计算A次方并求 mod P
     =这个数就是共享密钥。=
     Alice 计算的密钥= $(G^{B} \  mod \  P)^{A} \  mod \  P$
     我们将上面的算式简化：
     Alice 计算的密钥= $G^{B \times A} \  mod \  P$
                   $=G^{A \times B} \  mod \  P$
     上面我们将 modP中的“G的B次方的A次方”改写成了“G的AxB次方”。
（7） Bob 用 Alice 发过来的数计算B次方并求 mod P
     Bob 计算的密钥=$(G^{A} \  mod \  P)^{B} \  mod \  P$
     我们将上面的算式简化
     Bob 计算的密钥$=G^{A \times B} \  mod \  P$
     上面我们将 modP中的“G的A次方的B次方”改写成了“G的Ax B次方”。
     于是， Alice 和Bob 就计算出了相等的共享密钥。
     =Alice 计算的密钥=Bob 计算的密钥=
**** Eve 能计算出密钥吗
双方交换的数字（即能够被窃听者Eve 知道的数字）一共有4个：P、G、$G^{A} \  mod \  P$、$G^{b} \  mod \  P$
=根据这4个数字计算出 Alice 和 Bob 的共享密钥 （$G^{A \times B} \  mod \  P$） 是非常困难的。=

=如果仅仅是 $G^{A}$ 的话，要计算出A并不难，然而根据 $G^{A} \  mod \  P$ 计算出A的有效算法到现在还没有出现，=
=这个问题称为有限域（finite field）的离散对数问题。=
=而有限域的离散对数问题的复杂度正是支撑 Diffe-Hellman 密钥交换算法的基础。=
**** 生成元的意义
已知P质数，让我们来想象一下 mod P的时钟运算。
[[*mod 运算]]

[[./pictures/cryptography/87.png]]

我们可以发现 $2^{1}$ 到 $2^{12}$ 的值（共12个）全都不一样。
也就是说，2的乘方结果中出现了1到 12的全部整数。
=由于2具备上述性质，因此称为13的生成元。=
同样地，6、7和11也是生成元。

=也就是说，P的生成元的乘方结果与1~P-1中的数字是一一对应的。=
=正是因为具有这样一一对应的关系，Alice 才能够从1~P-2的范围中随机选择一个数字=
=（之所以不能选择P-1， 是因为 $G^{P-1} \  mod \  P$  的值一定是等于1的）。=
=当然，从数学上看我们还必须证明对于任意质数P 都一定存在生成元G=
  但证明的过程在这里就不再阐述了。
**** 具体实践一下
（1） Alice 向 Bob 发送两个质数P和G
     P=13
     G=2
     =2是13的一个生成元。=
     [[*生成元的意义]]
（2） Alice 生成一个随机数A
     A是一个1~P-2之间的整数。
     A 是只有 Alice 知道的秘密数字。
     A=9
（3） Bob 生成一个随机数 B
     B是一个1~P-2之间的整数。
     B是只有Bob 知道的秘密数字。
     B = 7
（4） Alice 将 $G^{A} \  mod \  P$ 这个数发送给Bob
     $G^{A} \  mod \  P = 2^{9} \  mod \  13=5$
     =这个数让Eve 知道也没关系。=
（5） Bob 将 $G^{B} \ mod \  P$ 这个数发送给 Alice
     $G^{B} \  mod \  P = 2^{7} \  mod \  13=11$
     =这个数让Eve 知道也没关系。=
（6） Alice 用Bob发过来的数计算A次方并求 mod P
     =这个数就是共享密钥。=
     Alice 计算的密钥= $(G^{B} \  mod \  P)^{A} \  mod \  P = 11^{A} \  mod \  P = 11^{9} \  mod \  13 = 8$
（7） Bob 用 Alice 发过来的数计算B次方并求 mod P
     Bob 计算的密钥=$(G^{A} \  mod \  P)^{B} \  mod \  P = 5^{B} \  mod \  P = 5^{7} \  mod \  13 = 8$
     =这个数就是共享密钥。=
     =Alice 计算的密钥=Bob 计算的密钥=
**** 椭圆曲线 Diffie-Hellman 密钥交换
Diffie-Hellman 密钥交换是利用“离散对数问题”的复杂度来实现密钥的安全交换的，
=如果将“离散对数问题”改为“椭圆曲线上的离散对数问题”，=
这样的算法就称为椭圆曲线 Diffie- Hellman密钥交换。

=椭圆曲线 Diffie-Heliman 密钥交换在总体流程上是不变的，只是所利用的数学问题不同而已。=
=椭圆曲线 Diffie-Hellman 密钥交换能够用较短的密钥长度实现较高的安全性，详情请参见附录1中的介绍。=
*** 基于口令的密码（PBE）
=基于口令的密码（Password Based Encryption,PBE）就是一种根据口令生成密钥并用该密钥进行加密的方法。=
=其中加密和解密使用同一个密钥。=

PBE 有很多种实现方法。
  例如 RFC 2898（PKCS#5）和 RFC 7292（PKCS#12）等规范中所描述的PBE 就通过Java的javax.crypto包等进行了实现。
  此外，在通过密码软件 PGP保存密钥时，也会使用PBE。
  
PBE 的意义可以按照下面的逻辑来理解。

想确保重要消息的机密性。
  $\downarrow$ 
将消息直接保存在磁盘上的话，可能会被别人看到。
  $\downarrow$ 
用密钥（CEK）对消息进行加密吧。
  $\downarrow$ 
但是这次又需要确保密钥（CEK）的机密性了。
  $\downarrow$ 
将密钥（CEK）直接保存在磁盘上好像很危险。
  $\downarrow$ 
用另一个密钥（KEK）对密钥进行加密（CEK）吧。
  $\downarrow$ 
等等！这次又需要确保密钥（KEK）的机密性了。进入死循环了。
  $\downarrow$ 
既然如此，那就用口令来生成密钥（KEK）吧。
  $\downarrow$ 
但只用口令容易遭到字典攻击。
  $\downarrow$ 
那么就用口令和盐共同生成密钥（KEK）吧。
  $\downarrow$ 
盐可以和加密后的密钥（CEK）一起保存在磁盘上，而密钥（KEK）可以直接丢弃。
  $\downarrow$ 
口令就记在自己的脑子里吧。

[[./pictures/cryptography/88.png]]

PBE 加密包括下列3个步骤：
（1）生成 KEK；
     =首先，伪随机数生成器会生成一个被称为盐的随机数。=
     将盐和 Alice 输入的口令一起输入单向散列函数，得到的散列值就是用来加密密钥的密钥（KEK）。
     =盐是一种用于防御字典攻击（稍后讲解）的机制。=
（2）生成会话密钥并加密；
    我们使用伪随机数生成器生成会话密钥。会话密钥是用来加密消息的密钥(CEK)。
（3）加密消息。

=其中“盐”和“用KEK加密的会话密钥”需要保存在安全的地方。=

[[./pictures/cryptography/89.png]]

PBE解密包括下列3个步骤。
（1） 重建 KEK；（2）解密会话密钥；（3）解密消息。

=在PBE 加密过程中使用了两次伪随机数生成器，而在 PBE 解密过程中却一次都没有使用。=
**** 盐的作用
=盐是由伪随机数生成器生成的随机数，在生成密钥（KEK）时会和口令一起被输入单向散列函数。=

=盐是用来防御字典攻击的。=
=字典攻击是一种事先进行计算并准备好候选密钥列表的方法。=

[[./pictures/cryptography/90.png]]

如果在生成KEK 时加盐，则盐的长度越大，候选KEK 的数量也会随之增大，事先生成候选KEK 就会变得非常困难。
**** 口令的作用
具有充足长度的密钥是无法用人脑记忆的。
口令也是一样，我们也无法记住具有充足比特数的口令。

=在PBE 中，我们通过口令生成密钥（KEK），再用这个密钥来加密会话密钥（CEK）。=
**** 通过拉伸来改良 PBE
=在生成KEK 时，通过多次使用单向散列函数就可以提高安全性。=
  例如，如果我们将盐和口令先输入单向散列函数，然后将得到的散列值再次输入单向散列函数，将得到的散列值又再次输入单向散列函数•••像这样将经过1000次散列函数所得到的散列值作KEK 来使用，是一个不错的方法。

对于用户来说，执行1000次散列函数并不会带来多大的负担。
因为和用户输入一次口令所花费的时间相比，执行1000次散列函数所需的时间可以忽略不计。

=像这样将单向散列函数进行多次迭代的方法称为拉伸（stretching）。=
*** 如何生成安全的口令
• 使用只有自己才能知道的信息
• 将多个不同的口令分开使用
• 有效利用笔记
• 理解口令的局限性
• 使用口令生成和管理工具
** 随机数 — 不可预测性的源泉

随机数在密码技术中却扮演着十分重要的角色。
  •生成密钥
     用于对称密码和消息认证码。
  •生成密钥对
     用于公钥密码和数字签名。
  •生成初始化向量（IV）
     用于分组密码的 CBC、CFB 和OFB 模式。
  •生成 nonce
     用于防御重放攻击以及分组密码的CTR 模式等。
  •生成盐
     用于基于口令的密码（PBE）等。

为了不让攻击者看穿而使用随机数这一观点，因为“无法看穿”，即 =不可预测性=

随机数的性质
  =随机性——不存在统计学偏差，是完全杂乱的数列=
  =不可预测性——不能从过去的数列推测出下一个出现的数=
  =不可重现性—除非将数列本身保存下来，否则不能重现相同的数列=
  越往下就越严格。

[[./pictures/cryptography/91.png]]

随机性
  判断一个伪随机数列是否随机的方法称为随机数测试，随机数测试的方法有很多种。
  将只具备随机性的伪随机数称为“弱伪随机数”。

不可预测性
  密码中所使用的随机数仅仅具备随机性是不够的，还需要具备避免被攻击者看穿的不可预测性。
  unpredictability
  =指攻击者在知道过去生成的伪随机数列的前提下，依然无法预测出下一个生成出来的伪随机数的性质。=
  =伪随机数生成器的算法是公开的，但伪随机数的种子是保密的。=
  那么如何才能编写出具备不可预测性的伪随机数生成器呢？
    =其实，不可预测性是通过使用其他的密码技术来实现的。=
    =例如，可以通过单向散列函数的单向性和密码的机密性来保证伪随机数生成器的不可预测性。=
    将具备不可预测性的伪随机数称为强伪随机数。

不可重现性
  指无法重现和某一随机数列完全相同的数列的性质。
  仅靠软件是无法生成出具备不可重现性的随机数列的。
    软件只能生成伪随机数列，这是因为运行软件的计算机本身仅具备有限的内部状态。
    而在内部状态相同的条件下，软件必然只能生成相同的数，因此软件所生成的数列在某个时刻一定会出现重复。
  凡是具有周期的数列，都不具备不可重现性。
  要生成具备不可重现性的随机数列，需要从不可重现的物理现象中获取信息，比如周围的温度和声音的变化、用户移动的鼠标的位置信息、键盘输入的时间间隔、放射线测量仪的输出值等，根据从这些硬件中所获取的信息而生成的数列，一般可以认为是具备不可重现性的随机数列。
  =目前，利用热噪声这一自然现象，人们已经开发出能够生成不可重现的随机数列的硬件设备了。=
    例如，英特尔的新型CPU 中就内置了数字随机数生成器，并提供了生成不可重现的随机数的 RDSEED 指令，以及生成不可预测的随机数的 RDRAND 指令。
  将具备不可重现性的随机数称为真随机数。
*** 伪随机数生成器
随机数可以通过硬件来生成，也可以通过软件来生成。

通过硬件生成的随机数列，是根据传感器收集的热量、声音的变化等事实上无法预测和重现的自然现象信息来生成的。
像这样的硬件设备就称为 =随机数生成器（Random Number Generator, RNG）。=

而 =可以生成随机数的软件则称为伪随机数生成器（Pseudo Random Number Generator， PRNG）。=

=伪随机数生成器具有“内部状态”，并根据外部输人的“种子”来生成伪随机数列。=
[[./pictures/cryptography/92.png]]

当有人对伪随机数生成器发出“给我一个伪随机数”的请求时，伪随机数生成器会根据内存中的数值（内部状态）进行计算，并将计算的结果作为伪随机数输出。
随后，为了响应下一个伪随机数请求， 伪随机数生成器会改变自己的内部状态。
=因此，将根据内部状态计算伪随机数的方法和改变内部状态的方法组合起来，就是伪随机数生成的算法。=

=伪随机数的种子是用来对伪随机数生成器的内部状态进行初始化的。=

伪随机数生成器是公开的，但种子是需要自己保密的，这就好像密码算法是公开的，但密钥只能自己保密。
[[./pictures/cryptography/93.png]]
*** 具体的伪随机数生成器
**** 杂乱的方法
这种做法是错误的。
  1.周期太短
  2.如果程序员不能够理解算法的详细内容，那么就无法判断所生成的随机数是否具备不可预测性。
**** 线性同余法
=不能用于密码技术。=

1.根据伪随机数的种子，计算第一个伪随机数 $R_0$
$R_0 = (A \times \ seed \  + C) \  mod \  M$
  在这里，A、C、M都是常量，且A和C需要小M。
2.根据前一个伪随机数计算下一个伪随机数
$R_1 = (A \times R_0 \  + C) \  mod \  M$
$R_2 = (A \times R_1 \  + C) \  mod \  M$
...
线性同余法就是将当前的伪随机数值乘以 A 再加上C，然后将除以M 得到的余数作为下一个伪随机数。
=在线性同余法中，最近一次生成的伪随机数的值就是内部状态，伪随机数的种子被用来对内部状态进行初始化。=

[[./pictures/cryptography/94.png]]

由于伪随机数是除以M得到的余数，因此其范围必定为0~M-1，而且根据A、C和M的值，最终只能生成上述范围中的一部分值（因此周期会缩短）。
=在线性同余法中，只要谨慎选择A、C和M的值，就能够很容易地生成具备随机性的伪随机数列。=
=然而，线性同余法不具备不可预测性，因此不可以将线性同余法用于密码技术。=
  很多伪随机数生成器的库函数（library function）都是采用线性同余法编写的。例如C语言的库函数rand，以及 Java的java.util.Random 类等，都采用了线性同余法。
  因此这些函数是不能用于密码技术的。
我们可以很容易地证明线性同余法不具备不可预测性。
  假设攻击者已知A=3、C=0、M=7。这时，攻击者只要得到所生成的伪随机数中的任意一个，就可以预测出下一个伪随机数。
**** 单向散列函数法
使用单向散列函数（如SHA-1）可以编写出能够生成具备不可预测性的伪随机数列（即强伪随机数）的伪随机数生成器。
[[./pictures/cryptography/95.png]]
这种伪随机数生成器的工作方式如下。
（1）用伪随机数的种子初始化内部状态（计数器）。
（2） 用单向散列函数计算计数器的散列值。
（3） 将散列值作为伪随机数输出。
（4） 计数器的值加1。
（5） 根据需要的伪随机数数量重复（2）~（4）的步骤。

请大家注意，这里输出的伪随机数列实际上相当于单向散列函数的散列值。
=也就是说，要想知道计数器的值，就需要破解单向散列函数的单向性，这是非常困难的，因此攻击者无法预测下一个伪随机数。=
=总而言之，在这种伪随机数生成器中，单向散列函数的单向性是支撑伪随机数生成器不可预测性的基础。=
[[*具备单向性]]

=注意：用刚刚计算出的散列值作为新的内部状态。并不具备不可预测性，你知道这是为什么吗？=
  伪随机数的不可预测性是指不能根据过去的伪随机数列来预测出下一个伪随机数的性质。
  在 Alice设计的伪随机数生成器中，只要对上一个输出的伪随机数计算散列值，就可以得到下一个伪随机数了，因此它不具备不可预测性。
**** 密码法
我们可以使用密码来编写能够生成强伪随机数的伪随机数生成器。
=既可以使用 AES 等对称密码，也可以使用RSA 等公钥密码。=

[[./pictures/cryptography/96.png]]
（1）初始化内部状态（计数器）。
（2）用密钥加密计数器的值。
（3）将密文作为伪随机数输出。
（4）计数器的值加1。
（5）根据需要的伪随机数数量重复 （2）~（4）的步骤。

攻击者要预测下一个伪随机数，需要知道计数器的当前值。
然而，由于之前所输出的伪随机数列相当于密文，因此要知道计数器的值，就需要破译密码，这是非常困难的，因此攻击者无法预测出下一个伪随机数。
=总而言之，在这种伪随机数生成器中，密码的机密性是支撑伪随机数生成器不可预测性的基础。=
**** ANSI X9.17
这里所介绍的伪随机数生成器，就被用于密码软件PGP中。

[[./pictures/cryptography/97.png]]

（1） 初始化内部状态。
（2） 将当前时间加密生成掩码。
（3） 对内部状态与掩码求 XOR。
（4） 将步骤（3）的结果进行加密。
（5） 将步骤（4）的结果作为伪随机数输出。
（6） 对步骤（4）的结果与掩码求 XOR。
（7） 将步骤（6）的结果加密。
（8） 将步骤（7）的结果作为新的内部状态。
（9） 重复步骤（2） ~ （8）直到得到所需数量的伪随机数。

=使用掩码对比特序列进行随机翻转。=

那么，攻击者是否能通过将伪随机数进行反算来看穿内部状态与掩码的 XOR呢？
  =不能，因为要看穿这个值，攻击者必须要破解密码。=
  因此，根据过去输出的伪随机数列，攻击者无法推测出伪随机数生成器的内部状态。

那么，攻击者是否能够从伪随机数推测出新的内部状态呢？
  不能，因为要算出新的内部状态，只知道上一个伪随机数是不够的，还必须知道掩码以及加密密钥才行。

在这种伪随机数生成器中， =密码的使用保证了无法根据输出的伪随机数列来推测内部状态。=
=换言之，伪随机数生成器的内部状态是通过密码进行保护的。=
**** 其他算法
一个随机数算法再优秀，如果它不具备不可预测性，那么就不能用于密码学和安全相关用途。

举个例子，有一个有名的伪随机数生成算法叫作梅森旋转算法（Mersenne twister），但它并不能用于安全相关的用途。
  和线性同余法一样，只要观察足够长的随机数列，就能够对之后生成的随机数列进行预测。
Java 中有一个用于生成随机数列的类，名叫java.util.Random，然而这个类也不能用于安全相关用途。如果要用于安全相关用途，可以使用另一个名叫 java.security.SecureRandom 的类。
Ruby 中也分别有Random 类和 SecureRandom 模块，在安全相关用途中应该使用 SecureRandom，而不是Random。
*** 对伪随机数生成器的攻击
**** 对种子进行攻击
伪随机数的种子和密码的密钥同等重要。
  如果攻击者知道了伪随机数的种子，那么他就能够知道这个伪随机数生成器所生成的全部伪随机数列“。
  因此，伪随机数的种子不可以被攻击者知道。
=要避免种子被攻击者知道，我们需要使用具备不可重现性的真随机数作为种子。=
**** 对随机数池进行攻击
会事先在一个名为随机数池（random pool）的文件中积累随机比特序列。

=当密码软件需要伪随机数的种子时，可以从这个随机数池中取出所需长度的随机比特序列来使用。=

随机数池的内容不可以被攻击者知道，否则伪随机数的种子就有可能被预测出来。
** PGP — 密码技术的完美组合
PGP 是于 1990年左右由菲利普•季默曼（Philip Zimmermann）个人编写的密码软件，现在依然在世界上被广泛使用。

此外还有一个由 GNU 遵照 OpenGPG （RFC4880）规范编写的叫作 GnuPG （GNU Privacy Guard）的自由软件。

=OpenPGP 是对密文和数字签名格式进行定义的标准规格（RFC1991、RFC2440、RFC4880、 RFC5581, RFC6637 )。=

[[./pictures/cryptography/98.png]]
RFC6637

GNU Privacy Guard （ GnuPG、GPG） 是一款基于 OpenPGP标准开发的密码学软件“，支持加密、数字签名、密钥管理、S/MIME、ssh 等多种功能。
*** PGP 的功能
**** 对称密码
PGP 支持用对称密码进行加密和解密。
=对称密码可以单独使用，也可以和公钥密码组合成混合密码系统使用。=
可以使用的对称密码算法包括 AES、IDEA、CAST、三重DES、Blowfish、Twofish、 Camellia等。
**** 公钥密码
PGP 支持生成公钥密码的密钥对，以及用公钥密码进行加密和解密。
=实际上并不是使用公钥密码直接对明文进行加密，而是使用混合密码系统来进行加密操作。=

可以使用的公钥密码算法包括 RSA 和EIGamal 等。
**** 数字签名
PGP 支持数字签名的生成和验证，也可以将数字签名附加到文件中，或者从文件中分离出数字签名。

可以使用的数字签名算法包括 RSA、DSA、ECDSA（椭圆曲线 DSA）、EdDSA（爱德华兹曲线 DSA）等。
**** 单向散列函数
PGP 可以用单向散列函数计算和显示消息的散列值。
可以使用的单向散列函数算法包括 SHA-1、SHA-224、SHA-256、SHA-384、SHA-512和 RIPEMD-160 等。MD5也依然可以使用，但并不推荐。
**** 证书
PGP 可以生成 OpenGPG 中规定格式的证书，以及与X.509规范兼容的证书。
=此外，还可以颁发公钥的作废证明（revocation certificate），并可以使用CRL 和 OSCP 对证书进行校验。=
**** 压缩
PGP 支持数据的压缩和解压缩，压缩采用ZIP、ZLIB、BZIPZ 等格式。
**** 文本数据
PGP 可以将二进制数据和文本数据相互转换。

radix-64 格式是在邮件等场合中经常使用的base64编码的基础上，增加了检测数据错误的校验和的版本。
base64编码是一种可以将任何二进制数据都用A~Z、a~z、0~9、+、/共64 个字符再加上=（用于末尾填充）来表示的格式。
**** 大文件的拆分和拼合
PGP 可以将一个大文件拆分成多个文件，反过来也可以将多个文件拼合成一个文件。
**** 钥匙串管理
PGP 可以管理所生成的密钥对以及从外部获取的公钥。
=用于管理密钥的文件称为钥匙串 (key ring ).=
*** 生成密钥对
~gpg2 --full-gen-key~
~gpg2 --export --armor XX~ 显示公钥内容
*** 加密与解密
[[./pictures/cryptography/99.png]]

消息经过混合密码系统进行加密，然后转换成报文数据（文本数据）。
=用公钥密码加密会话密钥，用对称密码加密消息就是混合密码系统的特点。=

[[./pictures/cryptography/100.png]]

PGP 的私钥是保存在用户的钥匙串中的。
为了防止钥匙串被盗，私钥都是以加密状态保存的，并在保存时使用了基于口令的密码（PBE)。
[[*基于口令的密码（PBE）]]
=如果攻击者想要使用你的私钥，就必须先窃取保存私钥的钥匙串，然后再破译加密私钥的密码。=
*** 生成和验证数字签名
顺便提一下，对于是否要将报文数据转换成文本数据，在 PGP 中是可以选择的。

[[./pictures/cryptography/101.png]]

[[*基于口令的密码（PBE）]]
[[*数字签名 — 消息到底是谁写的]]
[[*对称密码（共享密钥密码） — 用相同的密钥进行加密和解密]]
[[*公钥密码 — 用公钥加密，用私钥解密]]

[[./pictures/cryptography/102.png]]
*** 生成数字签名并加密以及解密并验证数字签名
对消息生成数字签名以及对消息进行压缩和加密这两个过程，并将两者的结果拼合在一起形成了报文数据（文本数据）。
对于是否要将报文数据转换成文本数据，在 PGP 中是可以选择的。
=这里的加密对象并不仅仅是消息本身，而是将数字签名和消息拼合之后的数据。=

[[./pictures/cryptography/103.png]]

[[*基于口令的密码（PBE）]]
[[*数字签名 — 消息到底是谁写的]]
[[*对称密码（共享密钥密码） — 用相同的密钥进行加密和解密]]
[[*公钥密码 — 用公钥加密，用私钥解密]]

对接收到的报文数据进行解密和解压缩，并对所得到的消息验证数字签名这两个过程。
最终得到的结果包括消息本身以及对数字签名的验证结果。
=这里解密所得到的并不仅仅是消息本身，而是将数字签名和消息拼合之后的数据。=

[[./pictures/cryptography/104.png]]
*** 信任网
=一种确认公钥合法性的方法=

在使用PGP 时，确认自己所得到的公钥是否真的属于正确的人（公钥合法性）是非常重要的，因为公钥可能会通过中间人攻击被替换。
[[*中间人攻击]]

=证书就是确认公钥合法性的方法之一。=
[[*证书 — 为公钥加上数字签名]]
  证书就是由认证机构对公钥所施加的数字签名，通过验证这个数字签名就可以确认公钥合法性。

然而，PGP 中却没有使用认证机构，而是采用了一种叫作 =信任网（web oftrust）的方法。=
=在这种方法中，PGP 用户会互相对对方的公钥进行数字签名。=
=信任网的要点是“不依赖认证机构，而是建立每个人之间的信任关系”。换言之，就是能够自己决定要信任哪些公钥。=

• 场景1：通过自己的数字签名进行确认
• 场景2：通过自己完全信任的人的数字签名进行确认
• 场景3：通过自己有限信任的多个人的数字签名进行确认

在PGP 中，用户可以设置对每个公钥所有者的所有者信任（owner trust）级别
[[./pictures/cryptography/105.png]]

[[*证书的层级结构]]

=公钥合法性与所有者信任是不同的=
  “公钥是否合法”与“所有者是否可信”是两个不同的问题

=所有者信任级别是因人而异的=
  PGP 的用户可以自行设置对谁进行何种程度的信任，PGP 就是根据信任数据库中的设置来判断所得到的公钥是否属于本人的。
[[./pictures/cryptography/106.png]]
** SSL/TLS - 一为了更安全的通信
SSL/TLS 中综合运用了本书中所学习的对称密码、消息认证码、公钥密码、数字签名、伪随机数生成器等密码技术。

=严格来说， SSL（Secure Socket Layer） 与 TLS （Transport Layer Security）是不同的，TLS 相当于是SSL的后续版本。=

[[./pictures/cryptography/107.png]]


要确保机密性，可以使用 =对称密码=
  由于对称密码的密钥不能被攻击者预测，因此我们 =使用伪随机数生成器来生成密钥= 。
  若要将对称密码的密钥发送给通信对象，可以使用 =公钥密码或者Diffie-Hellman 密钥交换。=

完整性
要识别篡改，对数据进行认证，可以使用 =消息认证码。=
  =消息认证码是使用单向散列函数来实现的。=

认证
要对通信对象进行认证，可以使用 =对公钥加上数字签名所生成的证书。=

=SSL/TLS 也可以保护其他的协议=
[[./pictures/cryptography/108.png]]

=SSL/TLS 提供了一种密码通信的框架，这意味着 SSL/TLS 中使用的对称密码、公钥密码、 数字签名、单向散列函数等技术，都是可以像零件一样进行替换的。=
为此，SSL/TLS 就像事先搭配好的盒饭一样，规定了一些密码技术的“推荐套餐”，这种推荐套餐称为 =密码套件（cipher suite）。=
*** SSL 与TLS 的区别
SSL 已经于 1995年发布了3.0版本，但在2014 年，SSL 3.0协议被发现存在可能导致POODLE 攻击的安全漏洞（CVE-2014-3566），因此SSL3.0已经不安全了。

TLS （ Transport Layer Security，传输层安全）是IETF 在SSL 3.0的基础上设计的协议。

在 1999 年作 RFC 2246 发布的 TLS 1.0，实际上相当于 SSL 3.1。

2006年，TLS 1.1 以RFC 4346的形式发布，这个版本中增加了针对CBC攻击的对策，并加入了 AES 对称密码算法。

TLS 1.2中新增了对GCM（8.5节）、CCM 认证加密（Authenticated Encryption）的支持，此外还新增了 HMAC-SHA256，并删除了 IDEA 和 DES，将伪随机函数 （PRF）改为基于SHA-256来实现。
*** 使用 SSL/TLS 进行通信
本节的内容是基于 TLS 1.2（RFC5246）编写的

=TLS 协议是由TLS 记录协议 （TLS record protocol）和 TLS 握手协议（TLS handshake protocol）这两层协议叠加而成的。=
=位于底层的TLS 记录协议负责进行加密，而位于上层的TLS 握手协议则负责除加密以外的其他各种操作。=
=上层的TLS握手协议又可以分为4个子协议。=
[[./pictures/cryptography/109.png]]
**** TLS 记录协议
TLS 记录协议中使用了对称密码和消息认证码，
=但是具体的算法和共享密钥则是通过后面将要介绍的握手协议在服务器和客户端之间协商决定的。=

=负责消息的压缩、加密以及数据的认证=
[[./pictures/cryptography/110.png]]

首先，消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。
  =压缩算法需要与通信对象协商决定。=
接下来，经过压缩的片段会被加上消息认证码，这是为了保证完整性，并进行数据的认证。
  =通过附加消息认证码的 MAC值，可以识别出篡改。=
  =与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编号。=
  =单向散列函数的算法，以及消息认证码所使用的共享密钥都需要与通信对象协商决定。=
再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。
  加密使用 CBC模式，CBC模式的初始化向量（IV）通过主密码（master secret ）生成，
  =而对称密码的算法以及共享密钥需要与通信对象协商决定。=
最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头 （header）就是最终的报文数据。
  =其中，数据类型为TLS 记录协议所承载的4个子协议（握手协议、密码规格变更协议、警告协议、应用数据协议）的其中之一。=
**** TLS 握手协议
=分为下列4个子协议：握手协议、密码规格变更协议、警告协议和应用数据协议=
***** 握手协议
=负责在客户端和服务器之间协商决定密码算法和共享密钥。=
=基于证书的认证操作也在这个协议中完成。=
这个协议大致相当于下面这段对话。
客户端：“你好。我能够理解的密码套件有 RSA/3DES，或者 DSS/AES，请问我们使用哪一种密码套件来通信呢？"
服务器：“你好。我们就用 RSA/3DES 来进行通信吧，这是我的证书。”
=在服务器和客户端之间通过握手协议协商一致之后，就会相互发出信号来切换密码。负责发出信号的就是下面要介绍的密码规格变更协议。=

=由于握手协议中的信息交换是在没有加密的情况下进行的（即使用“不加密”这一密码套件），也就是说，在这一协议中所收发的所有数据都可能被窃听者 Eve 窃听，因此在这一过程中必须使用公钥密码或者Diffie-Hellman密钥交换。=

[[./pictures/cryptography/111.png]]

（1）ClientHello（客户端一服务器）
    =“客户端随机数” 是一个由客户端生成的不可预测的随机数，我们在后面的步骤中需要用到它。=
    “会话ID”是当客户端和服务器希望重新使用之前建立的会话（通信路径）时所使用的信息。
（2）ServerHello（客户端一服务器）
    服务器根据客户端在 ClientHello 消息中发送过来的信息确定通信中使用的“版本号”“密码套件”和“压缩方式”。
    =“服务器随机数”是一个由服务器生成的不可预测的随机数。这个随机数必须与客户端生成的随机数无关，我们在后面的步骤中需要用到它。=
（3）Certificate（客户端服务器）
    证书清单是一组X.509v3证书序列，首先发送的是服务器（发送方）的证书，然后会按顺序发送对服务器证书签名的认证机构的证书。
（4）ServerKeyExchange（客户端一服务器）
    当 Certificate 消息不是以满足需求时，服务器会通过 ServerKeyExchange 消息向客户端发送一些必要信息。具体所发送的信息内容会根据所使用的密码套件而有所不同。
（5）CertificateRequest（客户端服务器）
    CertificateRequest 消息用于服务器向客户端请求证书，这是为了进行客户端认证。
    服务器会向客户端发送下列信息。
    • 服务器能够理解的证书类型清单
    • 服务器能够理解的认证机构名称清单
（6）ServerHelloDone（客户端一服务器）
    服务器：“问候到此结束。”
（7）Certificate（客户端一服务器）
    客户端会将自己的证书同 Certificate 消息一起发送给服务器。
    服务器读取客户端的证书并进行验证。
    当服务器没有发送 CertificateRequest 消息时，客户端不会发送 Certificate 消息。
（8）ClientKeyExchange（客户端一服务器）
    当密码套件中包含 RSA 时，会随 ClientKeyExchange 消息一起发送经过加密的预备主密码。
    当密码套件中包含Diffie-Hellman密钥交换时，会随 ClientKeyExchange 消息一起发送 Diffie-Hellman 的公开值。
    =预备主密码（pre-master secret ）是由客户端生成的随机数，之后会被用作生成主密码的种子。=
    =这个值会在使用服务器的公钥进行加密后发送给服务器。=
    =预备主密码的生成方法我们将稍后介绍。=
    =根据预备主密码，服务器和客户端会计算出相同的主密码，然后再根据主密码生成下列比特序列（密钥素材）。=
     • 对称密码的密钥
     • 消息认证码的密钥
     • 对称密码的 CBC 模式中使用的初始化向量（IV）
（9）CertificateVerify（客户端一服务器）
    客户端只有在服务器发送 CertificateRequest 消息时才会发送 CertificateVerify 消息。
    这个消息的目的是向服务器证明自己的确持有客户端证书的私钥。
    =为了实现这一目的，客户端会计算“主密码”和“握手协议中传送的消息”的散列值，并加上自己的数字签名后发送给服务器。=
（10）ChangeCipherSpec（客户端一服务器）
    =实际上，ChangeCipherSpec 消息并不是握手协议的消息，而是密码规格变更协议的消息。=
    在 ChangeCipherSpec 消息之前，客户端和服务器之间已经交换了所有关于密码套件的信息，因此在收到这一消息时，客户端和服务器会同时切换密码。
    在这一消息之后，TLS 记录协议就开始使用双方协商决定的密码通信方式了。
（11）Finished（客户端一服务器）
    =由于已经完成了密码切换，因此 Finished 消息是使用切换后的密码套件来发送的。=
    实际负责加密操作的是 TLS
    =Finished 消息的内容是固定的，因此服务器可以将收到的密文解密，来确认所收到的 Finished 消息是否正确。=
      通过这一消息，就可以确认握手协议是否正常结束，密码套件的切换是否正确。
（12）ChangeCipherSpec（客户端服务器）
    这次轮到服务器发送 ChangeCipherSpec 消息了。
（13）Finished（客户端服务器）
    和客户端一样，服务器也会发送 Finished 消息。
    =这一消息会使用切换后的密码套件来发送。实际负责加密操作的是TLS 记录协议。=
（14）切换至应用数据协议
    在此之后，客户端和服务器会使用应用数据协议和 TLS 记录协议进行密码通信。

从结果来看，握手协议完成了下列操作。
• 客户端获得了服务器的合法公钥，完成了服务器认证
• 服务器获得了客户端的合法公钥，完成了客户端认证（当需要客户端认证时）
• 客户端和服务器生成了密码通信中使用的共享密钥
• 客户端和服务器生成了消息认证码中使用的共享密钥
***** 密码规格变更协议
=密码规格变更协议是 TLS 握手协议的一部分，负责向通信对象传达变更密码方式的信号。=
=当协议中途发生错误时，就会通过下面的警告协议传达给对方。=
***** 警告协议
TLS 的警告协议 （alert protocol） 是TLS 握手协议的一部分
=警告协议负责在发生错误时将错误传达给对方。=
=如果没有发生错误，则会使用下面的应用数据协议来进行通信。=

=当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时， 会使用该协议。=
***** 应用数据协议
应用数据协议是 TLS 握手协议的一部分。
=应用数据协议是将 TLS 上面承载的应用数据传达给通信对象的协议。=

当TLS 承载HTTP时，HTTP 的请求和响应就会通过TLS 的应用数据协议和 TLS 记录协议来进行传送。
**** 主密码
主密码是 TLS客户端和服务器之间协商出来的一个秘密的数值。
这个数值非常重要，TLS 密码通信的机密性和数据的认证全部依靠这个数值。
主密码是一个48字节（384 比特）的数值。

主密码是客户端和服务器根据下列信息计算出来的。
=预备主密码=
=客户端随机数=
=服务器随机数=

当使用RSA公钥密码时，客户端会在发送 ClientKeyExchange 消息时，将经过加密的预备主密码一起发送给服务器。
当使用 Diffie-Hellman 密钥交换时，客户端会在发送 ClientKeyExchange 消息时，将 Diffie-Hellman 的公开值一起发送给服务器。根据这个值，客户端和服务器会各自生成预备主密码。
  关于客户端和服务器为什么能够生成出相同的值。
  [[*Diffie-Hellman 密钥交换]]

=客户端随机数和服务器随机数的作用相当于防止攻击者事先计算出密钥的盐。=
=当根据预备主密码计算主密码时，需要使用基于密码套件中定义的单项散列函数（如SHA- 256）来实现的伪随机函数（Pseudo Random Function, PRF）。=

[[./pictures/cryptography/112.png]]

主密码用于生成下列6种信息。
• 对称密码的密钥（客户端 $\leftarrow$ 服务器）
• 对称密码的密钥（客户端 $\rightarrow$ 服务器）
• 消息认证码的密钥（客户端 $\leftarrow$ 服务器）
• 消息认证码的密钥（客户端 $\rightarrow$ 服务器）
• 对称密码的CBC模式所使用的初始化向量（客户端 $\leftarrow$ 服务器）
• 对称密码的CBC 模式所使用的初始化向量（客户端 $\rightarrow$ 服务器）

[[./pictures/cryptography/113.png]]
*** 对 SSL/TLS 的攻击
**** 对各个密码技术的攻击
然而，SSL/TLS 作为框架的特性也正是在这里能够得以体现。
SSL/TLS 并不依赖于某种特定的密码技术，当发现某种对称密码存在弱点时，今后只要选择不包含该对称密码的密码套件就可以了。
**** OpenSSL 的心脏出血漏洞
具体来说，由于 OpenSSL 在 TLS 心跳扩展功能中对于请求的数据大小没有进行检查，从而导致误将内存中与该请求无关的信息返回给请求者，这就是心脏出血漏洞。
要应对这一漏洞，可以将 OpenSSL 更新到已消除心脏出血漏洞的版本，或者加上禁用心跳扩展的选项重新编译 OpenSSL。
  详情请参见 CVE-2014-0160。
**** SSL 3.0的漏洞与 POODLE 攻击
SSL 3.0中对CBC模式加密时的分组填充操作没有进行严格的规定，而且填充数据的完整性没有受到消息认证码的保护，POODLE攻击正是利用了这一漏洞来窃取秘密信息的。
POODLE 攻击的本质就是我们前面在CBC模式的介绍中提到的填充提示攻击。
[[*填充提示攻击]]
因此，要有效抵御 POODLE 攻击，必须禁用 SSL 3.0，详情请参见 CVE-2014-3566。
**** FREAK攻击与密码产品出口管制
其攻击方法是强制 SSL/TLS服务器使用一种名为 RSA Export Suites 的强度较低的密码套件。
要实现FREAK攻击，除了需要SSL/TLS服务器具有该漏洞，同时还需要用户的web 浏览器（HTTP 客户端）接受使用 RSA Export Suites 来进行通信。
FREAK攻击也是一种中间人攻击，当浏览器与 Web 服务器协商 SSL/TLS 的密码套件时 （此时的通信内容还没有被加密），攻击者Mallory 可以介人其中，强制双方使用RSA Export Suites。
**** 对伪随机数生成器的攻击
这个bug 存在于伪随机数生成器中。
由于SSL 中使用的伪随机数生成器的种子都在时间和进程编号等可预测的范围内，因此所得到的密钥范围实际上非常小。
**** 利用证书的时间差进行攻击
要验证证书需要使用最新版的CRL（证书作废清单）。
而 Web 浏览器如果没有获取最新版的CRL，即便使用 SSL/TLS也无法保证通信的安全。
*** SSL/TLS 用户的注意事项
不要误解证书的含义
  即便对方拥有合法的证书，也不代表你就可以放心地发送信用卡号， 因为仅通过 SSL/TLS 是无法确认对方是否在从事信用卡诈骗的。
密码通信之前的数据是不受保护的
密码通信之后的数据是不受保护的
** 密码技术与现实社会 — 我们生活在不完美的安全中
密码学家的工具箱
对称密码是一种用相同的密钥进行加密和解密的技术，用于确保消息的机密性。
  在对称密码的算法方面，目前主要使用的是AES。
  =尽管对称密码能够确保消息的机密性，但需要解决将解密密钥配送给接收者的密钥配送问题。=
公钥密码是一种用不同的密钥进行加密和解密的技术，和对称密码一样用于确保消息的机密性。
  使用最广泛的一种公钥密码算法是 RSA，除此之外还有 EIGamal 和 Rabin 等算法，以及与其相关 Diffie-Hellman 密钥交换（DH）和椭圆曲线 Diffie-Hellman 密钥交换（ECDH）等技术。
  =和对称密码相比，公钥密码的速度非常慢，因此一般都会和对称密码一起组成混合密码系统来使用。=
  =公钥密码能够解决对称密码中的密钥交换问题，但存在通过中间人攻击被伪装的风险， 因此需要对带有数字签名的公钥进行认证。=
单向散列函数是一种将长消息转换为短散列值的技术，用于确保消息的完整性。
  今后我们应该主要使用的算法包括目前已经在广泛使用的SHA-2（SHA-224、SHA-256、SHA-384、SHA-512），以及具有全新结构的 SHA-3（Keccak）算法。
  =单向散列函数可以单独使用，也可以作为消息认证码、数字签名以及伪随机数生成器等技术的组成元素来使用。=
消息认证码是一种能够识别通信对象发送的消息是否被篡改的认证技术，用于验证消息的完整性，以及对消息进行认证。
  消息认证码的算法中，最常用的是利用单向散列函数的 HMAC。
  =消息认证码能够对通信对象进行认证，但无法对第三方进行认证。=
  =此外，它也无法防止否认。=
  =消息认证码也可以用来实现认证加密。=
数字签名是一种能够对第三方进行消息认证，并能够防止通信对象做出否认的认证技术。
  数字签名的算法包括 RSA、EIGamal、DSA、椭圆曲线 DSA（ECDSA）、爱德华兹曲线 DSA （EDDSA）等。
  =公钥基础设施（PKI）中使用的证书，就是对公钥加上认证机构的数字签名所构成的。=
    =我的理解：证书 = 内容“下级的公钥” + 上级的私钥对内容进行的数字签名=  
  要验证公钥的数字签名，需要通过某种途径获取认证机构自身的合法公钥。
伪随机数生成器是一种能够生成具备不可预测性的比特序列的技术， =由密码和单向散列函数等技术构成。=
  伪随机数生成器用于生成密钥、初始化向量和 nonce 等。
[[./pictures/cryptography/114.png]]

密码与认证
  例如，公钥密码是一种很重要的技术，但如果无法确认自己所持有的公钥的合法性，即是否是经过认证的公钥，公钥密码就无法发挥作用。
  
  此外，即便在使用高强度的密码算法来确保机密性的情况下，依然存在像填充提示攻击这样通过伪造密文来窃取明文相关信息的攻击方式。
  =在这种情况下，我们需要对接收到的密文进行认证，判断其是不是通过合法的加密过程生成出来的，这样才能有效地确保信息的机密性。=

密码技术的框架化
  =框架的特点就是能够对其中作组成元素的技术进行替换。=
  =使用框架能够提高密码技术系统的重用性，也能够提高系统的强度。=
  =通过将单独的密码技术像零件一样组合起来，并根据需要进行替换，能够实现更长期的、 更高的安全性。=

密码技术与压缩技术
  [[./pictures/cryptography/115.png]]

  通过保护较短的密钥来保护较长的明文，这样的做法可以称为机密性的压缩。

  通过检查较短的散列值来确认较长的明文的完整性，这样的做法可以称为完整性的压缩。   

  通过较短的认证符号来对较长的消息进行认证，这样的做法可以称为认证的压缩。

  为了对伪随机数列赋予不可预测性，我们使用了随机数种子，这可以称为不可预测性的压缩。

  • 密钥是机密性的精华
  • 散列值是完整性的精华
  • 认证符号（MAC值和签名）是认证的精华
  • 种子是不可预测性的精华

[[./pictures/cryptography/116.png]]
** 虚拟货币——比特币

=比特币是一种虚拟货币，也叫密码学货币。=

=比特币交易时使用的私钥一旦遗失，所关联的比特币就再也无法找回了。=

比特币之所以能够成为一种流通的货币，完全依赖于全世界所有比特币用户组成的 P2P网络（Peer to Peer Network）。

=比特币是一种基于 P2P网络的支付结算系统，=

比特币交易是在比特币地址之间完成的。
  人们会每一次比特币交易创建不同的地址。当然，在捐赠等场景中，也会反复使用同一个地址。
  =比特币中使用的地址是由公钥的散列值生成的。=
  具体来说，将椭圆曲线 DSA 的公钥输入SHA-256 和 RIPEMD-160两个单向散列函数来求出散列值，为其附加一些信息后再通过Base58Check 进行编码，转换成字符串。

比特币交易也是一样，需要使用比特币的客户端，这种客户端称为 =钱包（wallet）。=
  =用户通过钱包生成密钥对，并据此在互联网上进行交易。=
  =其中，公钥用于接收比特币，而私钥用于支付比特币。=
  私钥保存在钱包中，和一般的密钥对的管理方法一样，不能泄露给别人。

区块链
  =区块链就是保存比特币全部交易记录的公共账簿。=
  全世界使用比特币进行的所有交易都被记录在这一本公共账簿中。
  顾名思义，区块链就是将交易以区块为单位组织起来，并形成一根链条。

  [[./pictures/cryptography/117.png]]

“从 Alice 的地址 A 向Bob 商店的地址B支付1 BTC”这样一个场景。
相当于
  • 地址A 所能够支付的比特币数量减少1BTC
  • 地址B 所能够支付的比特币数量增加1BTC
因此，如果我们有一本公共账簿，记录了比特币体系中所有的地址至今为止所有的交易，那么对于任意一个地址，我们都能够计算出当前它所拥有的比特币数量，而区块链正是用于实现这一目的的这本公共账簿。

=区块的添加=
  比特币的首付款是以交易（transaction）为单位来进行的， =若干条交易会被合并为一个区块， 并被添加到区块链中。=
  =当P2P 网络确认区块的添加后，相应的交易也就成立了。=
  [[./pictures/cryptography/118.png]]

  =一个区块是由若干条交易以及一个区块头所组成的，区块头中保存了“上一个区块的区块头的散列值”。= HX
  =此外，区块头中还保存着“本区块所有交易的整体散列值。= TX
  =区块头中还保存着一个名nonce 的任意数值，以及时间戳（图中省略）等信息。=
  
  假设区块2中记录的某一条交易中的1个比特被修改，那么散列值T2就需要重新计算，这样一来区块头2的内容就会发生变化，因此区块头3中的散列值H3也需要重新计算。
  =也就是说，一旦对区块链中的数据进行任何改动，都需要重建所改动的区块之后的所有区块的数据。=
  =由此可见，区块头中的两个散列值有效增加了篡改区块链数据的难度。=

=交易=
  所谓交易，就是对“从一个地址向另一个地址转移了多少比特币”
  例如，假设 Alice 从 Bob 商店购买了商品，需要向 Bob 商店支付1BTC 的货款。
  • Bob 商店创建公钥密钥对（公钥B和私钥b）
  • Bob 商店根据公钥 B生成地址 B，并发送给 Alice
  • Alice 创建公钥密钥对（公钥A 和私钥 a）
  • Alice 创建交易：“从地址A 向地址B发送1BTC”。 =此时，Alice使用私钥a对交易签署数字签名=
  • Alice 将这条交易发送至P2P 网络，即向全世界广播这条交易
  • 随后，Alice创建的交易与其他一些交易一起被合并为一个区块，并被添加到区块链中
  • 添加的区块被P2P 网络确认后，“从地址 A 向地址B发送1BTC”的交易就成立了

  在创建交易时运用了数字签名技术。比特币中使用的数字签名算法为椭圆曲线DSA，其中使用的椭圆曲线方程为 $x^{3} = y^{3} + 7$

=挖矿=
  随着全世界的比特币交易不断增加，区块链也会随之不断增长，这就意味着P2P 网络中的 “某个人”在负责将新的区块添加到区块链。
  =有趣的是，“将新的区块添加到区块链”这一行为，正好就相当于“创造新的比特币余额”=
  =向区块链中添加区块就好像从金矿中挖出比特币一样， 因此称为挖矿（mining），而从事挖矿的人则称为矿工（miner）。=

  按照比特币协议的规定，成功将区块添加到区块链的矿工将获得挖矿奖励（reward）以及该区块所有交易的手续费（transaction fee）。2015 年，每个区块的挖矿奖励为25 BTC（约75万日元）。

  =为了防止比特币被伪造，矿工必须证明自己确实完成了规定量的工作，这种证明称为工作量证明（Proofof Work. Pow），工作量证明是通过散列值来实现的。=

  要向区块链添加新的区块，矿工需要生成合法的区块头，而且区块头中“前一区块的散列值”的格式是有规定的，它的前面若个比特必须为0。
  区块头中之所以需要一个称为 nonce 的任意数值，就是为了凑出像上面这样前面若干比特都是0的散列值。
  =也就是说，矿工需要不断更换nonce 进行尝试，直到计算出符合要求的散列值为止。=

  比特币系统中大约每10分钟会添加一个新的区块，为了保持这样的恒定速率，计算的难度（即所需的0的个数）会不断地被调整。

=确认=
  =由于全世界有大量的矿工在不断尝试添加新的区块，因此如果在某一个时间点上有多个矿工同时计算出了符合要求的散列值，区块链就有可能会产生分支。=

  由于比特币是一个P2P 网络， 因此无法确定是哪一个区块先达到的节点，比如节点1可能先收到区块A，节点2可能先收到区块B，这样就会造成节点1和节点2的区块链产生差异。
  =到底哪个区块才应该被添加到区块链中呢？P2P 网络需要对此做出判断，这个动作称为确认。=
  =当产生分支时，P2P 网络的各个节点会选择计算量大的分支继续工作，从而抑制区块链继续产生分支。=

  比特币系统假设善意的矿工所拥有的计算资源要大于恶意的矿工所拥有的计算资源，这也是比特币系统得以正常运作的前提。

  [[./pictures/cryptography/119.png]]

比特币不存在管理它的国家和中央银行，那么我们到底能不能信任比特币呢？
“信任使用比特币进行交易的对象”与信任使用现金进行交易的对象是差不多的，这取决于你是否相信在向对方支付比特币之后能够按照约定收到商品。

